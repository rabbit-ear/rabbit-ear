/* Rabbit Ear 0.9.33 alpha 2023-02-02 (c) Kraft, MIT License */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ear=t()}(this,(function(){"use strict";const e="undefined",t="number",r="object",s="index",o="vertices",n="edges",a="faces",c="boundaries",i="vertices_coords",l="edges_vertices",d="faces_edges",m="edges_assignment",p="edges_foldAngle",g="faces_layer",u="boundary",v="front",h="back",_="foldedForm",b="black",y="white",E="none",A=typeof window!==e&&typeof window.document!==e;typeof process!==e&&null!=process.versions&&process.versions.node;const k=typeof self===r&&self.constructor&&"DedicatedWorkerGlobalScope"===self.constructor.name;var x="graph could not planarize",O="manifold required",M="cycle not allowed",w="planar boundary detection error, bad graph",j="circular edges not allowed",F="replace() index < value. indices parameter modified",P="replace() generated undefined",C="foldAngles cannot be determined from flat-folded faces without an assignment",S="WebGl not Supported",N="only convex faces are supported",z="window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",$="non-convex triangulation requires vertices_coords";const V={window:void 0};A&&(V.window=window);const RabbitEarWindow=()=>{if(void 0===V.window)throw new Error(z);return V.window};var T=Object.create(null);const L=1e-6,I=180/Math.PI,B=Math.PI/180,R=2*Math.PI;var U=Object.freeze({__proto__:null,D2R:B,EPSILON:L,R2D:I,TWO_PI:R});const fnTrue=()=>!0,fnSquare=e=>e*e,fnAdd=(e,t)=>e+(t||0),fnNotUndefined=e=>void 0!==e,fnVecToAngle=e=>Math.atan2(e[1],e[0]),fnAngleToVec=e=>[Math.cos(e),Math.sin(e)],fnEpsilonEqual=(e,t,r=L)=>Math.abs(e-t)<r,fnEpsilonCompare=(e,t,r=L)=>fnEpsilonEqual(e,t,r)?0:Math.sign(t-e),fnEpsilonEqualVectors=(e,t,r=L)=>{for(let s=0;s<Math.max(e.length,t.length);s+=1)if(!fnEpsilonEqual(e[s]||0,t[s]||0,r))return!1;return!0},include=(e,t=L)=>e>-t,exclude=(e,t=L)=>e>t,D=fnTrue,q=fnTrue,G=include,W=exclude,includeS=(e,t=L)=>e>-t&&e<1+t,excludeS=(e,t=L)=>e>t&&e<1-t,clampLine=e=>e,clampSegment=e=>e<-L?0:e>1.000001?1:e;var H=Object.freeze({__proto__:null,clampLine:clampLine,clampRay:e=>e<-L?0:e,clampSegment:clampSegment,exclude:exclude,excludeL:q,excludeR:W,excludeS:excludeS,fnAdd:fnAdd,fnAngleToVec:fnAngleToVec,fnEpsilonCompare:fnEpsilonCompare,fnEpsilonEqual:fnEpsilonEqual,fnEpsilonEqualVectors:fnEpsilonEqualVectors,fnNotUndefined:fnNotUndefined,fnSquare:fnSquare,fnTrue:fnTrue,fnVecToAngle:fnVecToAngle,include:include,includeL:D,includeR:G,includeS:includeS});const magnitude=e=>Math.sqrt(e.map(fnSquare).reduce(fnAdd,0)),magnitude2=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]),magnitude3=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]),magSquared=e=>e.map(fnSquare).reduce(fnAdd,0),normalize=e=>{const t=magnitude(e);return 0===t?e:e.map((e=>e/t))},normalize2=e=>{const t=magnitude2(e);return 0===t?e:[e[0]/t,e[1]/t]},normalize3=e=>{const t=magnitude3(e);return 0===t?e:[e[0]/t,e[1]/t,e[2]/t]},scale=(e,t)=>e.map((e=>e*t)),scale2=(e,t)=>[e[0]*t,e[1]*t],scale3=(e,t)=>[e[0]*t,e[1]*t,e[2]*t],add=(e,t)=>e.map(((e,r)=>e+(t[r]||0))),add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],add3=(e,t)=>[e[0]+t[0],e[1]+t[1],e[2]+t[2]],subtract=(e,t)=>e.map(((e,r)=>e-(t[r]||0))),subtract2=(e,t)=>[e[0]-t[0],e[1]-t[1]],subtract3=(e,t)=>[e[0]-t[0],e[1]-t[1],e[2]-t[2]],dot=(e,t)=>e.map(((r,s)=>e[s]*t[s])).reduce(fnAdd,0),dot2=(e,t)=>e[0]*t[0]+e[1]*t[1],dot3=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2],midpoint=(e,t)=>e.map(((e,r)=>(e+t[r])/2)),midpoint2=(e,t)=>scale2(add2(e,t),.5),average=function(){if(0===arguments.length)return[];const e=arguments[0].length>0?arguments[0].length:0,t=Array(e).fill(0);return Array.from(arguments).forEach((e=>t.forEach(((r,s)=>{t[s]+=e[s]||0})))),t.map((e=>e/arguments.length))},lerp=(e,t,r)=>{const s=1-r;return e.map(((e,o)=>e*s+(t[o]||0)*r))},cross2=(e,t)=>e[0]*t[1]-e[1]*t[0],cross3=(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],distance=(e,t)=>Math.sqrt(e.map(((r,s)=>(e[s]-t[s])**2)).reduce(fnAdd,0)),distance2=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1];return Math.sqrt(r*r+s*s)},distance3=(e,t)=>{const r=e[0]-t[0],s=e[1]-t[1],o=e[2]-t[2];return Math.sqrt(r*r+s*s+o*o)},flip=e=>e.map((e=>-e)),rotate90=e=>[-e[1],e[0]],rotate270=e=>[e[1],-e[0]],parallelNormalized=(e,t,r=L)=>1-Math.abs(dot(e,t))<r,parallel=(e,t,r=L)=>parallelNormalized(normalize(e),normalize(t),r),parallel2=(e,t,r=L)=>Math.abs(cross2(e,t))<r,resize=(e,t)=>t.length===e?t:Array(e).fill(0).map(((e,r)=>t[r]?t[r]:e)),resizeUp=(e,t)=>[e,t].map((r=>resize(Math.max(e.length,t.length),r)));var J=Object.freeze({__proto__:null,add:add,add2:add2,add3:add3,average:average,cross2:cross2,cross3:cross3,degenerate:(e,t=L)=>e.map((e=>Math.abs(e))).reduce(fnAdd,0)<t,distance:distance,distance2:distance2,distance3:distance3,dot:dot,dot2:dot2,dot3:dot3,flip:flip,lerp:lerp,magSquared:magSquared,magnitude:magnitude,magnitude2:magnitude2,magnitude3:magnitude3,midpoint:midpoint,midpoint2:midpoint2,midpoint3:(e,t)=>scale3(add3(e,t),.5),normalize:normalize,normalize2:normalize2,normalize3:normalize3,parallel:parallel,parallel2:parallel2,parallelNormalized:parallelNormalized,resize:resize,resizeUp:resizeUp,rotate270:rotate270,rotate90:rotate90,scale:scale,scale2:scale2,scale3:scale3,subtract:subtract,subtract2:subtract2,subtract3:subtract3});const Z=[1,0,0,1],Y=Z.concat(0,0),multiplyMatrix2Vector2=(e,t)=>[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]],multiplyMatrix2Line2=(e,t,r)=>({vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*r[0]+e[2]*r[1]+e[4],e[1]*r[0]+e[3]*r[1]+e[5]]}),multiplyMatrices2=(e,t)=>[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]],determinant2=e=>e[0]*e[3]-e[1]*e[2],invertMatrix2=e=>{const t=determinant2(e);if(!(Math.abs(t)<1e-6||Number.isNaN(t))&&Number.isFinite(e[4])&&Number.isFinite(e[5]))return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]},makeMatrix2Reflect=(e,t=[0,0])=>{const r=Math.atan2(e[1],e[0]),s=Math.cos(r),o=Math.sin(r),n=Math.cos(-r),a=Math.sin(-r),c=s*n+o*a,i=s*-a+o*n,l=o*n+-s*a,d=o*-a+-s*n;return[c,i,l,d,t[0]+c*-t[0]+-t[1]*l,t[1]+i*-t[0]+-t[1]*d]};var X=Object.freeze({__proto__:null,determinant2:determinant2,identity2x2:Z,identity2x3:Y,invertMatrix2:invertMatrix2,makeMatrix2Reflect:makeMatrix2Reflect,makeMatrix2Rotate:(e,t=[0,0])=>{const r=Math.cos(e),s=Math.sin(e);return[r,s,-s,r,t[0],t[1]]},makeMatrix2Scale:(e=[1,1],t=[0,0])=>[e[0],0,0,e[1],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1]],makeMatrix2Translate:(e=0,t=0)=>Z.concat(e,t),multiplyMatrices2:multiplyMatrices2,multiplyMatrix2Line2:multiplyMatrix2Line2,multiplyMatrix2Vector2:multiplyMatrix2Vector2});const K=Object.freeze([1,0,0,0,1,0,0,0,1]),Q=Object.freeze(K.concat(0,0,0)),multiplyMatrix3Vector3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]],multiplyMatrices3=(e,t)=>[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]],determinant3=e=>e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2],makeMatrix3Translate=(e=0,t=0,r=0)=>K.concat(e,t,r),singleAxisRotate=(e,t,r,s,o)=>{const n=K.concat([0,1,2].map((e=>t[e]||0))),a=Math.cos(e),c=Math.sin(e);return n[3*r+r]=a,n[3*r+s]=(o?1:-1)*c,n[3*s+r]=(o?-1:1)*c,n[3*s+s]=a,n},makeMatrix3RotateZ=(e,t=[0,0,0])=>singleAxisRotate(e,t,0,1,!0),makeMatrix3Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[o,n,a]=resize(3,normalize(t)),c=Math.cos(e),i=Math.sin(e),l=1-c,d=K.concat(-s[0],-s[1],-s[2]),m=K.concat(s[0],s[1],s[2]);return multiplyMatrices3(m,multiplyMatrices3([l*o*o+c,l*n*o+a*i,l*a*o-n*i,l*o*n-a*i,l*n*n+c,l*a*n+o*i,l*o*a+n*i,l*n*a-o*i,l*a*a+c,0,0,0],d))},makeMatrix3Scale=(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,e[1],0,0,0,e[2],e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2]];var ee=Object.freeze({__proto__:null,determinant3:determinant3,identity3x3:K,identity3x4:Q,invertMatrix3:e=>{const t=determinant3(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[9])||!Number.isFinite(e[10])||!Number.isFinite(e[11]))return;const r=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]],s=1/t;return r.map((e=>e*s))},isIdentity3x4:e=>Q.map(((t,r)=>Math.abs(t-e[r])<L)).reduce(((e,t)=>e&&t),!0),makeMatrix3ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,r[2],r[3],0,0,0,1,r[4],r[5],0]},makeMatrix3Rotate:makeMatrix3Rotate,makeMatrix3RotateX:(e,t=[0,0,0])=>singleAxisRotate(e,t,1,2,!0),makeMatrix3RotateY:(e,t=[0,0,0])=>singleAxisRotate(e,t,0,2,!1),makeMatrix3RotateZ:makeMatrix3RotateZ,makeMatrix3Scale:makeMatrix3Scale,makeMatrix3Translate:makeMatrix3Translate,multiplyMatrices3:multiplyMatrices3,multiplyMatrix3Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*r[0]+e[3]*r[1]+e[6]*r[2]+e[9],e[1]*r[0]+e[4]*r[1]+e[7]*r[2]+e[10],e[2]*r[0]+e[5]*r[1]+e[8]*r[2]+e[11]]}),multiplyMatrix3Vector3:multiplyMatrix3Vector3});const isIterable=e=>null!=e&&"function"==typeof e[Symbol.iterator],semiFlattenArrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?semiFlattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...semiFlattenArrays(e)]:e))}},flattenArrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return isIterable(arguments[0])&&"string"!=typeof arguments[0]?flattenArrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>isIterable(e)?[...flattenArrays(e)]:e)).reduce(((e,t)=>e.concat(t)),[])}};var te=Object.freeze({__proto__:null,flattenArrays:flattenArrays,semiFlattenArrays:semiFlattenArrays});const getVector=function(){let e=flattenArrays(arguments);return e.length>0&&"object"==typeof e[0]&&null!==e[0]&&!Number.isNaN(e[0].x)&&(e=["x","y","z"].map((t=>e[0][t])).filter(fnNotUndefined)),e.filter((e=>"number"==typeof e))},getVectorOfVectors=function(){return semiFlattenArrays(arguments).map((e=>getVector(e)))},vectorOriginForm=(e,t)=>({vector:e||[],origin:t||[]}),getLine$1=function(){const e=semiFlattenArrays(arguments);return 0===e.length?vectorOriginForm([],[]):e[0].constructor===Object&&void 0!==e[0].vector?vectorOriginForm(e[0].vector||[],e[0].origin||[]):"number"==typeof e[0]?vectorOriginForm(getVector(e)):vectorOriginForm(...e.map((e=>getVector(e))))},re=[[0,1,3,4,9,10],[0,1,2,3,4,5,6,7,8,9,10,11],[0,1,2,void 0,3,4,5,void 0,6,7,8,void 0,9,10,11]];[11,7,3].forEach((e=>delete re[2][e]));const matrixMap3x4=e=>e<8?re[0]:e<13?re[1]:re[2],pointsToLine=(...e)=>{const t=getVectorOfVectors(...e);return{vector:subtract(t[1],t[0]),origin:t[0]}},rayLineToUniqueLine=({vector:e,origin:t})=>{const r=magnitude(e),s=rotate90(e),o=dot(t,s)/r;return{normal:scale(s,1/r),distance:o}},uniqueLineToRayLine=({normal:e,distance:t})=>vectorOriginForm(rotate270(e),scale(e,t));var se=Object.freeze({__proto__:null,getLine:getLine$1,getMatrix3x4:function(){const e=flattenArrays(arguments),t=[...Q];return matrixMap3x4(e.length).forEach(((r,s)=>{null!=e[s]&&(t[r]=e[s])})),t},getSegment:function(){const e=semiFlattenArrays(arguments);return 4===e.length?[[e[0],e[1]],[e[2],e[3]]]:e.map((e=>getVector(e)))},getVector:getVector,getVectorOfVectors:getVectorOfVectors,pointsToLine:pointsToLine,rayLineToUniqueLine:rayLineToUniqueLine,uniqueLineToRayLine:uniqueLineToRayLine});const angleArray=e=>Array.from(Array(Math.floor(e))).map(((t,r)=>R*(r/e))),anglesToVecs=(e,t)=>e.map((e=>[t*Math.cos(e),t*Math.sin(e)])),makePolygonCircumradius=(e=3,t=1)=>anglesToVecs(angleArray(e),t),makePolygonCircumradiusSide=(e=3,t=1)=>{const r=Math.PI/e,s=angleArray(e).map((e=>e+r));return anglesToVecs(s,t)},makePolygonNonCollinear=(e,t=L)=>{const r=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>subtract(e[1],e[0]))).map(((e,t,r)=>[e,r[(t+r.length-1)%r.length]])).map((e=>!parallel(e[1],e[0],t)));return e.filter(((e,t)=>r[t]))},signedArea=e=>.5*e.map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[0]*s[1]-s[0]*e[1]})).reduce(fnAdd,0),centroid=e=>{const t=1/(6*signedArea(e));return e.map(((e,t,r)=>{const s=r[(t+1)%r.length],o=e[0]*s[1]-s[0]*e[1];return[(e[0]+s[0])*o,(e[1]+s[1])*o]})).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((e=>e*t))},boundingBox$1=(e,t=0)=>{if(!e||!e.length)return;const r=Array(e[0].length).fill(1/0),s=Array(e[0].length).fill(-1/0);e.forEach((e=>e.forEach(((e,o)=>{e<r[o]&&(r[o]=e-t),e>s[o]&&(s[o]=e+t)}))));const o=s.map(((e,t)=>e-r[t]));return{min:r,max:s,span:o}};var oe=Object.freeze({__proto__:null,boundingBox:boundingBox$1,centroid:centroid,circumcircle:(e,t,r)=>{const s=t[0]-e[0],o=t[1]-e[1],n=r[0]-e[0],a=r[1]-e[1],c=s*(e[0]+t[0])+o*(e[1]+t[1]),i=n*(e[0]+r[0])+a*(e[1]+r[1]),l=2*(s*(r[1]-t[1])-o*(r[0]-t[0]));if(Math.abs(l)<L){const s=Math.min(e[0],t[0],r[0]),o=Math.min(e[1],t[1],r[1]),n=.5*(Math.max(e[0],t[0],r[0])-s),a=.5*(Math.max(e[1],t[1],r[1])-o);return{origin:[s+n,o+a],radius:Math.sqrt(n*n+a*a)}}const d=[(a*c-o*i)/l,(s*i-n*c)/l],m=d[0]-e[0],p=d[1]-e[1];return{origin:d,radius:Math.sqrt(m*m+p*p)}},makePolygonCircumradius:makePolygonCircumradius,makePolygonCircumradiusSide:makePolygonCircumradiusSide,makePolygonInradius:(e=3,t=1)=>makePolygonCircumradius(e,t/Math.cos(Math.PI/e)),makePolygonInradiusSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/Math.cos(Math.PI/e)),makePolygonNonCollinear:makePolygonNonCollinear,makePolygonSideLength:(e=3,t=1)=>makePolygonCircumradius(e,t/2/Math.sin(Math.PI/e)),makePolygonSideLengthSide:(e=3,t=1)=>makePolygonCircumradiusSide(e,t/2/Math.sin(Math.PI/e)),signedArea:signedArea});const vertex_degree=function(e,t){const r=this;Object.defineProperty(e,"degree",{get:()=>r.vertices_vertices&&r.vertices_vertices[t]?r.vertices_vertices[t].length:null})},edge_coords=function(e,t){const r=this;Object.defineProperty(e,"coords",{get:()=>{if(r.edges_vertices&&r.edges_vertices[t]&&r.vertices_coords)return r.edges_vertices[t].map((e=>r.vertices_coords[e]))}})},face_simple=function(e,t){const r=this;Object.defineProperty(e,"simple",{get:()=>{if(!r.faces_vertices||!r.faces_vertices[t])return null;for(let s=0;s<e.length-1;s+=1)for(let o=s+1;o<e.length;o+=1)if(r.faces_vertices[t][s]===r.faces_vertices[t][o])return!1;return!0}})},face_coords=function(e,t){const r=this;Object.defineProperty(e,"coords",{get:()=>{if(r.faces_vertices&&r.faces_vertices[t]&&r.vertices_coords)return r.faces_vertices[t].map((e=>r.vertices_coords[e]))}})};var ne={vertices:function(e,t){return vertex_degree.call(this,e,t),e},edges:function(e,t){return edge_coords.call(this,e,t),e},faces:function(e,t){return face_simple.call(this,e,t),face_coords.call(this,e,t),e}};const ae={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]};var ce=Object.freeze({__proto__:null,foldKeys:ae,foldFileClasses:["singleModel","multiModel","animation","diagrams"],foldFrameClasses:["creasePattern","foldedForm","graph","linkage"],foldFrameAttributes:["2D","3D","abstract","manifold","nonManifold","orientable","nonOrientable","selfTouching","nonSelfTouching","selfIntersecting","nonSelfIntersecting"]});const ie={vertices:"vertex",edges:"edge",faces:"face"},le=Array.from("BbMmVvFfJjUu"),fe={b:"boundary",m:"mountain",v:"valley",f:"flat",j:"join",u:"unassigned"};Object.keys(fe).forEach((e=>{fe[e.toUpperCase()]=fe[e]}));const de={M:-180,m:-180,V:180,v:180,B:0,b:0,F:0,f:0,J:0,j:0,U:0,u:0},edgeAssignmentToFoldAngle=e=>de[e]||0,edgeFoldAngleToAssignment=e=>e>L?"V":e<-L?"M":"U",edgeFoldAngleIsFlat=e=>fnEpsilonEqual(0,e)||fnEpsilonEqual(-180,e)||fnEpsilonEqual(180,e),edgesFoldAngleAreAllFlat=({edges_foldAngle:e})=>{if(!e)return!0;for(let t=0;t<e.length;t+=1)if(!edgeFoldAngleIsFlat(e[t]))return!1;return!0},filterKeysWithSuffix=(e,t)=>Object.keys(e).map((e=>e.substring(e.length-t.length,e.length)===t?e:void 0)).filter((e=>void 0!==e)),filterKeysWithPrefix=(e,t)=>Object.keys(e).map((e=>e.substring(0,t.length)===t?e:void 0)).filter((e=>void 0!==e)),getGraphKeysWithPrefix=(e,t)=>filterKeysWithPrefix(e,`${t}_`),getGraphKeysWithSuffix=(e,t)=>filterKeysWithSuffix(e,`_${t}`),transposeGraphArrays=(e,t)=>{const r=getGraphKeysWithPrefix(e,t);if(0===r.length)return[];const s=Math.max(...r.map((t=>e[t].length))),o=Array.from(Array(s)).map((()=>({})));return r.forEach((t=>o.forEach(((r,s)=>{o[s][t]=e[t][s]})))),o},me=Object.freeze([].concat(ae.file).concat(ae.frame).concat(ae.graph).concat(ae.orders)),isFoldObject=(e={})=>0===Object.keys(e).length?0:me.filter((t=>e[t])).length/Object.keys(e).length;var pe=Object.freeze({__proto__:null,singularize:ie,pluralize:{vertex:"vertices",edge:"edges",face:"faces"},edgesAssignmentValues:le,edgesAssignmentNames:fe,edgeAssignmentToFoldAngle:edgeAssignmentToFoldAngle,edgeFoldAngleToAssignment:edgeFoldAngleToAssignment,edgeFoldAngleIsFlat:edgeFoldAngleIsFlat,edgesFoldAngleAreAllFlat:edgesFoldAngleAreAllFlat,filterKeysWithSuffix:filterKeysWithSuffix,filterKeysWithPrefix:filterKeysWithPrefix,getGraphKeysWithPrefix:getGraphKeysWithPrefix,getGraphKeysWithSuffix:getGraphKeysWithSuffix,transposeGraphArrays:transposeGraphArrays,transposeGraphArrayAtIndex:(e,t,r)=>{const s=getGraphKeysWithPrefix(e,t);if(0===s.length)return;const o={};return s.forEach((t=>{o[t]=e[t][r]})),o},isFoldObject:isFoldObject});const verticesClusters=({vertices_coords:e},t=L)=>{if(!e)return[];const r=[],s=[],o=e.map(((e,t)=>({i:t,d:e[0]}))).sort(((e,t)=>e.d-t.d)).map((e=>e.i));let n=0,a=[0,0],c=[0,0];const updateRange=r=>{const s=r[r.length-1];for(;e[s]-e[r[n]]>t;)n+=1;const o=r.slice(n,r.length).map((t=>e[t])),i=o.map((e=>e[1]));a=[Math.min(...i)-t,Math.max(...i)+t],c=[o[0][0]-t,o[o.length-1][0]+t]};for(;s.length!==e.length;){const t=[],l=o.shift();t.push(l),s.push(l),n=0,updateRange(t);let d=0;for(;d<o.length&&e[o[d]][0]<c[1];)if(i=o[d],e[i][0]>c[0]&&e[i][0]<c[1]&&e[i][1]>a[0]&&e[i][1]<a[1]){const e=o.splice(d,1).shift();t.push(e),s.push(e),updateRange(t)}else d+=1;r.push(t)}var i;return r},max_arrays_length=(...e)=>Math.max(0,...e.filter((e=>void 0!==e)).map((e=>e.length))),count=(e,t)=>max_arrays_length(...getGraphKeysWithPrefix(e,t).map((t=>e[t])));count.vertices=({vertices_coords:e,vertices_faces:t,vertices_vertices:r})=>max_arrays_length(e,t,r),count.edges=({edges_vertices:e,edges_edges:t,edges_faces:r})=>max_arrays_length(e,t,r),count.faces=({faces_vertices:e,faces_edges:t,faces_faces:r})=>max_arrays_length(e,t,r);const uniqueElements=e=>Array.from(new Set(e)),nonUniqueElements=e=>{const t={};return e.forEach((e=>{void 0===t[e]&&(t[e]=0),t[e]+=1})),e.filter((e=>t[e]>1))},uniqueSortedNumbers=e=>uniqueElements(e).sort(((e,t)=>e-t)),splitCircularArray=(e,t)=>(t.sort(((e,t)=>e-t)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]),booleanMatrixToIndexedArray=e=>e.map((e=>e.map(((e,t)=>!0===e?t:void 0)).filter((e=>void 0!==e)))),booleanMatrixToUniqueIndexPairs=e=>{const t=[];for(let r=0;r<e.length-1;r+=1)for(let s=r+1;s<e.length;s+=1)e[r][s]&&t.push([r,s]);return t},selfRelationalUniqueIndexPairs=e=>{const t=[],r=[];return e.forEach(((e,s)=>e.forEach((e=>{s<e&&r.push([s,e]),s!==e||t[s]||(t[s]=!0,r.push([s,e]))})))),r},clusterScalars=(e,t=L)=>{const r=e.map(((e,t)=>({v:e,i:t}))).sort(((e,t)=>e.v-t.v)).map((e=>e.i)),s=[[r[0]]];for(let o=1;o<r.length;o+=1){const n=r[o],a=s.length-1,c=s[a][s[a].length-1];Math.abs(e[c]-e[n])<t?s[a].push(n):s.push([n])}return s},chooseTwoPairs=e=>{const t=Array(e.length*(e.length-1)/2);let r=0;for(let s=0;s<e.length-1;s+=1)for(let o=s+1;o<e.length;o+=1,r+=1)t[r]=[e[s],e[o]];return t};var ge=Object.freeze({__proto__:null,uniqueElements:uniqueElements,nonUniqueElements:nonUniqueElements,uniqueSortedNumbers:uniqueSortedNumbers,splitCircularArray:splitCircularArray,booleanMatrixToIndexedArray:booleanMatrixToIndexedArray,booleanMatrixToUniqueIndexPairs:booleanMatrixToUniqueIndexPairs,selfRelationalUniqueIndexPairs:selfRelationalUniqueIndexPairs,clusterScalars:clusterScalars,chooseTwoPairs:chooseTwoPairs});const removeGeometryIndices=(e,t,r)=>{const s=count(e,t),o=uniqueSortedNumbers(r),n=[];for(let e=0,t=0,r=0;e<s;e+=1,t+=1){for(;e===o[r];)n[e]=void 0,e+=1,r+=1;e<s&&(n[e]=t)}return getGraphKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>e[t][s].forEach(((r,o)=>{e[t][s][o]=n[r]})))))),o.reverse(),getGraphKeysWithPrefix(e,t).forEach((t=>o.forEach((r=>e[t].splice(r,1))))),n},replaceGeometryIndices=(e,t,r)=>{const s=count(e,t);let o=!1;Object.entries(r).filter((([e,t])=>e<t)).forEach((([e,t])=>{o=!0,delete r[e],r[t]=e})),o&&console.warn(F);const n=Object.keys(r).map((e=>parseInt(e,10))),a=uniqueSortedNumbers(n),c=[];for(let e=0,t=0,o=0;e<s;e+=1,t+=1){for(;e===a[o];){if(c[e]=c[r[a[o]]],void 0===c[e])throw new Error(P);e+=1,o+=1}e<s&&(c[e]=t)}return getGraphKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,s)=>e[t][s].forEach(((r,o)=>{e[t][s][o]=c[r]})))))),a.reverse(),getGraphKeysWithPrefix(e,t).forEach((t=>a.forEach((r=>e[t].splice(r,1))))),c},duplicateVertices=(e,t)=>verticesClusters(e,t).filter((e=>e.length>1)),isolatedVertices=({vertices_coords:e,edges_vertices:t,faces_vertices:r})=>{if(!e)return[];let s=e.length;const o=Array(s).fill(!1);return t&&t.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,s-=1}))})),r&&r.forEach((e=>{e.filter((e=>!o[e])).forEach((e=>{o[e]=!0,s-=1}))})),o.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},removeIsolatedVertices=(e,t)=>(t||(t=isolatedVertices(e)),{map:removeGeometryIndices(e,o,t),remove:t}),removeDuplicateVertices=(e,t=L)=>{const r=[],s=[],n=verticesClusters(e,t).filter((e=>e.length>1));return n.forEach((e=>{Math.min(...e)!==e[0]&&e.sort(((e,t)=>e-t));for(let t=1;t<e.length;t+=1)r[e[t]]=e[0],s.push(e[t])})),n.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>average(...e))).forEach(((t,r)=>{e.vertices_coords[n[r][0]]=t})),{map:replaceGeometryIndices(e,o,r),remove:s}};var ue=Object.freeze({__proto__:null,duplicateVertices:duplicateVertices,edgeIsolatedVertices:({vertices_coords:e,edges_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},faceIsolatedVertices:({vertices_coords:e,faces_vertices:t})=>{if(!e||!t)return[];let r=e.length;const s=Array(r).fill(!1);return t.forEach((e=>{e.filter((e=>!s[e])).forEach((e=>{s[e]=!0,r-=1}))})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},isolatedVertices:isolatedVertices,removeIsolatedVertices:removeIsolatedVertices,removeDuplicateVertices:removeDuplicateVertices});const isCounterClockwiseBetween=(e,t,r)=>{for(;r<t;)r+=R;for(;e>t;)e-=R;for(;e<t;)e+=R;return e<r},clockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=R;for(;t<0;)t+=R;for(;e>R;)e-=R;for(;t>R;)t-=R;const r=e-t;return r>=0?r:R-(t-e)},counterClockwiseAngleRadians=(e,t)=>{for(;e<0;)e+=R;for(;t<0;)t+=R;for(;e>R;)e-=R;for(;t>R;)t-=R;const r=t-e;return r>=0?r:R-(e-t)},clockwiseAngle2=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1],s=t[0]*e[1]-t[1]*e[0];let o=Math.atan2(s,r);return o<0&&(o+=R),o},counterClockwiseAngle2=(e,t)=>{const r=e[0]*t[0]+e[1]*t[1],s=e[0]*t[1]-e[1]*t[0];let o=Math.atan2(s,r);return o<0&&(o+=R),o},clockwiseBisect2=(e,t)=>fnAngleToVec(fnVecToAngle(e)-clockwiseAngle2(e,t)/2),counterClockwiseBisect2=(e,t)=>fnAngleToVec(fnVecToAngle(e)+counterClockwiseAngle2(e,t)/2),clockwiseSubsectRadians=(e,t,r)=>{const s=clockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsectRadians=(e,t,r)=>{const s=counterClockwiseAngleRadians(e,t)/r;return Array.from(Array(r-1)).map(((t,r)=>e+s*(r+1)))},counterClockwiseSubsect2=(e,t,r)=>{const s=Math.atan2(e[1],e[0]),o=Math.atan2(t[1],t[0]);return counterClockwiseSubsectRadians(s,o,r).map(fnAngleToVec)},counterClockwiseOrderRadians=function(){const e=Array.from(arguments).flat(),t=e.map(((e,t)=>t)).sort(((t,r)=>e[t]-e[r]));return t.slice(t.indexOf(0),t.length).concat(t.slice(0,t.indexOf(0)))},counterClockwiseOrder2=function(){return counterClockwiseOrderRadians(semiFlattenArrays(arguments).map(fnVecToAngle))},counterClockwiseSectorsRadians=function(){const e=Array.from(arguments).flat(),t=counterClockwiseOrderRadians(e).map((t=>e[t]));return t.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(e[0],e[1])))},counterClockwiseSectors2=function(){return counterClockwiseSectorsRadians(semiFlattenArrays(arguments).map(fnVecToAngle))},threePointTurnDirection=(e,t,r,s=L)=>{const o=normalize2(subtract2(t,e)),n=normalize2(subtract2(r,e)),a=cross2(o,n);return fnEpsilonEqual(a,0,s)?fnEpsilonEqual(distance2(e,t)+distance2(t,r),distance2(e,r))?0:void 0:Math.sign(a)};var ve=Object.freeze({__proto__:null,clockwiseAngle2:clockwiseAngle2,clockwiseAngleRadians:clockwiseAngleRadians,clockwiseBisect2:clockwiseBisect2,clockwiseSubsect2:(e,t,r)=>{const s=Math.atan2(e[1],e[0]),o=Math.atan2(t[1],t[0]);return clockwiseSubsectRadians(s,o,r).map(fnAngleToVec)},clockwiseSubsectRadians:clockwiseSubsectRadians,counterClockwiseAngle2:counterClockwiseAngle2,counterClockwiseAngleRadians:counterClockwiseAngleRadians,counterClockwiseBisect2:counterClockwiseBisect2,counterClockwiseOrder2:counterClockwiseOrder2,counterClockwiseOrderRadians:counterClockwiseOrderRadians,counterClockwiseSectors2:counterClockwiseSectors2,counterClockwiseSectorsRadians:counterClockwiseSectorsRadians,counterClockwiseSubsect2:counterClockwiseSubsect2,counterClockwiseSubsectRadians:counterClockwiseSubsectRadians,isCounterClockwiseBetween:isCounterClockwiseBetween,threePointTurnDirection:threePointTurnDirection});const he={edges:"edgeOrders",faces:"faceOrders"},countImplied=(e,t)=>Math.max((e=>{let t=-1;return e.filter((e=>void 0!==e)).forEach((e=>e.forEach((e=>e.forEach((e=>{e>t&&(t=e)})))))),t})(getGraphKeysWithSuffix(e,t).map((t=>e[t]))),e[he[t]]?(e=>{let t=-1;return e.forEach((e=>{e[0]>t&&(t=e[0]),e[1]>t&&(t=e[1])})),t})(e[he[t]]):-1)+1;countImplied.vertices=e=>countImplied(e,o),countImplied.edges=e=>countImplied(e,n),countImplied.faces=e=>countImplied(e,a);const counterClockwiseWalk=({vertices_vertices:e,vertices_sectors:t},r,s,o={})=>{const n={},a={vertices:[r],edges:[],angles:[]};let c=r,i=s;for(;;){const r=e[i],s=(r.indexOf(c)+r.length-1)%r.length,l=r[s],d=`${i} ${l}`;if(n[d])return Object.assign(o,n),a.vertices.pop(),a;if(n[d]=!0,o[d])return;a.vertices.push(i),a.edges.push(d),t&&a.angles.push(t[i][s]),c=i,i=l}},planarVertexWalk=({vertices_vertices:e,vertices_sectors:t})=>{const r={vertices_vertices:e,vertices_sectors:t},s={};return e.map(((e,t)=>e.map((e=>counterClockwiseWalk(r,t,e,s))).filter((e=>void 0!==e)))).flat()},filterWalkedBoundaryFace=e=>e.filter((e=>e.angles.map((e=>Math.PI-e)).reduce(((e,t)=>e+t),0)>0));var _e=Object.freeze({__proto__:null,counterClockwiseWalk:counterClockwiseWalk,planarVertexWalk:planarVertexWalk,filterWalkedBoundaryFace:filterWalkedBoundaryFace});const smallestComparisonSearch=(e,t,r)=>{const s=e.map(((e,s)=>({i:s,d:r(t,e)})));let o,n=1/0;for(let e=0;e<s.length;e+=1)s[e].d<n&&(o=e,n=s[e].d);return o},minimum2DPointIndex=(e,t=L)=>{if(!e.length)return;const r=((e,t=0,r=fnEpsilonCompare,s=L)=>{let o=[0];for(let n=1;n<e.length;n+=1)switch(r(e[n][t],e[o[0]][t],s)){case 0:o.push(n);break;case 1:o=[n]}return o})(e,0,fnEpsilonCompare,t);let s=0;for(let t=1;t<r.length;t+=1)e[r[t]][1]<e[r[s]][1]&&(s=t);return r[s]};var be=Object.freeze({__proto__:null,minimum2DPointIndex:minimum2DPointIndex,smallestComparisonSearch:smallestComparisonSearch});const sortAgainstItem=(e,t,r)=>e.map(((e,s)=>({i:s,n:r(e,t)}))).sort(((e,t)=>e.n-t.n)).map((e=>e.i)),sortPointsAlongVector=(e,t)=>sortAgainstItem(e,t,dot),clusterIndicesOfSortedNumbers=(e,t=L)=>{const r=[[0]];let s=0;for(let o=1;o<e.length;o+=1)fnEpsilonEqual(e[o],e[o-1],t)?r[s].push(o):(s=r.length,r.push([o]));return r},radialSortPointIndices2=(e=[],t=L)=>{const r=minimum2DPointIndex(e,t),s=e.map((t=>subtract2(t,e[r]))).map((e=>normalize2(e))).map((e=>dot2([0,1],e))),o=s.map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).filter((e=>e!==r));return[[r]].concat(clusterIndicesOfSortedNumbers(o.map((e=>s[e])),t).map((e=>e.map((e=>o[e])))).map((t=>1===t.length?t:t.map((t=>({i:t,len:distance2(e[t],e[r])}))).sort(((e,t)=>e.len-t.len)).map((e=>e.i)))))};var ye=Object.freeze({__proto__:null,clusterIndicesOfSortedNumbers:clusterIndicesOfSortedNumbers,radialSortPointIndices2:radialSortPointIndices2,sortAgainstItem:sortAgainstItem,sortPointsAlongVector:sortPointsAlongVector});const sortVerticesCounterClockwise=({vertices_coords:e},t,r)=>t.map((t=>e[t])).map((t=>subtract(t,e[r]))).map((e=>Math.atan2(e[1],e[0]))).map((e=>e>-L?e:e+2*Math.PI)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).map((e=>e.i)).map((e=>t[e])),sortVerticesAlongVector=({vertices_coords:e},t,r)=>sortPointsAlongVector(t.map((t=>e[t])),r).map((e=>t[e]));var Ee=Object.freeze({__proto__:null,sortVerticesCounterClockwise:sortVerticesCounterClockwise,sortVerticesAlongVector:sortVerticesAlongVector});const makeFacesNormal=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>{const t=resize(3,subtract(e[1],e[0])),r=resize(3,subtract(e[2],e[0]));return normalize3(cross3(t,r))})),makeVerticesNormal=({vertices_coords:e,faces_vertices:t,faces_normal:r})=>{r||(r=makeFacesNormal({vertices_coords:e,faces_vertices:t}));const s=e.map((()=>[0,0,0]));return t.forEach(((e,t)=>e.forEach((e=>{return o=s[e],n=r[t],o[0]+=n[0],o[1]+=n[1],void(o[2]+=n[2]);var o,n})))),s.map((e=>normalize3(e)))};var Ae=Object.freeze({__proto__:null,makeFacesNormal:makeFacesNormal,makeVerticesNormal:makeVerticesNormal});const makeVerticesEdgesUnsorted=({edges_vertices:e})=>{const t=[];return e.forEach(((e,r)=>e.forEach((e=>{void 0===t[e]&&(t[e]=[]),t[e].push(r)})))),t},makeVerticesEdges=({edges_vertices:e,vertices_vertices:t})=>{const r=makeVerticesToEdgeBidirectional({edges_vertices:e});return t.map(((e,t)=>e.map((e=>r[`${t} ${e}`]))))},makeVerticesVertices2D=({vertices_coords:e,vertices_edges:t,edges_vertices:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const s=t.map(((e,t)=>e.map((e=>r[e].filter((e=>e!==t)))).reduce(((e,t)=>e.concat(t)),[])));return void 0===e?s:s.map(((t,r)=>sortVerticesCounterClockwise({vertices_coords:e},t,r)))},makeVerticesVerticesFromFaces=({vertices_coords:e,vertices_faces:t,faces_vertices:r})=>{t||(t=makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r}));const s=t.map((e=>e.map((e=>r[e])))),o=s.map(((e,t)=>e.map((e=>e.indexOf(t)))));return s.map(((e,t)=>e.map(((e,r)=>[(o[t][r]+e.length-1)%e.length,o[t][r],(o[t][r]+1)%e.length])))).map(((e,t)=>e.map(((e,r)=>e.map((e=>s[t][r][e])))))).map((e=>{const t=e.map((e=>[[0,1],[1,2]].map((t=>t.map((t=>e[t])).join(" "))))),r={},s={};return t.forEach(((e,t)=>{r[e[0]]=t,s[e[1]]=t})),{facesVerts:t,to:s,from:r}})).map((e=>{const t=Object.keys(e.to),r=t.map((e=>e.split(" ").reverse().join(" "))),s=t.filter(((t,s)=>!(r[s]in e.from)));if(s.length>2)return console.warn("vertices_vertices found an unsolvable vertex"),[];const o=s.length?s:[t[0]],n=[],a={};for(let t=0;t<o.length;t+=1){const r=o[t],s=[r];a[r]=!0;let c=!1;do{const t=s[s.length-1],r=e.to[t];if(!(r in e.facesVerts))break;let o;if(e.facesVerts[r][0]===t&&(o=e.facesVerts[r][1]),e.facesVerts[r][1]===t&&(o=e.facesVerts[r][0]),void 0===o)return"not found";const n=o.split(" ").reverse().join(" ");s.push(o),c=n in a,c||s.push(n),a[o]=!0,a[n]=!0}while(!c);const i=s.filter(((e,t)=>t%2==0)).map((e=>e.split(" ")[1])).map((e=>parseInt(e,10)));n.push(...i)}return n}))},makeVerticesVertices=e=>e.vertices_coords&&e.vertices_coords.length?3===e.vertices_coords[0].length?makeVerticesVerticesFromFaces(e):makeVerticesVertices2D(e):[],makeVerticesVerticesUnsorted=({vertices_edges:e,edges_vertices:t})=>(e||(e=makeVerticesEdgesUnsorted({edges_vertices:t})),e.map(((e,r)=>e.flatMap((e=>t[e].filter((e=>e!==r))))))),makeVerticesFacesUnsorted=({vertices_coords:e,faces_vertices:t})=>{if(!t)return e.map((()=>[]));const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.vertices({faces_vertices:t}))).map((()=>[]));return t.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t})),s.forEach(((e,t)=>r[t].push(e)))})),r},makeVerticesFaces=({vertices_coords:e,vertices_vertices:t,faces_vertices:r})=>{if(!r)return e.map((()=>[]));if(!t)return makeVerticesFacesUnsorted({vertices_coords:e,faces_vertices:r});const s=makeVerticesToFace({faces_vertices:r});return t.map(((e,t)=>e.map(((e,r,s)=>[s[(r+1)%s.length],t,e].join(" "))))).map((e=>e.map((e=>s[e]))))},makeVerticesToEdgeBidirectional=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),e.map((e=>`${e[1]} ${e[0]}`)).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToEdge=({edges_vertices:e})=>{const t={};return e.map((e=>e.join(" "))).forEach(((e,r)=>{t[e]=r})),t},makeVerticesToFace=({faces_vertices:e})=>{const t={};return e.forEach(((e,r)=>e.map(((t,r)=>[0,1,2].map((t=>(r+t)%e.length)).map((t=>e[t])).join(" "))).forEach((e=>{t[e]=r})))),t},makeVerticesVerticesVector=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>{s||(s=makeEdgesVector({vertices_coords:e,edges_vertices:r}));const o=makeVerticesToEdge({edges_vertices:r});return t.map(((e,r)=>t[r].map((e=>{const t=o[`${r} ${e}`],n=o[`${e} ${r}`];return void 0!==t?s[t]:void 0!==n?flip(s[n]):void 0}))))},makeVerticesSectors=({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s})=>makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:r,edges_vector:s}).map((e=>1===e.length?[R]:counterClockwiseSectors2(e))),makeEdgesFacesUnsorted=({edges_vertices:e,faces_edges:t})=>{const r=void 0!==e?e.map((()=>[])):Array.from(Array(countImplied.edges({faces_edges:t}))).map((()=>[]));return t.forEach(((e,t)=>{const s=[];e.forEach((e=>{s[e]=t})),s.forEach(((e,t)=>r[t].push(e)))})),r},makeEdgesFaces=({vertices_coords:e,edges_vertices:t,edges_vector:r,faces_vertices:s,faces_edges:o,faces_center:n})=>{if(!t)return makeEdgesFacesUnsorted({faces_edges:o});r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const a=t.map((t=>e[t[0]]));n||(n=makeFacesConvexCenter({vertices_coords:e,faces_vertices:s}));const c=t.map((()=>[]));return o.forEach(((e,t)=>{const r=[];e.forEach((e=>{r[e]=t})),r.forEach(((e,t)=>c[t].push(e)))})),c.forEach(((e,t)=>{const s=e.map((e=>n[e])).map((e=>subtract2(e,a[t]))).map((e=>cross2(e,r[t])));e.sort(((e,t)=>s[e]-s[t]))})),c},ke={M:-180,m:-180,V:180,v:180},makeEdgesAssignmentSimple=({edges_foldAngle:e})=>e.map((e=>0===e?"F":e<0?"M":"V")),makeEdgesAssignment=({edges_vertices:e,edges_foldAngle:t,edges_faces:r,faces_vertices:s,faces_edges:o})=>(r||(o||(o=makeFacesEdgesFromVertices({edges_vertices:e,faces_vertices:s})),r=makeEdgesFacesUnsorted({edges_vertices:e,faces_edges:o})),t.map(((e,t)=>r[t].length<2?"B":0===e?"F":e<0?"M":"V"))),makeEdgesFoldAngle=({edges_assignment:e})=>e.map((e=>ke[e]||0)),makeEdgesFoldAngleFromFaces=({vertices_coords:e,edges_vertices:t,edges_faces:r,edges_assignment:s,faces_vertices:o,faces_edges:n,faces_normal:a,faces_center:c})=>(r||(n||(n=makeFacesEdgesFromVertices({edges_vertices:t,faces_vertices:o})),r=makeEdgesFacesUnsorted({edges_vertices:t,faces_edges:n})),a||(a=makeFacesNormal({vertices_coords:e,faces_vertices:o})),c||(c=makeFacesConvexCenter({vertices_coords:e,faces_vertices:o})),r.map(((e,t)=>{if(e.length>2)throw new Error(O);if(e.length<2)return 0;const r=a[e[0]],o=a[e[1]],n=normalize(subtract(c[e[1]],c[e[0]]));let i=Math.sign(dot(r,n));if(0===i){if(!s||!s[t])throw new Error(C);"F"!==s[t]&&"F"!==s[t]||(i=0),"M"!==s[t]&&"m"!==s[t]||(i=-1),"V"!==s[t]&&"v"!==s[t]||(i=1)}return Math.acos(dot(r,o))*(180/Math.PI)*i}))),makeEdgesCoords=({vertices_coords:e,edges_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeEdgesVector=({vertices_coords:e,edges_vertices:t})=>makeEdgesCoords({vertices_coords:e,edges_vertices:t}).map((e=>subtract(e[1],e[0]))),makeEdgesLength=({vertices_coords:e,edges_vertices:t})=>makeEdgesVector({vertices_coords:e,edges_vertices:t}).map((e=>magnitude(e))),makeEdgesBoundingBox=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=0)=>(r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t})),r.map((e=>boundingBox$1(e,s)))),makePlanarFaces=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,vertices_sectors:s,edges_vertices:o,edges_vector:n})=>{t||(t=makeVerticesVertices({vertices_coords:e,edges_vertices:o,vertices_edges:r})),s||(s=makeVerticesSectors({vertices_coords:e,vertices_vertices:t,edges_vertices:o,edges_vector:n}));const a=makeVerticesToEdgeBidirectional({edges_vertices:o});return filterWalkedBoundaryFace(planarVertexWalk({vertices_vertices:t,vertices_sectors:s})).map((e=>({...e,edges:e.edges.map((e=>a[e]))})))},makeFacesVerticesFromEdges=e=>e.faces_edges.map((t=>t.map((t=>e.edges_vertices[t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[0]===s[0]||e[0]===s[1]?e[1]:e[0]})))),makeFacesEdgesFromVertices=e=>{const t=makeVerticesToEdgeBidirectional(e);return e.faces_vertices.map((e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]].join(" "))))).map((e=>e.map((e=>t[e]))))},makeFacesFaces=({faces_vertices:e})=>{const t=e.map((()=>[])),r={};return e.forEach(((e,t)=>e.forEach(((s,o,n)=>{let a=n[(o+1)%e.length];a<s&&([s,a]=[a,s]);const c=`${s} ${a}`;void 0===r[c]&&(r[c]={}),r[c][t]=!0})))),Object.values(r).map((e=>Object.keys(e))).filter((e=>e.length>1)).forEach((e=>{t[e[0]].push(parseInt(e[1],10)),t[e[1]].push(parseInt(e[0],10))})),t},makeFacesPolygon=({vertices_coords:e,faces_vertices:t},r)=>t.map((t=>t.map((t=>e[t])))).map((e=>makePolygonNonCollinear(e,r))),makeFacesConvexCenter=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).reduce(((e,t)=>add(e,t)),Array(e[0].length).fill(0)).map((e=>e/t.length))));var xe=Object.freeze({__proto__:null,makeVerticesEdgesUnsorted:makeVerticesEdgesUnsorted,makeVerticesEdges:makeVerticesEdges,makeVerticesVertices2D:makeVerticesVertices2D,makeVerticesVerticesFromFaces:makeVerticesVerticesFromFaces,makeVerticesVertices:makeVerticesVertices,makeVerticesVerticesUnsorted:makeVerticesVerticesUnsorted,makeVerticesFacesUnsorted:makeVerticesFacesUnsorted,makeVerticesFaces:makeVerticesFaces,makeVerticesToEdgeBidirectional:makeVerticesToEdgeBidirectional,makeVerticesToEdge:makeVerticesToEdge,makeVerticesToFace:makeVerticesToFace,makeVerticesVerticesVector:makeVerticesVerticesVector,makeVerticesSectors:makeVerticesSectors,makeEdgesEdges:({edges_vertices:e,vertices_edges:t})=>e.map(((e,r)=>{const s=t[e[0]].filter((e=>e!==r)),o=t[e[1]].filter((e=>e!==r));return s.concat(o)})),makeEdgesFacesUnsorted:makeEdgesFacesUnsorted,makeEdgesFaces:makeEdgesFaces,makeEdgesAssignmentSimple:makeEdgesAssignmentSimple,makeEdgesAssignment:makeEdgesAssignment,makeEdgesFoldAngle:makeEdgesFoldAngle,makeEdgesFoldAngleFromFaces:makeEdgesFoldAngleFromFaces,makeEdgesCoords:makeEdgesCoords,makeEdgesVector:makeEdgesVector,makeEdgesLength:makeEdgesLength,makeEdgesBoundingBox:makeEdgesBoundingBox,makePlanarFaces:makePlanarFaces,makeFacesVerticesFromEdges:makeFacesVerticesFromEdges,makeFacesEdgesFromVertices:makeFacesEdgesFromVertices,makeFacesFaces:makeFacesFaces,makeFacesPolygon:makeFacesPolygon,makeFacesPolygonQuick:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))),makeFacesCenter2D:({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])))).map((e=>centroid(e))),makeFacesConvexCenter:makeFacesConvexCenter});const circularEdges=({edges_vertices:e})=>{if(!e)return[];const t=[];for(let r=0;r<e.length;r+=1)e[r][0]===e[r][1]&&t.push(r);return t},duplicateEdges=({edges_vertices:e})=>{if(!e)return[];const t=[],r={};for(let s=0;s<e.length;s+=1){const o=`${e[s][0]} ${e[s][1]}`,n=`${e[s][1]} ${e[s][0]}`;void 0!==r[o]?t[s]=r[o]:(r[o]=s,r[n]=s)}return t},removeCircularEdges=(e,t)=>(t||(t=circularEdges(e)),t.length&&((e,t,r)=>{const s={};r.forEach((e=>{s[e]=!0})),getGraphKeysWithSuffix(e,t).forEach((t=>e[t].forEach(((r,o)=>{for(let n=r.length-1;n>=0;n-=1)!0===s[r[n]]&&e[t][o].splice(n,1)}))))})(e,n,t),{map:removeGeometryIndices(e,n,t),remove:t}),removeDuplicateEdges=(e,t)=>{t||(t=duplicateEdges(e));const r=Object.keys(t).map((e=>parseInt(e,10))),s=replaceGeometryIndices(e,n,t);return r.length&&(e.vertices_edges||e.vertices_vertices||e.vertices_faces)&&(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),e.vertices_faces=makeVerticesFaces(e)),{map:s,remove:r}};var Oe=Object.freeze({__proto__:null,circularEdges:circularEdges,duplicateEdges:duplicateEdges,removeCircularEdges:removeCircularEdges,removeDuplicateEdges:removeDuplicateEdges});const mergeSimpleNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>t));return e.forEach((e=>t.forEach(((r,s)=>{t[s]=e[r]})))),t},mergeNextmaps=(...e)=>{if(0===e.length)return[];const t=e[0].map(((e,t)=>[t]));return e.forEach((e=>{t.forEach(((r,s)=>r.forEach(((r,o)=>{t[s][o]=e[r]})))),t.forEach(((e,r)=>{t[r]=e.reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0!==e))}))})),t},mergeBackmaps=(...e)=>{if(0===e.length)return[];let r=e[0].reduce(((e,t)=>e.concat(t)),[]).map(((e,t)=>[t]));return e.forEach((e=>{const s=[];e.forEach(((e,o)=>{s[o]=typeof e===t?r[e]:e.map((e=>r[e])).reduce(((e,t)=>e.concat(t)),[])})),r=s})),r},invertMap=e=>{const r=[],setIndexValue=(e,s)=>{void 0!==r[e]?typeof r[e]===t?r[e]=[r[e],s]:r[e].push(s):r[e]=s};return e.forEach(((e,r)=>{null!=e&&(typeof e===t&&setIndexValue(e,r),e.constructor===Array&&e.forEach((e=>setIndexValue(e,r))))})),r},invertSimpleMap=e=>{const t=[];return e.forEach(((e,r)=>{t[e]=r})),t};var Me=Object.freeze({__proto__:null,mergeSimpleNextmaps:mergeSimpleNextmaps,mergeNextmaps:mergeNextmaps,mergeSimpleBackmaps:(...e)=>{if(0===e.length)return[];let t=e[0].map(((e,t)=>t));return e.forEach((e=>{const r=e.map((e=>t[e]));t=r})),t},mergeBackmaps:mergeBackmaps,invertMap:invertMap,invertSimpleMap:invertSimpleMap});const clean=(e,t)=>{const r=removeDuplicateVertices(e,t),s=removeCircularEdges(e),o=removeDuplicateEdges(e),n=removeIsolatedVertices(e),a=invertSimpleMap(r.map),c=n.remove.map((e=>a[e])),i=invertSimpleMap(s.map),l=o.remove.map((e=>i[e]));return{vertices:{map:mergeSimpleNextmaps(r.map,n.map),remove:r.remove.concat(c)},edges:{map:mergeSimpleNextmaps(s.map,o.map),remove:s.remove.concat(l)}}},validate=(e,t)=>{const r=duplicateEdges(e),s=circularEdges(e),o=isolatedVertices(e),n=duplicateVertices(e,t),a=(e=>{const t=count.vertices(e),r=count.edges(e),s=count.faces(e);return{vertices:t>=countImplied.vertices(e),edges:r>=countImplied.edges(e),faces:s>=countImplied.faces(e)}})(e);return{summary:0===r.length&&0===s.length&&0===o.length&&a.vertices&&a.edges&&a.faces?"valid":"problematic",vertices:{isolated:o,duplicate:n,references:a.vertices},edges:{circular:s,duplicate:r,references:a.edges},faces:{references:a.faces}}},populate=(e,t)=>"object"!=typeof e?e:e.edges_vertices?(e.vertices_edges=makeVerticesEdgesUnsorted(e),e.vertices_vertices=makeVerticesVertices(e),e.vertices_edges=makeVerticesEdges(e),(e=>{const t=e.edges_vertices.length;if(e.edges_assignment||(e.edges_assignment=[]),e.edges_foldAngle||(e.edges_foldAngle=[]),e.edges_assignment.length>e.edges_foldAngle.length)for(let t=e.edges_foldAngle.length;t<e.edges_assignment.length;t+=1)e.edges_foldAngle[t]=edgeAssignmentToFoldAngle(e.edges_assignment[t]);if(e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);for(let r=e.edges_assignment.length;r<t;r+=1)e.edges_assignment[r]="U",e.edges_foldAngle[r]=0})(e),((e,t)=>{if(void 0!==t||e.faces_vertices||e.faces_edges||(t=!0),t&&e.vertices_coords){const t=makePlanarFaces(e);return e.faces_vertices=t.map((e=>e.vertices)),void(e.faces_edges=t.map((e=>e.edges)))}e.faces_vertices&&e.faces_edges||(e.faces_vertices&&!e.faces_edges?e.faces_edges=makeFacesEdgesFromVertices(e):e.faces_edges&&!e.faces_vertices?e.faces_vertices=makeFacesVerticesFromEdges(e):(e.faces_vertices=[],e.faces_edges=[]))})(e,t),e.vertices_faces=makeVerticesFaces(e),e.edges_faces=makeEdgesFacesUnsorted(e),e.faces_faces=makeFacesFaces(e),e):e,collinearBetween=(e,t,r,s=!1,o=L)=>{if([e,r].map((e=>fnEpsilonEqualVectors(t,e))).reduce(((e,t)=>e||t),!1))return s;const n=[[e,t],[t,r]].map((e=>subtract(e[1],e[0]))).map((e=>normalize(e)));return fnEpsilonEqual(1,dot(...n),o)},pleat=(e,t,r,s=L)=>{const o=dot(e.vector,t.vector),n=cross2(e.vector,t.vector),a=cross2(subtract2(t.origin,e.origin),t.vector)/n,c=[e.vector,t.vector].map((e=>normalize(e))),i=(n>-s?[[e.vector,t.vector],[flip(t.vector),e.vector]]:[[t.vector,e.vector],[flip(e.vector),t.vector]]).map((e=>counterClockwiseSubsect2(e[0],e[1],r))),l=Math.abs(cross2(...c))<s,d=l?void 0:add2(e.origin,scale2(e.vector,a)),m=Array.from(Array(r-1)),p=l?m.map(((s,o)=>lerp(e.origin,t.origin,(o+1)/r))):m.map((()=>d)),g=i.map((e=>e.map(((e,t)=>({vector:e,origin:[...p[t]]})))));return l&&(g[o>-s?1:0]=[]),g},bisectLines2=(e,t,r=L)=>{const s=pleat(e,t,2,r).map((e=>e[0]));return s.forEach(((e,t)=>{void 0===e&&delete s[t]})),s};var we=Object.freeze({__proto__:null,bisectLines2:bisectLines2,collinearBetween:collinearBetween,lerpLines:(e,t,r)=>({vector:lerp(e.vector,t.vector,r),origin:lerp(e.origin,t.origin,r)}),pleat:pleat});const overlapBoundingBoxes=(e,t,r=L)=>{const s=Math.min(e.min.length,t.min.length);for(let o=0;o<s;o+=1)if(e.min[o]>t.max[o]+r||e.max[o]<t.min[o]-r)return!1;return!0},overlapLineLine=(e,t,r=q,s=q,o=L)=>{const n=cross2(e.vector,t.vector),a=-n,c=subtract2(t.origin,e.origin);if(Math.abs(n)<o){if(Math.abs(cross2(c,e.vector))>o)return!1;const n=subtract2(e.origin,t.origin),a=add2(n,e.vector),i=c,l=add2(i,t.vector),d=dot2(e.vector,e.vector),m=dot2(e.vector,e.vector),p=dot2(n,t.vector)/m,g=dot2(a,t.vector)/m,u=dot2(i,e.vector)/d,v=dot2(l,e.vector)/d;return r(u,o)||r(v,o)||s(p,o)||s(g,o)}const i=[-c[0],-c[1]],l=cross2(c,t.vector)/n,d=cross2(i,e.vector)/a;return r(l,o/magnitude2(e.vector))&&s(d,o/magnitude2(t.vector))},overlapLinePoint=({vector:e,origin:t},r,s=q,o=L)=>{const n=subtract2(r,t),a=magSquared(e),c=Math.sqrt(a);if(c<o)return!1;const i=cross2(n,e.map((e=>e/c))),l=dot2(n,e)/a;return Math.abs(i)<o&&s(l,o/c)},overlapConvexPolygonPoint=(e,t,r=exclude,s=L)=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>cross2(normalize2(subtract2(e[1],e[0])),subtract2(t,e[0])))).map((e=>r(e,s))).map(((e,t,r)=>e===r[0])).reduce(((e,t)=>e&&t),!0),overlapConvexPolygons=(e,t,r=L)=>{for(let s=0;s<2;s+=1){const o=0===s?e:t,n=0===s?t:e;for(let e=0;e<o.length;e+=1){const t=o[e],s=rotate90(subtract2(o[(e+1)%o.length],o[e])),a=n.map((e=>subtract2(e,t))).map((e=>dot2(s,e))),c=o[(e+2)%o.length],i=dot2(s,subtract2(c,t))>0;if(a.map((e=>i?e<r:e>-r)).reduce(((e,t)=>e&&t),!0))return!1}}return!0};var je=Object.freeze({__proto__:null,overlapBoundingBoxes:overlapBoundingBoxes,overlapCirclePoint:({radius:e,origin:t},r,s=exclude,o=L)=>s(e-distance2(t,r),o),overlapConvexPolygonPoint:overlapConvexPolygonPoint,overlapConvexPolygons:overlapConvexPolygons,overlapLineLine:overlapLineLine,overlapLinePoint:overlapLinePoint});const getEdgesVerticesOverlappingSpan=(e,t=L)=>makeEdgesBoundingBox(e,t).map((t=>e.vertices_coords.map((e=>e[0]>t.min[0]&&e[1]>t.min[1]&&e[0]<t.max[0]&&e[1]<t.max[1])))),getEdgesEdgesOverlapingSpans=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=L)=>{const o=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},s),n=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let r=e+1;r<t.length;r+=1){const t=(o[e].max[0]<o[r].min[0]||o[r].max[0]<o[e].min[0])&&(o[e].max[1]<o[r].min[1]||o[r].max[1]<o[e].min[1]);n[e][r]=!t,n[r][e]=!t}for(let e=0;e<t.length;e+=1)n[e][e]=!0;return n};var Fe=Object.freeze({__proto__:null,getEdgesVerticesOverlappingSpan:getEdgesVerticesOverlappingSpan,getEdgesEdgesOverlapingSpans:getEdgesEdgesOverlapingSpans});const getOppositeVertices=({edges_vertices:e},t,r)=>(r.forEach((r=>{if(e[r][0]===t&&e[r][1]===t)throw new Error(j)})),r.map((r=>e[r][0]===t?e[r][1]:e[r][0]))),isVertexCollinear=({vertices_coords:e,vertices_edges:t,edges_vertices:r},s,o=L)=>{if(!e||!r)return!1;t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const n=t[s];if(void 0===n||2!==n.length)return!1;const a=getOppositeVertices({edges_vertices:r},s,n),c=[a[0],s,a[1]].map((t=>e[t]));return collinearBetween(...c,!1,o)},getVerticesEdgesOverlap=({vertices_coords:e,edges_vertices:t,edges_coords:r},s=L)=>{r||(r=t.map((t=>t.map((t=>e[t])))));const o=getEdgesVerticesOverlappingSpan({vertices_coords:e,edges_vertices:t,edges_coords:r},s);for(let t=0;t<r.length;t+=1)for(let n=0;n<e.length;n+=1)o[t][n]&&(o[t][n]=overlapLinePoint({vector:subtract(r[t][1],r[t][0]),origin:r[t][0]},e[n],excludeS,s));return o.map((e=>e.map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))};var Pe=Object.freeze({__proto__:null,isVertexCollinear:isVertexCollinear,getVerticesEdgesOverlap:getVerticesEdgesOverlap});const intersectLineLine=(e,t,r=D,s=D,o=L)=>{const n=cross2(normalize2(e.vector),normalize2(t.vector));if(Math.abs(n)<o)return;const a=cross2(e.vector,t.vector),c=-a,i=[t.origin[0]-e.origin[0],t.origin[1]-e.origin[1]],l=[-i[0],-i[1]],d=cross2(i,t.vector)/a,m=cross2(l,e.vector)/c;return r(d,o/magnitude2(e.vector))&&s(m,o/magnitude2(t.vector))?add2(e.origin,scale2(e.vector,d)):void 0},intersectCircleLine=(e,t,r=D,s=L)=>{const o=t.vector[0]**2+t.vector[1]**2,n=Math.sqrt(o),a=0===n?t.vector:t.vector.map((e=>e/n)),c=rotate90(a),i=subtract2(t.origin,e.origin),l=cross2(i,a);if(Math.abs(l)>e.radius+s)return;const d=Math.sqrt(e.radius**2-l**2),f=(t,r)=>e.origin[r]-c[r]*l+a[r]*t,m=Math.abs(e.radius-Math.abs(l))<s?[d].map((e=>[e,e].map(f))):[-d,d].map((e=>[e,e].map(f))),p=m.map((e=>e.map(((e,r)=>e-t.origin[r])))).map((e=>e[0]*t.vector[0]+t.vector[1]*e[1])).map((e=>e/o));return m.filter(((e,t)=>r(p[t],s)))},rotateVector2=(e,t,r)=>{const s=t[0]-e[0],o=t[1]-e[1],n=s*Math.cos(r)+o*Math.sin(r),a=o*Math.cos(r)-s*Math.sin(r);return[e[0]+n,e[1]+a]},getUniquePair=e=>{for(let t=1;t<e.length;t+=1)if(!fnEpsilonEqualVectors(e[0],e[t]))return[e[0],e[t]]},intersectConvexPolygonLineInclusive=(e,{vector:t,origin:r},s=includeS,o=D,n=L)=>{const a=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>intersectLineLine({vector:subtract2(e[1],e[0]),origin:e[0]},{vector:t,origin:r},s,o,n))).filter((e=>void 0!==e));switch(a.length){case 0:return;case 1:return[a];default:return getUniquePair(a)||[a[0]]}},intersectConvexPolygonLine=(e,{vector:t,origin:r},s=includeS,o=q,n=L)=>{const a=intersectConvexPolygonLineInclusive(e,{vector:t,origin:r},s,o,n);let c;switch(o){case W:c=G;break;case excludeS:c=includeS;break;default:return a}const i=intersectConvexPolygonLineInclusive(e,{vector:t,origin:r},includeS,c,n);if(void 0===i)return;const l=getUniquePair(i);if(void 0===l)switch(o){case W:return overlapConvexPolygonPoint(e,r,exclude,n)?i:void 0;case excludeS:return overlapConvexPolygonPoint(e,add2(r,t),exclude,n)||overlapConvexPolygonPoint(e,r,exclude,n)?i:void 0;default:return}return overlapConvexPolygonPoint(e,midpoint2(...l),exclude,n)?l:a};var Ce=Object.freeze({__proto__:null,intersectCircleCircle:(e,t,r=L)=>{const s=e.radius<t.radius?e.radius:t.radius,o=e.radius<t.radius?t.radius:e.radius,n=e.radius<t.radius?e.origin:t.origin,a=e.radius<t.radius?t.origin:e.origin,c=[n[0]-a[0],n[1]-a[1]],i=Math.sqrt(c[0]**2+c[1]**2);if(i<r)return;const l=c.map(((e,t)=>e/i*o+a[t]));if(Math.abs(o+s-i)<r||Math.abs(o-(s+i))<r)return[l];if(i+s<o||o+s<i)return;const d=(m=(s*s-i*i-o*o)/(-2*i*o))>=1?0:m<=-1?Math.PI:Math.acos(m);var m;return[rotateVector2(a,l,+d),rotateVector2(a,l,-d)]},intersectCircleLine:intersectCircleLine,intersectConvexPolygonLine:intersectConvexPolygonLine,intersectLineLine:intersectLineLine});const makeEdgesLineParallelOverlap=({vertices_coords:e,edges_vertices:t},r,s,o=L)=>{const n=normalize2(r),a=t.map((t=>e[t[0]])),c=t.map((t=>t.map((t=>e[t])))).map((e=>subtract2(e[1],e[0]))).map((e=>parallel2(e,r,o)));for(let e=0;e<t.length;e+=1){if(!c[e])continue;if(fnEpsilonEqualVectors(a[e],s)){c[e]=!0;continue}const t=normalize2(subtract2(a[e],s)),r=Math.abs(dot2(t,n));c[e]=Math.abs(1-r)<o}return c},makeEdgesSegmentIntersection=({vertices_coords:e,edges_vertices:t,edges_coords:r},s,o,n=L)=>{r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t}));const a=boundingBox$1([s,o],n),c=subtract2(o,s);return makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r},n).map((e=>overlapBoundingBoxes(a,e))).map(((e,t)=>e?intersectLineLine({vector:c,origin:s},{vector:subtract2(r[t][1],r[t][0]),origin:r[t][0]},includeS,includeS,n):void 0))},makeEdgesEdgesIntersection=function({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_origin:s},o=L){r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t})),s||(s=t.map((t=>e[t[0]])));const n=r.map((()=>[])),a=getEdgesEdgesOverlapingSpans({vertices_coords:e,edges_vertices:t},o);for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(!0!==a[e][t])continue;const c=intersectLineLine({vector:r[e],origin:s[e]},{vector:r[t],origin:s[t]},excludeS,excludeS,o);void 0!==c&&(n[e][t]=c,n[t][e]=c)}return n},intersectConvexFaceLine=({vertices_coords:e,edges_vertices:t,faces_vertices:r,faces_edges:s},o,{vector:n,origin:a},c=L)=>{const i=r[o].map((t=>e[t])).map((e=>overlapLinePoint({vector:n,origin:a},e,(()=>!0),c))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),l=i.map((e=>r[o][e]));if(i.concat(i.map((e=>e+r[o].length))).map(((e,t,r)=>r[t+1]-e==1)).reduce(((e,t)=>e||t),!1))return;if(l.length>1)return{vertices:l,edges:[]};const d=s[o].map((r=>t[r].map((t=>e[t])))).map((e=>intersectLineLine({vector:n,origin:a},{vector:subtract(e[1],e[0]),origin:e[0]},D,excludeS,c))).map(((e,t)=>({coords:e,edge:s[o][t]}))).filter((e=>void 0!==e.coords)).filter((e=>!l.map((r=>t[e.edge].includes(r))).reduce(((e,t)=>e||t),!1)));return d.length+l.length===2?{vertices:l,edges:d}:void 0};var Se=Object.freeze({__proto__:null,makeEdgesLineParallelOverlap:makeEdgesLineParallelOverlap,makeEdgesSegmentIntersection:makeEdgesSegmentIntersection,makeEdgesEdgesIntersection:makeEdgesEdgesIntersection,intersectConvexFaceLine:intersectConvexFaceLine});const fragment_graph=(e,t=L)=>{const r=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))),s=r.map((e=>subtract(e[1],e[0]))),o=r.map((e=>e[0])),n=makeEdgesEdgesIntersection({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_vector:s,edges_origin:o},1e-6),a=getVerticesEdgesOverlap({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_coords:r},t);if(0===n.flat().filter((e=>void 0!==e)).length&&0===a.flat().filter((e=>void 0!==e)).length)return;const c=e.vertices_coords.length;n.forEach((t=>t.filter((e=>void 0!==e)).filter((e=>2===e.length)).forEach((t=>{const r=e.vertices_coords.length;e.vertices_coords.push([...t]),t.splice(0,2),t.push(r)})))),n.forEach(((e,t)=>{e.forEach(((e,r)=>{e&&(n[t][r]=e[0])}))}));const i=n.map((e=>e.filter((e=>void 0!==e))));e.edges_vertices.forEach(((e,t)=>e.push(...i[t],...a[t]))),e.edges_vertices.forEach(((t,r)=>{e.edges_vertices[r]=sortVerticesAlongVector({vertices_coords:e.vertices_coords},t,s[r])}));const l=e.edges_vertices.map(((e,t)=>Array(e.length-1).fill(t))).flat();if(e.edges_vertices=e.edges_vertices.map((e=>Array.from(Array(e.length-1)).map(((t,r,s)=>[e[r],e[r+1]])))).flat(),e.edges_assignment&&e.edges_foldAngle&&e.edges_foldAngle.length>e.edges_assignment.length)for(let t=e.edges_assignment.length;t<e.edges_foldAngle.length;t+=1)e.edges_assignment[t]=edgeFoldAngleToAssignment(e.edges_foldAngle[t]);return e.edges_assignment&&(e.edges_assignment=l.map((t=>e.edges_assignment[t]||"U"))),e.edges_foldAngle&&(e.edges_foldAngle=l.map((t=>e.edges_foldAngle[t])).map(((t,r)=>void 0===t?edgeAssignmentToFoldAngle(e.edges_assignment[r]):t))),{vertices:{new:Array.from(Array(e.vertices_coords.length-c)).map(((e,t)=>c+t))},edges:{backmap:l}}},Ne=[i,l,m,p],fragment=(e,t=L)=>{e.vertices_coords=e.vertices_coords.map((e=>e.slice(0,2))),[o,n,a].map((t=>getGraphKeysWithPrefix(e,t))).flat().filter((e=>!Ne.includes(e))).forEach((t=>delete e[t]));const r={vertices:{},edges:{}};let s;for(s=0;s<20;s+=1){const s=removeDuplicateVertices(e,t/2),o=removeDuplicateEdges(e),n=removeCircularEdges(e),a=fragment_graph(e,t);if(void 0===a){r.vertices.map=void 0===r.vertices.map?s.map:mergeNextmaps(r.vertices.map,s.map),r.edges.map=void 0===r.edges.map?mergeNextmaps(o.map,n.map):mergeNextmaps(r.edges.map,o.map,n.map);break}const c=invertMap(a.edges.backmap),i=mergeNextmaps(o.map,n.map,c);r.vertices.map=void 0===r.vertices.map?s.map:mergeNextmaps(r.vertices.map,s.map),r.edges.map=void 0===r.edges.map?i:mergeNextmaps(r.edges.map,i)}if(20===s)throw new Error(x);return r},boundingBox=({vertices_coords:e},t)=>boundingBox$1(e,t),boundaryVertices=({edges_vertices:e,edges_assignment:t})=>uniqueElements(e.filter(((e,r)=>"B"===t[r]||"b"===t[r])).flat()),boundary=({vertices_edges:e,edges_vertices:t,edges_assignment:r})=>{if(void 0===r)return{vertices:[],edges:[]};e||(e=makeVerticesEdgesUnsorted({edges_vertices:t}));const s=r.map((e=>"B"===e||"b"===e)),o=[],n=[];let a=-1;for(let e=0;e<s.length;e+=1)if(s[e]){a=e;break}if(-1===a)return{vertices:[],edges:[]};s[a]=!1,o.push(a),n.push(t[a][0]);let c=t[a][1];for(;n[0]!==c;){if(n.push(c),a=e[c].filter((e=>s[e])).shift(),void 0===a)return{vertices:[],edges:[]};t[a][0]===c?[,c]=t[a]:[c]=t[a],s[a]=!1,o.push(a)}return{vertices:n,edges:o}},planarBoundary=({vertices_coords:e,vertices_edges:t,vertices_vertices:r,edges_vertices:s},o=!0)=>{r||(r=makeVerticesVertices({vertices_coords:e,vertices_edges:t,edges_vertices:s}));const n=makeVerticesToEdgeBidirectional({edges_vertices:s}),a=[],c=[],i={vertices:c,edges:a};let l=-1/0,d=-1;if(e.forEach(((e,t)=>{e[0]>l&&(l=e[0],d=t)})),-1===d)return i;c.push(d);const m=e[d],p=r[d],g=p.map((t=>e[t])).map((e=>[e[0]-m[0],e[1]-m[1]])).map((e=>Math.atan2(e[1],e[0]))).map((e=>e<0?e+2*Math.PI:e)).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a)).shift().i,u=p[g],v=n[d<u?`${d} ${u}`:`${u} ${d}`];a.push(v);let h=d,_=u;const b=performance.now();let y=0;for(;;){const e=r[_],t=e.indexOf(h),s=e[(t+1)%e.length],l=n[_<s?`${_} ${s}`:`${s} ${_}`];if(l===a[0])return i;if(c.push(_),a.push(l),h=_,_=s,y+=1,o&&y%1e3==0&&performance.now()-b>1e4)throw new Error(w)}};var ze=Object.freeze({__proto__:null,boundingBox:boundingBox,boundaryVertices:boundaryVertices,boundary:boundary,planarBoundary:planarBoundary});const apply_matrix_to_graph=function(e,t){return filterKeysWithSuffix(e,"coords").forEach((r=>{e[r]=e[r].map((e=>resize(3,e))).map((e=>multiplyMatrix3Vector3(t,e)))})),filterKeysWithSuffix(e,"matrix").forEach((r=>{e[r]=e[r].map((e=>multiplyMatrices3(e,t)))})),e};var $e={scale:(e,...t)=>{const r=1===t.length?[t[0],t[0],t[0]]:[1,1,1].map(((e,r)=>void 0===t[r]?e:t[r])),s=makeMatrix3Scale(r);return apply_matrix_to_graph(e,s)},translate:(e,...t)=>{const r=getVector(...t),s=resize(3,r),o=makeMatrix3Translate(...s);return apply_matrix_to_graph(e,o)},rotateZ:(e,t,...r)=>{const s=getVector(...r),o=resize(3,s),n=makeMatrix3RotateZ(t,...o);return apply_matrix_to_graph(e,n)},transform:apply_matrix_to_graph};const getFaceFaceSharedVertices=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const s=e.map((e=>!!r[e])),o=[],n=s.indexOf(!1),a={};for(let t=n+1;t<s.length;t+=1)s[t]&&!a[e[t]]&&(o.push(e[t]),a[e[t]]=!0);for(let t=0;t<n;t+=1)s[t]&&!a[e[t]]&&(o.push(e[t]),a[e[t]]=!0);return o},makeFaceSpanningTree=({faces_vertices:e,faces_faces:t},r=0)=>{if(t||(t=makeFacesFaces({faces_vertices:e})),0===t.length)return[];const s=[[{face:r}]],o={};o[r]=!0;do{const r=s[s.length-1].map((e=>t[e.face].map((t=>({face:t,parent:e.face}))))).reduce(((e,t)=>e.concat(t)),[]),n={};r.forEach(((e,t)=>{o[e.face]&&(n[t]=!0),o[e.face]=!0}));const a=r.filter(((e,t)=>!n[t]));a.map((t=>getFaceFaceSharedVertices(e[t.face],e[t.parent]))).forEach(((e,t)=>{const r=e.slice(0,2);a[t].edge_vertices=r})),s[s.length]=a}while(s[s.length-1].length>0);return s.length>0&&0===s[s.length-1].length&&s.pop(),s};var Ve=Object.freeze({__proto__:null,getFaceFaceSharedVertices:getFaceFaceSharedVertices,makeFaceSpanningTree:makeFaceSpanningTree});const multiplyVerticesFacesMatrix2=({vertices_coords:e,vertices_faces:t,faces_vertices:r},s)=>{t||(t=makeVerticesFaces({faces_vertices:r}));const o=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?Y:s[e]));return e.map(((e,t)=>multiplyMatrix2Vector2(o[t],e)))},Te={U:!0,u:!0},makeFacesMatrix=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:n},a=0)=>{!s&&r&&(s=makeEdgesAssignmentSimple({edges_foldAngle:r})),r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0));const c=makeVerticesToEdgeBidirectional({edges_vertices:t}),i=o.map((()=>Q));return makeFaceSpanningTree({faces_vertices:o,faces_faces:n},a).slice(1).forEach((t=>t.forEach((t=>{const o=t.edge_vertices.map((t=>e[t])),n=t.edge_vertices.join(" "),a=c[n],l=Te[s[a]]?Math.PI:r[a]*Math.PI/180,d=makeMatrix3Rotate(l,subtract(...resizeUp(o[1],o[0])),o[0]);i[t.face]=multiplyMatrices3(i[t.parent],d)})))),i},Le={M:!0,m:!0,V:!0,v:!0,U:!0,u:!0,F:!1,f:!1,B:!1,b:!1},makeEdgesIsFolded=({edges_vertices:e,edges_foldAngle:t,edges_assignment:r})=>void 0===r?void 0===t?e.map((()=>!0)):t.map((e=>e<-L||e>L)):r.map((e=>Le[e])),makeFacesMatrix2=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:n},a=0)=>{r||(r=s?makeEdgesFoldAngle({edges_assignment:s}):Array(t.length).fill(0));const c=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=makeVerticesToEdgeBidirectional({edges_vertices:t}),l=o.map((()=>Y));return makeFaceSpanningTree({faces_vertices:o,faces_faces:n},a).slice(1).forEach((t=>t.forEach((t=>{const r=t.edge_vertices.map((t=>e[t])),s=t.edge_vertices.join(" "),o=i[s],n=subtract2(r[1],r[0]),a=r[0],d=c[o]?makeMatrix2Reflect(n,a):Y;l[t.face]=multiplyMatrices2(l[t.parent],d)})))),l};var Ie=Object.freeze({__proto__:null,multiplyVerticesFacesMatrix2:multiplyVerticesFacesMatrix2,makeFacesMatrix:makeFacesMatrix,makeEdgesIsFolded:makeEdgesIsFolded,makeFacesMatrix2:makeFacesMatrix2});const makeVerticesCoordsFolded=({vertices_coords:e,vertices_faces:t,edges_vertices:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:n,faces_faces:a,faces_matrix:c},i)=>{c=makeFacesMatrix({vertices_coords:e,edges_vertices:r,edges_foldAngle:s,edges_assignment:o,faces_vertices:n,faces_faces:a},i),t||(t=makeVerticesFaces({faces_vertices:n}));const l=t.map((e=>e.filter((e=>null!=e)).shift())).map((e=>void 0===e?Q:c[e]));return e.map((e=>resize(3,e))).map(((e,t)=>multiplyMatrix3Vector3(l[t],e)))},makeVerticesCoordsFlatFolded=({vertices_coords:e,edges_vertices:t,edges_foldAngle:r,edges_assignment:s,faces_vertices:o,faces_faces:n},a=0)=>{const c=makeEdgesIsFolded({edges_vertices:t,edges_foldAngle:r,edges_assignment:s}),i=[];o[a].forEach((t=>{i[t]=[...e[t]]}));const l=[];l[a]=!1;const d=makeVerticesToEdgeBidirectional({edges_vertices:t});return makeFaceSpanningTree({faces_vertices:o,faces_faces:n},a).slice(1).forEach((r=>r.forEach((r=>{const s=r.edge_vertices.join(" "),n=d[s],a=t[n].map((e=>i[e]));if(void 0===a[0]||void 0===a[1])return;const m=t[n].map((t=>e[t])),p=m[0],g=normalize2(subtract2(m[1],m[0])),u=rotate90(g);l[r.face]=c[n]?!l[r.parent]:l[r.parent];const v=normalize2(subtract2(a[1],a[0])),h=a[0],_=l[r.face]?rotate270(v):rotate90(v);o[r.face].filter((e=>void 0===i[e])).forEach((t=>{const r=subtract2(e[t],p),s=dot(r,u),o=dot(r,g),n=scale2(v,o),a=scale2(_,s),c=add2(add2(h,n),a);i[t]=c}))})))),i};var Be=Object.freeze({__proto__:null,makeVerticesCoordsFolded:makeVerticesCoordsFolded,makeVerticesCoordsFlatFolded:makeVerticesCoordsFlatFolded});const clone=function(e){let t,s;if(typeof e!==r)return e;if(!e)return e;if("[object Array]"===Object.prototype.toString.apply(e)){for(t=[],s=0;s<e.length;s+=1)t[s]=clone(e[s]);return t}for(s in t={},e)e.hasOwnProperty(s)&&(t[s]=clone(e[s]));return t},makeFacesWindingFromMatrix2=e=>e.map((e=>e[0]*e[3]-e[1]*e[2])).map((e=>e>=0)),makeFacesWinding=({vertices_coords:e,faces_vertices:t})=>t.map((t=>t.map((t=>e[t])).map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>(e[1][0]-e[0][0])*(e[1][1]+e[0][1]))).reduce(((e,t)=>e+t),0))).map((e=>e<0));var Re=Object.freeze({__proto__:null,makeFacesWindingFromMatrix:e=>e.map((e=>e[0]*e[4]-e[1]*e[3])).map((e=>e>=0)),makeFacesWindingFromMatrix2:makeFacesWindingFromMatrix2,makeFacesWinding:makeFacesWinding});const explode=e=>{if(!e.faces_vertices)return{};const t=e.faces_edges?e.faces_edges:makeFacesEdgesFromVertices(e),r=e.faces_vertices.flatMap((e=>e)),s=t.flatMap((e=>e));let o=0,n=0,a=0;return e.faces_vertices=e.faces_vertices.map((e=>e.map((()=>o++)))),e.faces_edges=e.faces_edges.map((e=>e.map((()=>n++)))),e.edges_vertices=e.faces_edges.flatMap((e=>e.map(((e,t,r)=>{const s=t===r.length-1?[a,a+1-r.length]:[a,a+1];return a+=1,s})))),e.vertices_coords&&(e.vertices_coords=clone(r.map((t=>e.vertices_coords[t])))),e.edges_assignment&&(e.edges_assignment=clone(s.map((t=>e.edges_assignment[t])))),e.edges_foldAngle&&(e.edges_foldAngle=clone(s.map((t=>e.edges_foldAngle[t])))),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_edges&&delete e.edges_edges,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,{vertices:{map:r},edges:{map:s}}},explodeFaces=e=>{const t=e.faces_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t]))));let r=0;const s=e.faces_vertices.map((e=>e.map((()=>r++))));return{vertices_coords:JSON.parse(JSON.stringify(t)),faces_vertices:s}},explodeShrinkFaces=({vertices_coords:e,faces_vertices:t},r=.333)=>{const s=explodeFaces({vertices_coords:e,faces_vertices:t}),o=makeFacesWinding(s),n=s.faces_vertices.map((e=>e.map((e=>s.vertices_coords[e])))).map((e=>e.map(((e,t,r)=>subtract2(e,r[(t+1)%r.length]))))),a=makeFacesConvexCenter({vertices_coords:e,faces_vertices:t}),c=t.map((t=>t.map((t=>e[t])))).map(((e,t)=>e.map((e=>distance2(e,a[t]))))),i=n.map(((e,t)=>e.map(((e,t,r)=>[e,flip(r[(t-1+r.length)%r.length])])).map((e=>o[t]?counterClockwiseBisect2(...e):clockwiseBisect2(...e))))).map(((e,t)=>e.map(((e,r)=>scale(e,c[t][r])))));return s.faces_vertices.forEach(((e,t)=>e.forEach(((e,o)=>{s.vertices_coords[e]=add2(s.vertices_coords[e],scale2(i[t][o],-r))})))),s};var Ue=Object.freeze({__proto__:null,explode:explode,explodeFaces:explodeFaces,explodeShrinkFaces:explodeShrinkFaces});const nearestPointOnLine=({vector:e,origin:t},r,s=clampLine,o=L)=>{t=resize(e.length,t),r=resize(e.length,r);const n=magSquared(e),a=subtract(r,t),c=s(dot(e,a)/n,o);return add(t,scale(e,c))};var De=Object.freeze({__proto__:null,nearestPoint:(e,t)=>{const r=smallestComparisonSearch(e,t,distance);return void 0===r?void 0:e[r]},nearestPoint2:(e,t)=>{const r=smallestComparisonSearch(e,t,distance2);return void 0===r?void 0:e[r]},nearestPointOnCircle:({radius:e,origin:t},r)=>add(t,scale(normalize(subtract(r,t)),e)),nearestPointOnLine:nearestPointOnLine,nearestPointOnPolygon:(e,t)=>e.map(((e,t,r)=>subtract(r[(t+1)%r.length],e))).map(((t,r)=>({vector:t,origin:e[r]}))).map((e=>nearestPointOnLine(e,t,clampSegment))).map(((e,r)=>({point:e,edge:r,distance:distance(e,t)}))).sort(((e,t)=>e.distance-t.distance)).shift()});const nearestVertex=({vertices_coords:e},t)=>{if(!e)return;const r=resize(e[0].length,t),s=e.map(((e,t)=>({d:distance(r,e),i:t}))).sort(((e,t)=>e.d-t.d)).shift();return s?s.i:void 0},nearestEdge=({vertices_coords:e,edges_vertices:t},r)=>{if(!e||!t)return;const s=t.map((t=>t.map((t=>e[t])))).map((e=>nearestPointOnLine({vector:subtract(e[1],e[0]),origin:e[0]},r,clampSegment)));return smallestComparisonSearch(s,r,distance)},faceContainingPoint=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!t)return;const s=t.map(((t,r)=>({face:t.map((t=>e[t])),i:r}))).filter((e=>overlapConvexPolygonPoint(e.face,r))).shift();return void 0===s?void 0:s.i},nearestFace=(e,t)=>{const r=faceContainingPoint(e,t);if(void 0!==r)return r;if(e.edges_faces){const r=nearestEdge(e,t),s=e.edges_faces[r];if(1===s.length)return s[0];if(s.length>1){const r=makeFacesConvexCenter({vertices_coords:e.vertices_coords,faces_vertices:s.map((t=>e.faces_vertices[t]))}).map((e=>distance(e,t)));let o=0;for(let e=0;e<r.length;e+=1)r[e]<r[o]&&(o=e);return s[o]}}};var qe=Object.freeze({__proto__:null,nearestVertex:nearestVertex,nearestEdge:nearestEdge,faceContainingPoint:faceContainingPoint,nearestFace:nearestFace,nearest:(e,...t)=>{const r={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace},s=getVector(...t),o=Object.create(null);return["vertices","edges","faces"].forEach((t=>{Object.defineProperty(o,ie[t],{enumerable:!0,get:()=>r[t](e,s)}),filterKeysWithPrefix(e,t).forEach((r=>Object.defineProperty(o,r,{enumerable:!0,get:()=>e[r][o[ie[t]]]})))})),o}});const addVertices=(e,t,r=L)=>{e.vertices_coords||(e.vertices_coords=[]),"number"==typeof t[0]&&(t=[t]);const s=t.map((t=>e.vertices_coords.map((e=>distance(e,t)<r)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).shift()));let o=e.vertices_coords.length;const n=t.filter(((e,t)=>void 0===s[t]));return e.vertices_coords.push(...n),s.map((e=>void 0===e?o++:e))},splitEdge=(e,t,r,s=L)=>{if(e.edges_vertices.length<t)return{};const o=e.edges_vertices[t];r||(r=midpoint(...o));const a=o.map((t=>e.vertices_coords[t])).map((e=>distance(e,r)<s));if(a[0])return{vertex:o[0],edges:{}};if(a[1])return{vertex:o[1],edges:{}};const c=e.vertices_coords.length;e.vertices_coords[c]=r;const i=[0,1].map((t=>t+e.edges_vertices.length));((e,t,r)=>{const s=e.edges_vertices[t],o=[{edges_vertices:[s[0],r]},{edges_vertices:[r,s[1]]}];if(o.forEach((r=>[m,p].filter((r=>e[r]&&void 0!==e[r][t])).forEach((s=>{r[s]=e[s][t]})))),e.vertices_coords&&(e.edges_length||e.edges_vector)){const t=o.map((t=>t.edges_vertices.map((t=>e.vertices_coords[t]))));e.edges_vector&&o.forEach(((e,r)=>{e.edges_vector=subtract(t[r][1],t[r][0])})),e.edges_length&&o.forEach(((e,r)=>{e.edges_length=distance(...t[r])}))}return o})(e,t,c).forEach(((t,r)=>Object.keys(t).forEach((s=>{e[s][i[r]]=t[s]})))),(({vertices_vertices:e},t,r)=>{e&&(e[t]=[...r],r.forEach(((r,s,o)=>{const n=o[(s+1)%o.length],a=e[r].indexOf(n);e[r][a]=t})))})(e,c,o),(({vertices_coords:e,vertices_vertices:t,vertices_sectors:r},s)=>{r&&(r[s]=1===t[s].length?[R]:counterClockwiseSectors2(t[s].map((t=>subtract2(e[t],e[s])))))})(e,c),(({vertices_edges:e},t,r,s,o)=>{e&&(e[r]=[...o],s.map((r=>e[r].indexOf(t))).forEach(((t,r)=>{e[s[r]][t]=o[r]})))})(e,t,c,o,i);const l=(({vertices_faces:e,edges_vertices:t,edges_faces:r,faces_edges:s,faces_vertices:o},n)=>{if(r&&r[n])return r[n];const a=t[n];if(void 0!==e){const t=[];for(let r=0;r<e[a[0]].length;r+=1)for(let s=0;s<e[a[1]].length;s+=1)if(e[a[0]][r]===e[a[1]][s]){if(void 0===e[a[0]][r])continue;t.push(e[a[0]][r])}return t}if(s){const e=[];for(let t=0;t<s.length;t+=1)for(let r=0;r<s[t].length;r+=1)s[t][r]===n&&e.push(t);return e}o&&console.warn("todo: findAdjacentFacesToEdge")})(e,t);l&&((({vertices_faces:e},t,r)=>{e&&(e[t]=[...r])})(e,c,l),(({edges_faces:e},t,r)=>{e&&t.forEach((t=>{e[t]=[...r]}))})(e,i,l),(({faces_vertices:e},t,r,s)=>{e&&s.map((t=>e[t])).forEach((e=>e.map(((e,t,s)=>{const o=(t+1)%s.length;return e===r[0]&&s[o]===r[1]||e===r[1]&&s[o]===r[0]?o:void 0})).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((r=>e.splice(r,0,t)))))})(e,c,o,l),(({edges_vertices:e,faces_vertices:t,faces_edges:r},s)=>{const o=makeVerticesToEdgeBidirectional({edges_vertices:e});s.map((e=>t[e].map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>o[e.join(" ")])))).forEach(((e,t)=>{r[s[t]]=e}))})(e,l));const d=removeGeometryIndices(e,n,[t]);return i.forEach(((e,t)=>{i[t]=d[i[t]]})),d.splice(-2),d[t]=i,{vertex:c,edges:{map:d,new:i,remove:t}}},rebuild_edge=(e,t,r)=>{const s=e.edges_vertices.length,o=(({vertices_coords:e},t,r)=>{const s=t.map((t=>e[t])).reverse();return{edges_vertices:[...t],edges_foldAngle:0,edges_assignment:"U",edges_length:distance(...s),edges_vector:subtract(...s),edges_faces:[r,r]}})(e,r,t);return Object.keys(o).filter((t=>void 0!==e[t])).forEach((t=>{e[t][s]=o[t]})),s},build_faces=(e,t,r)=>{const s=[0,1].map((t=>e.faces_vertices.length+t));return(({edges_vertices:e,faces_vertices:t,faces_edges:r},s,o)=>{const n=o.map((e=>t[s].indexOf(e))),a=splitCircularArray(t[s],n).map((e=>({faces_vertices:e})));if(r){const t=makeVerticesToEdgeBidirectional({edges_vertices:e});a.map((e=>e.faces_vertices.map(((e,t,r)=>`${e} ${r[(t+1)%r.length]}`)).map((e=>t[e])))).forEach(((e,t)=>{a[t].faces_edges=e}))}return a})(e,t,r).forEach(((t,r)=>Object.keys(t).forEach((o=>{e[o][s[r]]=t[o]})))),s},splitFace=(e,t,r,s,o)=>{const n=intersectConvexFaceLine(e,t,{vector:r,origin:s},o);if(void 0===n)return;const c=((e,{vertices:t,edges:r})=>{let s;const o=r.map((t=>{const r=splitEdge(e,s?s[t.edge]:t.edge,t.coords);return s=s?mergeNextmaps(s,r.edges.map):r.edges.map,r}));let n;return t.push(...o.map((e=>e.vertex))),o.forEach((e=>{e.edges.remove=n?n[e.edges.remove]:e.edges.remove;const t=invertSimpleMap(e.edges.map);n=n?mergeBackmaps(n,t):t})),{vertices:t,edges:{map:s,remove:o.map((e=>e.edges.remove))}}})(e,n);c.edges.new=rebuild_edge(e,t,c.vertices),(({vertices_coords:e,vertices_vertices:t,edges_vertices:r},s)=>{const o=r[s][0],n=r[s][1];t[o]=sortVerticesCounterClockwise({vertices_coords:e},t[o].concat(n),o),t[n]=sortVerticesCounterClockwise({vertices_coords:e},t[n].concat(o),n)})(e,c.edges.new),(({edges_vertices:e,vertices_edges:t,vertices_vertices:r},s)=>{if(!t||!r)return;const o=e[s];o.map((e=>r[e])).map(((e,t)=>e.indexOf(o[(t+1)%o.length]))).forEach(((e,r)=>t[o[r]].splice(e,0,s)))})(e,c.edges.new);const i=build_faces(e,t,c.vertices);((e,t,r)=>{const s={};r.forEach((t=>e.faces_vertices[t].forEach((e=>{s[e]||(s[e]=[]),s[e].push(t)})))),e.faces_vertices[t].forEach((r=>{const o=e.vertices_faces[r].indexOf(t),n=s[r];if(-1===o||!n)throw new Error(N);e.vertices_faces[r].splice(o,1,...n)}))})(e,t,i),((e,t,r,s)=>{const o={};s.forEach((t=>e.faces_edges[t].forEach((e=>{o[e]||(o[e]=[]),o[e].push(t)})))),[...e.faces_edges[t],r].forEach((r=>{const s=o[r],n=[];for(let s=0;s<e.edges_faces[r].length;s+=1)e.edges_faces[r][s]===t&&n.push(s);if(0===n.length||!s)throw new Error(N);n.reverse().forEach((t=>e.edges_faces[r].splice(t,1)));const a=n[n.length-1];e.edges_faces[r].splice(a,0,...s)}))})(e,t,c.edges.new,i),(({faces_vertices:e,faces_faces:t},r,s)=>{const o=t[r],n=s.map((t=>e[t])),a=o.map((t=>{const r=e[t],o=[0,0];for(let e=0;e<n.length;e+=1){let t=0;for(let s=0;s<r.length;s+=1)-1!==n[e].indexOf(r[s])&&(t+=1);o[e]=t}return o[0]>=2?s[0]:o[1]>=2?s[1]:void 0}));s.forEach(((e,r,o)=>{t[e]=[o[(r+1)%s.length]]})),o.forEach(((e,s)=>{for(let o=0;o<t[e].length;o+=1)t[e][o]===r&&(t[e][o]=a[s],t[a[s]].push(e))}))})(e,t,i);const l=removeGeometryIndices(e,a,[t]);return i.forEach(((e,t)=>{i[t]=l[i[t]]})),l.splice(-2),l[t]=i,c.faces={map:l,new:i,remove:t},c},Ge={};Ge.prototype=Object.create(Object.prototype),Ge.prototype.constructor=Ge;const We={clean:clean,validate:validate,populate:populate,fragment:fragment,addVertices:addVertices,splitEdge:splitEdge,faceSpanningTree:makeFaceSpanningTree,explodeFaces:explodeFaces,explodeShrinkFaces:explodeShrinkFaces,...$e};Object.keys(We).forEach((e=>{Ge.prototype[e]=function(){return We[e](this,...arguments)}})),Ge.prototype.splitFace=function(e,...t){const r=getLine$1(...t);return splitFace(this,e,r.vector,r.origin)},Ge.prototype.copy=function(){return Object.assign(Object.create(Object.getPrototypeOf(this)),clone(this))},Ge.prototype.clear=function(){return ae.graph.forEach((e=>delete this[e])),ae.orders.forEach((e=>delete this[e])),delete this.file_frames,this},Ge.prototype.boundingBox=function(){return boundingBox$1(this.vertices_coords)},Ge.prototype.unitize=function(){if(!this.vertices_coords)return this;const e=boundingBox$1(this.vertices_coords),t=Math.max(...e.span),r=0===t?1:1/t,s=e.min;return this.vertices_coords=this.vertices_coords.map((e=>subtract(e,s))).map((e=>e.map((e=>e*r)))),this},Ge.prototype.folded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFolded(this,...arguments);return Object.assign(Object.create(Object.getPrototypeOf(this)),Object.assign(clone(this),{vertices_coords:e,frame_classes:[_]}))},Ge.prototype.flatFolded=function(){const e=this.faces_matrix2?multiplyVerticesFacesMatrix2(this,this.faces_matrix2):makeVerticesCoordsFlatFolded(this,...arguments);return Object.assign(Object.create(Object.getPrototypeOf(this)),Object.assign(clone(this),{vertices_coords:e,frame_classes:[_]}))};const shortenKeys=function(e){const t=Object.create(null);return Object.keys(e).forEach((r=>{t[r.substring(this.length+1)]=e[r]})),t},getComponent=function(e){return transposeGraphArrays(this,e).map(shortenKeys.bind(e)).map(ne[e].bind(this))};[o,n,a].forEach((e=>Object.defineProperty(Ge.prototype,e,{enumerable:!0,get:function(){return getComponent.call(this,e)}}))),Object.defineProperty(Ge.prototype,u,{enumerable:!0,get:function(){const e=boundary(this),t=e.vertices.map((e=>this.vertices_coords[e]));return Object.keys(e).forEach((r=>{t[r]=e[r]})),Object.assign(t,e)}});const He={vertices:nearestVertex,edges:nearestEdge,faces:nearestFace};Ge.prototype.nearest=function(){const e=getVector(arguments),t=Object.create(null),r={};return[o,n,a].forEach((s=>{Object.defineProperty(t,ie[s],{enumerable:!0,get:()=>(void 0!==r[s]||(r[s]=He[s](this,e)),r[s])}),filterKeysWithPrefix(this,s).forEach((e=>Object.defineProperty(t,e,{enumerable:!0,get:()=>this[e][t[ie[s]]]})))})),t};var Je=Ge.prototype;const linePointFromParameter=(e,t,r)=>add2(t,scale2(e,r)),getIntersectParameters=(e,t,r,s,o)=>e.map(((e,t,r)=>[subtract2(r[(t+1)%r.length],e),e])).map((e=>((e,t,r,s,o=includeS,n=L)=>{const a=cross2(normalize2(e),normalize2(r));if(Math.abs(a)<n)return;const c=cross2(e,r),i=-c,l=subtract2(s,t),d=flip(l),m=cross2(l,r)/c;return o(cross2(d,e)/i,n/magnitude2(r))?m:void 0})(t,r,e[0],e[1],s,o))).filter(fnNotUndefined).sort(((e,t)=>e-t)),clipLineConvexPolygon=(e,{vector:t,origin:r},s=include,o=D,n=L)=>{const a=getIntersectParameters(e,t,r,includeS,n);if(a.length<2)return;const c=((e,t,r)=>{let s=0,o=e.length-1;for(;s<o&&!t(e[s+1]-e[s],r);)s+=1;for(;o>s&&!t(e[o]-e[o-1],r);)o-=1;if(!(s>=o))return[e[s],e[o]]})(a,s,2*n/magnitude2(t));if(void 0===c)return;const i=c.map((e=>o(e)?e:e<.5?0:1));if(Math.abs(i[0]-i[1])<2*n/magnitude2(t))return;const l=linePointFromParameter(t,r,(i[0]+i[1])/2);return overlapConvexPolygonPoint(e,l,s,n)?i.map((e=>linePointFromParameter(t,r,e))):void 0},clipPolygonPolygon=(e,t,r=L)=>{const inside=(e,t,s)=>(s[0]-t[0])*(e[1]-t[1])>(s[1]-t[1])*(e[0]-t[0])+r,intersection=(e,t,r,s)=>{const o=subtract2(e,t),n=subtract2(s,r),a=cross2(e,t),c=cross2(s,r),i=1/cross2(o,n);return scale2(subtract2(scale2(n,a),scale2(o,c)),i)};let s=e,o=t[t.length-1];for(let e=0;e<t.length;e+=1){const r=t[e],n=s;s=[];let a=n[n.length-1];for(let e=0;e<n.length;e+=1){const t=n[e];inside(t,o,r)?(inside(a,o,r)||s.push(intersection(o,r,t,a)),s.push(t)):inside(a,o,r)&&s.push(intersection(o,r,t,a)),a=t}o=r}return 0===s.length?void 0:s};var Ze=Object.freeze({__proto__:null,clipLineConvexPolygon:clipLineConvexPolygon,clipPolygonPolygon:clipPolygonPolygon});const clip=function(e,t){const r=boundary(e).vertices.map((t=>e.vertices_coords[t])),s=t.vector?t.vector:subtract2(t[1],t[0]),o=t.origin?t.origin:t[0],n=t.domain_function?t.domain_function:D;return clipLineConvexPolygon(r,{vector:s,origin:o},include,n)},addEdges=(e,t)=>{e.edges_vertices||(e.edges_vertices=[]),"number"==typeof t[0]&&(t=[t]);const r=t.map(((t,r)=>e.edges_vertices.length+r));e.edges_vertices.push(...t);const s=removeDuplicateEdges(e).map;return r.map((e=>s[e]))},addPlanarSegment=(e,t,r,s=L)=>{e.vertices_sectors||(e.vertices_sectors=makeVerticesSectors(e));const o=[t,r].map((e=>[e[0],e[1]])),n=subtract2(o[1],o[0]),a=makeEdgesSegmentIntersection(e,o[0],o[1],s),c=a.map(((e,t)=>void 0===e?void 0:t)).filter((e=>void 0!==e)).sort(((e,t)=>e-t)),i={};c.forEach((t=>e.edges_faces[t].forEach((e=>{i[e]=!0}))));const l=Object.keys(i).map((e=>parseInt(e,10))).sort(((e,t)=>e-t)),d=c.reverse().map((t=>splitEdge(e,t,a[t],s))).map((e=>e.vertex)),m=addVertices(e,o,s),p={};d.forEach((e=>{p[e]=!0})),m.forEach((e=>{p[e]=!0}));const g=Object.keys(p).map((e=>parseInt(e,10))),u=sortVerticesAlongVector(e,g,n),v=makeVerticesToEdgeBidirectional(e),h=((e,t,r)=>{const s=Array.from(Array(t.length-1)).map(((e,r)=>[t[r],t[r+1]])),o=s.map((e=>e.join(" "))).map((e=>void 0===r[e])),n=s.filter(((e,t)=>o[t])),a=Array.from(Array(n.length)).map(((t,r)=>e.edges_vertices.length+r));a.forEach(((t,r)=>{e.edges_vertices[t]=n[r]})),e.edges_assignment&&a.forEach((t=>{e.edges_assignment[t]="U"})),e.edges_foldAngle&&a.forEach((t=>{e.edges_foldAngle[t]=0}));for(let r=0;r<t.length;r+=1){const s=t[r],n=[o[r-1]?t[r-1]:void 0,o[r]?t[r+1]:void 0].filter((e=>void 0!==e)),a=(e.vertices_vertices[s]?e.vertices_vertices[s]:[]).concat(n);e.vertices_vertices[s]=sortVerticesCounterClockwise(e,a,t[r])}const c=makeVerticesToEdgeBidirectional(e);for(let r=0;r<t.length;r+=1){const s=t[r];e.vertices_edges[s]=e.vertices_vertices[s].map((e=>c[`${s} ${e}`]))}return t.map((t=>1===e.vertices_vertices[t].length?[R]:counterClockwiseSectors2(e.vertices_vertices[t].map((r=>subtract2(e.vertices_coords[r],e.vertices_coords[t])))))).forEach(((r,s)=>{e.vertices_sectors[t[s]]=r})),a})(e,u,v);h.forEach((t=>{const r=e.edges_vertices[t];v[`${r[0]} ${r[1]}`]=t,v[`${r[1]} ${r[0]}`]=t}));const _=u.map((t=>e.vertices_vertices[t].map((e=>[[e,t],[t,e]])))).reduce(((e,t)=>e.concat(t)),[]).reduce(((e,t)=>e.concat(t)),[]),b={},y=_.map((t=>counterClockwiseWalk(e,t[0],t[1],b))).filter((e=>void 0!==e)),E=filterWalkedBoundaryFace(y);removeGeometryIndices(e,"faces",l);const A=E.map(((t,r)=>e.faces_vertices.length+r));return e.faces_vertices&&A.forEach(((t,r)=>{e.faces_vertices[t]=E[r].vertices})),e.faces_edges&&A.forEach(((t,r)=>{e.faces_edges[t]=E[r].edges.map((e=>v[e]))})),e.faces_angles&&A.forEach(((t,r)=>{e.faces_angles[t]=E[r].faces_angles})),e.vertices_faces&&(e.vertices_faces=makeVerticesFaces(e)),e.edges_faces&&(e.edges_faces=makeEdgesFacesUnsorted(e)),e.faces_faces&&(e.faces_faces=makeFacesFaces(e)),e.vertices_coords.length===e.vertices_vertices.length&&e.vertices_coords.length===e.vertices_edges.length&&e.vertices_coords.length===e.vertices_faces.length||console.warn("vertices mismatch",JSON.parse(JSON.stringify(e))),e.edges_vertices.length===e.edges_faces.length&&e.edges_vertices.length===e.edges_assignment.length||console.warn("edges mismatch",JSON.parse(JSON.stringify(e))),e.faces_vertices.length===e.faces_edges.length&&e.faces_vertices.length===e.faces_faces.length||console.warn("faces mismatch",JSON.parse(JSON.stringify(e))),h},removePlanarEdge=(e,t)=>{const r=[...e.edges_vertices[t]].sort(((e,t)=>t-e)),s=[...e.edges_faces[t]];(({vertices_vertices:e},t)=>{const r=[t[1],t[0]];t.map(((t,s)=>e[t].indexOf(r[s]))).forEach(((r,s)=>e[t[s]].splice(r,1)))})(e,r),(({vertices_edges:e},t,r)=>{r.map(((r,s)=>e[r].indexOf(t))).forEach(((t,s)=>e[r[s]].splice(t,1)))})(e,t,r);const o=r.map((t=>0===e.vertices_vertices[t].length)),n=r.filter(((e,t)=>o[t]));if(2===s.length&&s[0]!==s[1]){const o=e.faces_vertices.length,n=((e,t,r,s)=>{const o=t.map((t=>e.faces_edges[t].indexOf(r))),n=[];t.forEach(((t,r)=>e.faces_vertices[t].forEach(((e,t,o)=>{const a=o[(t+1)%o.length];(e===s[0]&&a===s[1]||e===s[1]&&a===s[0])&&(n[r]=t)})))),void 0!==n[0]&&void 0!==n[1]||console.warn("removePlanarEdge error joining faces");const a=t.map((t=>e.faces_edges[t].length)),c=t.map((t=>e.faces_vertices[t].length)),i=a.map((e=>e-1)),l=c.map((e=>e-1)),d=o.map(((e,t)=>(e+1)%a[t])),m=n.map(((e,t)=>(e+1)%c[t])),p=t.map(((t,r)=>Array.from(Array(i[r])).map(((e,t)=>(d[r]+t)%a[r])).map((r=>e.faces_edges[t][r])))),g=t.map(((t,r)=>Array.from(Array(l[r])).map(((e,t)=>(m[r]+t)%c[r])).map((r=>e.faces_vertices[t][r])))),u=t.map((t=>e.faces_faces[t])).reduce(((e,t)=>e.concat(t)),[]).filter((e=>e!==t[0]&&e!==t[1]));return{vertices:g[0].concat(g[1]),edges:p[0].concat(p[1]),faces:u}})(e,s,t,r);e.faces_vertices.push(n.vertices),e.faces_edges.push(n.edges),e.faces_faces.push(n.faces),e.vertices_faces.forEach(((t,r)=>{let n=!1;t.forEach(((a,c)=>{if(a===s[0]||a===s[1]){e.vertices_faces[r][c]=o;const s=n?[r,1]:[r,1,o];t.splice(...s),n=!0}}))})),e.edges_faces.forEach(((t,r)=>t.forEach(((t,n)=>{t!==s[0]&&t!==s[1]||(e.edges_faces[r][n]=o)})))),e.faces_faces.forEach(((t,r)=>t.forEach(((t,n)=>{t!==s[0]&&t!==s[1]||(e.faces_faces[r][n]=o)})))),e.faces_vertices.forEach((t=>t.forEach((t=>{void 0===t&&console.log("FOUND ONE before remove",e.faces_vertices)})))),removeGeometryIndices(e,"faces",s)}if(2===s.length&&s[0]===s[1]&&n.length){const r=s[0];e.faces_vertices[r]=e.faces_vertices[r].filter((e=>!n.includes(e))).filter(((e,t,r)=>e!==r[(t+1)%r.length])),e.faces_edges[r]=e.faces_edges[r].filter((e=>e!==t))}removeGeometryIndices(e,"edges",[t]),removeGeometryIndices(e,"vertices",n)},removePlanarVertex=(e,t)=>{const r=e.vertices_edges[t],s=uniqueSortedNumbers(e.vertices_faces[t].filter((e=>null!=e)));if(2!==r.length||s.length>2)return void console.warn("cannot remove non 2-degree vertex yet (e,f)",r,s);const o=getOppositeVertices(e,t,r),n=o.slice().reverse();r.sort(((e,t)=>e-t)),o.forEach((t=>{const s=e.vertices_edges[t].indexOf(r[1]);-1!==s&&(e.vertices_edges[t][s]=r[0])})),o.forEach(((r,s)=>{const o=e.vertices_vertices[r].indexOf(t);-1!==o?e.vertices_vertices[r][o]=n[s]:console.warn("removePlanarVertex unknown vertex issue")})),e.edges_vertices[r[0]]=[...o],s.forEach((r=>{const s=e.faces_vertices[r].indexOf(t);-1!==s?e.faces_vertices[r].splice(s,1):console.warn("removePlanarVertex unknown face_vertex issue")})),s.forEach((t=>{const s=e.faces_edges[t].indexOf(r[1]);-1!==s?e.faces_edges[t].splice(s,1):console.warn("removePlanarVertex unknown face_edge issue")})),removeGeometryIndices(e,"vertices",[t]),removeGeometryIndices(e,"edges",[r[1]])},alternatingSum=e=>[0,1].map((t=>e.filter(((e,r)=>r%2===t)).reduce(((e,t)=>e+t),0))),kawasakiSolutionsRadians=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>counterClockwiseAngleRadians(...e))).map(((e,t,r)=>r.slice(t+1,r.length).concat(r.slice(0,t)))).map((e=>alternatingSum(e).map((e=>Math.PI-e)))).map(((t,r)=>e[r]+t[0])).map(((t,r)=>isCounterClockwiseBetween(t,e[r],e[(r+1)%e.length])?t:void 0)),kawasakiSolutionsVectors=e=>{const t=e.map((e=>Math.atan2(e[1],e[0])));return kawasakiSolutionsRadians(t).map((e=>void 0===e?void 0:[Math.cos(e),Math.sin(e)]))};var Ye=Object.freeze({__proto__:null,alternatingSum:alternatingSum,alternatingSumDifference:e=>{const t=e.reduce(((e,t)=>e+t),0)/2;return alternatingSum(e).map((e=>e-t))},kawasakiSolutionsRadians:kawasakiSolutionsRadians,kawasakiSolutionsVectors:kawasakiSolutionsVectors});const Xe={B:!0,b:!0,F:!0,f:!0,U:!0,u:!0},vertices_flat=({vertices_edges:e,edges_assignment:t})=>e.map((e=>e.map((e=>Xe[t[e]])).reduce(((e,t)=>e&&t),!0))).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),Ke={M:!0,m:!0,V:!0,v:!0},Qe={M:-1,m:-1,V:1,v:1},validateMaekawa=({edges_vertices:e,vertices_edges:t,edges_assignment:r})=>{t||(t=makeVerticesEdgesUnsorted({edges_vertices:e}));const s=t.map((e=>e.map((e=>Qe[r[e]])).filter((e=>void 0!==e)).reduce(((e,t)=>e+t),0))).map((e=>2===e||-2===e));return boundaryVertices({edges_vertices:e,edges_assignment:r}).forEach((e=>{s[e]=!0})),vertices_flat({vertices_edges:t,edges_assignment:r}).forEach((e=>{s[e]=!0})),s.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))},validateKawasaki=({vertices_coords:e,vertices_vertices:t,vertices_edges:r,edges_vertices:s,edges_assignment:o,edges_vector:n},a=L)=>{t||(t=makeVerticesVertices({vertices_coords:e,vertices_edges:r,edges_vertices:s}));const c=makeVerticesVerticesVector({vertices_coords:e,vertices_vertices:t,edges_vertices:s,edges_vector:n}).map(((e,t)=>e.filter(((e,s)=>Ke[o[r[t][s]]])))).map((e=>e.length>1?counterClockwiseSectors2(e):[0,0])).map((e=>alternatingSum(e))).map((e=>Math.abs(e[0]-e[1])<a));return boundaryVertices({edges_vertices:s,edges_assignment:o}).forEach((e=>{c[e]=!0})),vertices_flat({vertices_edges:r,edges_assignment:o}).forEach((e=>{c[e]=!0})),c.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))};var et=Object.freeze({__proto__:null,validateMaekawa:validateMaekawa,validateKawasaki:validateKawasaki});const tt={};tt.prototype=Object.create(Je),tt.prototype.constructor=tt;const make_edges_array=function(e){return e.mountain=(t=-180)=>(e.forEach((e=>{this.edges_assignment[e]="M",this.edges_foldAngle[e]=t})),e),e.valley=(t=180)=>(e.forEach((e=>{this.edges_assignment[e]="V",this.edges_foldAngle[e]=t})),e),e.flat=()=>(e.forEach((e=>{this.edges_assignment[e]="F",this.edges_foldAngle[e]=0})),e),e},clipLineTypeToCP=(e,t)=>{const r=clip(e,t);if(!r)return;const s=addPlanarSegment(e,r[0],r[1]);return make_edges_array.call(e,s)};tt.prototype.line=function(...e){const t=getLine$1(...e);if(t)return t.domain_function=D,clipLineTypeToCP(this,t)},tt.prototype.ray=function(...e){const t=getLine$1(...e);if(t)return t.domain_function=G,clipLineTypeToCP(this,t)},tt.prototype.segment=function(...e){const t=getVectorOfVectors(...e);if(t)return t.domain_function=includeS,clipLineTypeToCP(this,t)},["circle","ellipse","rect","polygon"].forEach((e=>{tt.prototype[e]=function(){const t=math[e](...arguments);if(!t)return;const r=t.segments(96).map((e=>math.segment(e))).map((e=>clip(this,e))).filter((e=>void 0!==e));if(!r)return;const s=[],o=[];r.forEach((e=>{const t=addVertices(this,e);s.push(...t),o.push(...addEdges(this,t))}));const{map:n}=fragment(this).edges;return populate(this),make_edges_array.call(this,o.map((e=>n[e])).reduce(((e,t)=>e.concat(t)),[]))}})),tt.prototype.removeEdge=function(e){const t=this.edges_vertices[e];return removePlanarEdge(this,e),t.map((e=>isVertexCollinear(this,e))).map(((e,r)=>e?t[r]:void 0)).filter((e=>void 0!==e)).sort(((e,t)=>t-e)).forEach((e=>removePlanarVertex(this,e))),!0},tt.prototype.validate=function(e){const t=validate(this,e);return t.vertices.kawasaki=validateKawasaki(this,e),t.vertices.maekawa=validateMaekawa(this),this.edges_foldAngle&&(t.edges.not_flat=this.edges_foldAngle.map(((e,t)=>edgeFoldAngleIsFlat(e)?void 0:t)).filter((e=>void 0!==e))),"valid"===t.summary&&(t.vertices.kawasaki.length||t.vertices.maekawa.length?t.summary="invalid":t.edges.not_flat.length&&(t.summary="not flat")),t};var rt=tt.prototype;const make_face_side=(e,t,r,s)=>{const o=subtract2(r,t),n=cross2(e,o);return s?n>0:n<0},make_face_center=(e,t)=>e.faces_vertices[t]?e.faces_vertices[t].map((t=>e.vertices_coords[t])).reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]]),[0,0]).map((r=>r/e.faces_vertices[t].length)):[0,0],st={F:!0,f:!0,U:!0,u:!0},ot={M:"V",m:"V",V:"M",v:"M"},face_snapshot=(e,t)=>({center:e.faces_center[t],matrix:e.faces_matrix2[t],winding:e.faces_winding[t],crease:e.faces_crease[t],side:e.faces_side[t],layer:e.faces_layer[t]}),flatFold=(e,t,r,s="V",o=L)=>{const n=ot[a=s]||a;var a;populate(e),e.faces_layer||(e.faces_layer=Array(e.faces_vertices.length).fill(0)),e.faces_center=e.faces_vertices.map(((t,r)=>make_face_center(e,r))),e.faces_matrix2||(e.faces_matrix2=makeFacesMatrix2(e,0)),e.faces_winding=makeFacesWindingFromMatrix2(e.faces_matrix2),e.faces_crease=e.faces_matrix2.map(invertMatrix2).map((e=>multiplyMatrix2Line2(e,t,r))),e.faces_side=e.faces_vertices.map(((t,r)=>make_face_side(e.faces_crease[r].vector,e.faces_crease[r].origin,e.faces_center[r],e.faces_winding[r])));const c=multiplyVerticesFacesMatrix2(e,e.faces_matrix2),i=makeEdgesLineParallelOverlap({vertices_coords:c,edges_vertices:e.edges_vertices},t,r,o).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).filter((t=>st[e.edges_assignment[t]]));i.map((t=>e.edges_faces[t].find((e=>null!=e)))).map((t=>e.faces_winding[t])).map((e=>e?s:n)).forEach(((t,r)=>{e.edges_assignment[i[r]]=t,e.edges_foldAngle[i[r]]=edgeAssignmentToFoldAngle(t)}));const l=face_snapshot(e,0),d=e.faces_vertices.map(((e,t)=>t)).reverse().map((t=>{const r=face_snapshot(e,t),a=splitFace(e,t,r.crease.vector,r.crease.origin,o);if(void 0===a)return;e.edges_assignment[a.edges.new]=r.winding?s:n,e.edges_foldAngle[a.edges.new]=edgeAssignmentToFoldAngle(e.edges_assignment[a.edges.new]);return a.faces.map[a.faces.remove].forEach((t=>{e.faces_center[t]=make_face_center(e,t),e.faces_side[t]=make_face_side(r.crease.vector,r.crease.origin,e.faces_center[t],r.winding),e.faces_layer[t]=r.layer})),a})).filter((e=>void 0!==e)),m=mergeNextmaps(...d.map((e=>e.faces.map))),p=mergeNextmaps(...d.map((e=>e.edges.map)).filter((e=>void 0!==e))),g=d.map((e=>e.faces.remove)).reverse();e.faces_layer=((e,t)=>{const r=[],s=e.map(((e,t)=>t)),o=s.filter((e=>t[e])),n=s.filter((e=>!t[e]));return n.sort(((t,r)=>e[t]-e[r])).forEach(((e,t)=>{r[e]=t})),o.sort(((t,r)=>e[r]-e[t])).forEach(((e,t)=>{r[e]=n.length+t})),r})(e.faces_layer,e.faces_side);const u=m&&m[0]&&2===m[0].length,v=u?m[0].filter((t=>e.faces_side[t])).shift():0;let h=l.matrix;return s!==n&&(h=u||e.faces_side[0]?multiplyMatrices2(l.matrix,makeMatrix2Reflect(l.crease.vector,l.crease.origin)):l.matrix),e.faces_matrix2=makeFacesMatrix2(e,v).map((e=>multiplyMatrices2(h,e))),delete e.faces_center,delete e.faces_winding,delete e.faces_crease,delete e.faces_side,{faces:{map:m,remove:g},edges:{map:p}}},nt={};nt.prototype=Object.create(Je),nt.prototype.constructor=nt,nt.prototype.flatFold=function(){const e=getLine$1(arguments);return flatFold(this,e.vector,e.origin),this};var at=nt.prototype;const isFoldedForm=e=>e.frame_classes&&e.frame_classes.includes("foldedForm")||e.file_classes&&e.file_classes.includes("foldedForm");var ct=Object.freeze({__proto__:null,isFoldedForm:isFoldedForm});const selfRelationalArraySubset=(e,t)=>{const r={};t.forEach((e=>{r[e]=!0}));const s=[];return t.forEach((t=>{s[t]=e[t].filter((e=>r[e]))})),s},subgraph=(e,t)=>{const r=["faces","edges","vertices"],s={};r.forEach((e=>{s[e]={}})),r.forEach((e=>t[e].forEach((t=>{s[e][t]=!0}))));const o={};r.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{o[e]={}})),filterKeysWithSuffix(e,t).forEach((e=>{o[e]={}}))})),r.forEach((t=>{filterKeysWithPrefix(e,t).forEach((e=>{o[e].prefix=t})),filterKeysWithSuffix(e,t).forEach((e=>{o[e].suffix=t}))}));const n={...e};return ae.graph.forEach((e=>delete n[e])),delete n.file_frames,Object.keys(o).forEach((e=>{n[e]=[]})),Object.keys(o).forEach((r=>{const{prefix:a,suffix:c}=o[r];a&&c?t[a].forEach((t=>{n[r][t]=e[r][t].filter((e=>s[c][e]))})):a?t[a].forEach((t=>{n[r][t]=e[r][t]})):n[r]=c?e[r].map((e=>e.filter((e=>s[c][e])))):e[r]})),n},subgraphWithFaces=(e,t)=>{let r=[];e.faces_vertices&&(r=uniqueSortedNumbers(t.flatMap((t=>e.faces_vertices[t]))));let s=[];if(e.faces_edges)s=uniqueSortedNumbers(t.flatMap((t=>e.faces_edges[t])));else if(e.edges_vertices){const t={};r.forEach((e=>{t[e]=!0})),s=e.edges_vertices.map(((e,r)=>t[e[0]]&&t[e[1]]?r:void 0)).filter((e=>void 0!==e))}return subgraph(e,{faces:t,edges:s,vertices:r})};var it=Object.freeze({__proto__:null,selfRelationalArraySubset:selfRelationalArraySubset,subgraph:subgraph,subgraphWithFaces:subgraphWithFaces});const makeEdgesFacesOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r,edges_faces:s,faces_vertices:o},n)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const a=makeFacesWinding({vertices_coords:e,faces_vertices:o}),c=t.map((t=>e[t[0]])),i=t.map((t=>t.map((t=>e[t])))),l=o.map((t=>t.map((t=>e[t]))));a.forEach(((e,t)=>{e||l[t].reverse()}));const d=t.map((()=>o.map((()=>{}))));s.forEach(((e,t)=>e.forEach((e=>{d[t][e]=!1}))));const m=makeEdgesBoundingBox({edges_coords:i}),p=l.map((e=>boundingBox$1(e)));return m.forEach(((e,t)=>p.forEach(((r,s)=>{!1!==d[t][s]&&(overlapBoundingBoxes(r,e)||(d[t][s]=!1))})))),i.forEach(((e,t)=>l.forEach(((e,s)=>{if(void 0!==d[t][s])return;if(i[t].map((e=>overlapConvexPolygonPoint(l[s],e,exclude,n))).reduce(((e,t)=>e||t),!1))return void(d[t][s]=!0);intersectConvexPolygonLine(l[s],{vector:r[t],origin:c[t]},excludeS,excludeS,n)?d[t][s]=!0:d[t][s]=!1})))),d},getFacesFaces2DOverlap=({vertices_coords:e,faces_vertices:t},r=L)=>{const s=Array.from(Array(t.length)).map((()=>Array.from(Array(t.length)))),o=t.map((t=>t.map((t=>e[t])))),n=o.map((e=>boundingBox$1(e)));for(let e=0;e<n.length-1;e+=1)for(let t=e+1;t<n.length;t+=1)overlapBoundingBoxes(n[e],n[t])||(s[e][t]=!1,s[t][e]=!1);const a=o.map((e=>makePolygonNonCollinear(e,r)));for(let e=0;e<t.length-1;e+=1)for(let o=e+1;o<t.length;o+=1){if(!1===s[e][o])continue;const t=overlapConvexPolygons(a[e],a[o],r);s[e][o]=t,s[o][e]=t}return s};var lt=Object.freeze({__proto__:null,makeEdgesFacesOverlap:makeEdgesFacesOverlap,getFacesFaces2DOverlap:getFacesFaces2DOverlap});const triangulateConvexFacesVertices=({faces_vertices:e})=>e.flatMap((e=>{return e.length<4?[e]:(t=e,Array.from(Array(t.length-2)).map(((e,r)=>[t[0],t[r+1],t[r+2]])));var t})),triangulateNonConvexFacesVertices=({vertices_coords:e,faces_vertices:t},r)=>{if(!e||!e.length)throw new Error($);const s=e[0].length;return t.map((t=>t.flatMap((t=>e[t])))).map((e=>r(e,null,s))).map(((e,r)=>e.map((e=>t[r][e])))).flatMap((e=>{return 3===(t=e).length?[t]:Array.from(Array(Math.floor(t.length/3))).map(((e,r)=>[3*r+0,3*r+1,3*r+2].map((e=>t[e]))));var t}))},triangulate=(e,t)=>{if(!e.faces_vertices)return{};const r=e.edges_vertices?e.edges_vertices.length:0,s=(({faces_vertices:e})=>{let t=0;return e.map((e=>Math.max(3,e.length))).map((e=>Array.from(Array(e-2)).map((()=>t++))))})(e);e.faces_vertices=t?triangulateNonConvexFacesVertices(e,t):triangulateConvexFacesVertices(e),(e=>{e.edges_vertices||(e.edges_vertices=[]);const t=makeVerticesToEdgeBidirectional(e);let r=e.edges_vertices.length;const s=[];e.faces_edges=e.faces_vertices.map((e=>e.map(((e,o,n)=>{const a=[e,n[(o+1)%n.length]],c=a.join(" ");return c in t?t[c]:(s.push(a),t[c]=r,t[a.reverse().join(" ")]=r,r++)}))));const o=s.length;e.edges_vertices.push(...s),e.edges_assignment&&e.edges_assignment.push(...Array(o).fill("J")),e.edges_foldAngle&&e.edges_foldAngle.push(...Array(o).fill(0)),e.vertices_vertices&&delete e.vertices_vertices,e.vertices_edges&&delete e.vertices_edges,e.vertices_faces&&delete e.vertices_faces,e.edges_faces&&delete e.edges_faces,e.faces_faces&&delete e.faces_faces,e.faceOrders&&delete e.faceOrders})(e);return{faces:{map:s},edges:{new:Array.from(Array(e.edges_vertices.length-r)).map(((e,t)=>r+t))}}};var ft=Object.freeze({__proto__:null,triangulateConvexFacesVertices:triangulateConvexFacesVertices,triangulateNonConvexFacesVertices:triangulateNonConvexFacesVertices,triangulate:triangulate});const connectedComponents=e=>{const t=[],recurse=(r,s)=>void 0!==t[r]?0:(t[r]=s,e[r].forEach((e=>recurse(e,s))),1);for(let t=0,r=0;t<e.length;t+=1)t in e&&(r+=recurse(t,r));return t},makeEdgesEdgesParallel=({vertices_coords:e,edges_vertices:t,edges_vector:r},s=L)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>normalize(e)));return o.map(((e,t)=>o.map(((e,r)=>t===r?void 0:1-Math.abs(dot(o[t],o[r]))<s)).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e))))},overwriteEdgesOverlaps=(e,t,r,s,o)=>{const n=e.map((()=>[]));return e.forEach(((e,a)=>e.forEach((e=>{a>=e||overlapLineLine({vector:t[a],origin:r[a]},{vector:t[e],origin:r[e]},s,s,o)&&(n[a].push(e),n[e].push(a))})))),n},makeEdgesEdgesParallelOverlap=({vertices_coords:e,edges_vertices:t,edges_vector:r},s)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=t.map((t=>e[t[0]])),n=makeEdgesEdgesParallel({vertices_coords:e,edges_vertices:t,edges_vector:r},s);return overwriteEdgesOverlaps(n,r,o,excludeS,s)};var dt=Object.freeze({__proto__:null,makeEdgesEdgesSimilar:({vertices_coords:e,edges_vertices:t,edges_coords:r},s=L)=>{r||(r=makeEdgesCoords({vertices_coords:e,edges_vertices:t}));const o=makeEdgesBoundingBox({vertices_coords:e,edges_vertices:t,edges_coords:r}),n=Array.from(Array(r.length)).map((()=>[])),a=o.length?o[0].min.length:0;for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){let r=!0;for(let n=0;n<a;n+=1)fnEpsilonEqual(o[e].min[n],o[t].min[n],s)&&fnEpsilonEqual(o[e].max[n],o[t].max[n],s)||(r=!1);n[e][t]=r,n[t][e]=r}for(let e=0;e<r.length-1;e+=1)for(let t=e+1;t<r.length;t+=1){if(!n[e][t])continue;const o=fnEpsilonEqualVectors(r[e][0],r[t][0],s)&&fnEpsilonEqualVectors(r[e][1],r[t][1],s),a=fnEpsilonEqualVectors(r[e][0],r[t][1],s)&&fnEpsilonEqualVectors(r[e][1],r[t][0],s),c=o||a;n[e][t]=c,n[t][e]=c}return booleanMatrixToIndexedArray(n)},makeEdgesEdgesParallel:makeEdgesEdgesParallel,makeEdgesEdges2DParallel:({vertices_coords:e,edges_vertices:t,edges_vector:r},s=L)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>Math.atan2(e[1],e[0]))).map(((e,t)=>({a:e,i:t}))).sort(((e,t)=>e.a-t.a));o.forEach(((e,t)=>{}));const n=o.slice(-1).concat(o.slice(0,-1)).filter((e=>e));console.log("shifted",n)},makeEdgesEdgesCrossing:({vertices_coords:e,edges_vertices:t,edges_vector:r},s)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=t.map((t=>e[t[0]])),n=(({vertices_coords:e,edges_vertices:t,edges_vector:r},s=L)=>{r||(r=makeEdgesVector({vertices_coords:e,edges_vertices:t}));const o=r.map((e=>normalize(e)));return o.map(((e,t)=>o.map(((e,r)=>t===r?void 0:1-Math.abs(dot(o[t],o[r]))<s)).map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e))))})({vertices_coords:e,edges_vertices:t,edges_vector:r},s);return overwriteEdgesOverlaps(n,r,o,excludeS,s)},makeEdgesEdgesParallelOverlap:makeEdgesEdgesParallelOverlap});var mt=Object.assign(Object.create(null),{count:count,countImplied:countImplied,validate:validate,clean:clean,populate:populate,remove:removeGeometryIndices,replace:replaceGeometryIndices,removePlanarVertex:removePlanarVertex,removePlanarEdge:removePlanarEdge,addVertices:addVertices,addEdges:addEdges,splitEdge:splitEdge,splitFace:splitFace,flatFold:flatFold,addPlanarSegment:addPlanarSegment,clip:clip,fragment:fragment,verticesClusters:verticesClusters,connectedComponents:connectedComponents,clone:clone,flattenFrame:(e,t=1)=>{if(!e.file_frames||e.file_frames.length<t)return e;const r=["frame_parent","frame_inherit"],s={visited_frames:[]},o={};filterKeysWithPrefix(e,"file_").filter((e=>"file_frames"!==e)).forEach((t=>{o[t]=e[t]}));const recurse=(e,t,r)=>{if(-1!==s.visited_frames.indexOf(t))throw new Error(M);return s.visited_frames.push(t),r=[t].concat(r),0===t?r:e.file_frames[t-1].frame_inherit&&null!=e.file_frames[t-1].frame_parent?recurse(e,e.file_frames[t-1].frame_parent,r):r};return recurse(e,t,[]).map((t=>{if(0===t){const t=e.file_frames;e.file_frames=null;const s=clone(e);return e.file_frames=t,delete s.file_frames,r.forEach((e=>delete s[e])),s}const s=clone(e.file_frames[t-1]);return r.forEach((e=>delete s[e])),s})).reduce(((e,t)=>Object.assign(e,t)),o)}},ce,pe,xe,ze,_e,qe,Ee,Fe,Me,ct,it,Se,lt,ft,Ae,$e,ue,Oe,Pe,dt,Be,Ve,Ie,Re,Ue,ge);const pt=1.1,gt="Rabbit Ear",ut={},make_rect_vertices_coords=(e,t)=>[[0,0],[e,0],[e,t],[0,t]],make_closed_polygon=e=>populate({vertices_coords:e,edges_vertices:e.map(((e,t,r)=>[t,(t+1)%r.length])),edges_assignment:Array(e.length).fill("B")});ut.square=(e=1)=>make_closed_polygon(make_rect_vertices_coords(e,e)),ut.rectangle=(e=1,t=1)=>make_closed_polygon(make_rect_vertices_coords(e,t)),ut.polygon=(e=3,t=1)=>make_closed_polygon(makePolygonCircumradius(e,t)),ut.kite=()=>populate({vertices_coords:[[0,0],[1,0],[1,Math.sqrt(2)-1],[1,1],[Math.sqrt(2)-1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[0,2],[0,4],[0,3]],edges_assignment:Array.from("BBBBBBVVF")});const vt=Object.create(null),ht={graph:Je,cp:rt,origami:at},_t={graph:()=>{},cp:ut.square,origami:ut.square},bt={graph:()=>({file_spec:pt,file_creator:gt}),cp:()=>({file_spec:pt,file_creator:gt,frame_classes:["creasePattern"]}),origami:()=>({file_spec:pt,file_creator:gt,frame_classes:["foldedForm"]})};Object.keys(ht).forEach((e=>{vt[e]=function(){const t=Array.from(arguments).filter((e=>isFoldObject(e))).map((e=>JSON.parse(JSON.stringify(e))));return populate(Object.assign(Object.create(ht[e]),t.length?{}:_t[e](),...t,bt[e]()))},vt[e].prototype=ht[e],vt[e].prototype.constructor=vt[e],Object.keys(ut).forEach((t=>{vt[e][t]=function(){return vt[e](ut[t](...arguments))}}))})),Object.assign(vt.graph,mt);const countPlaces=function(e){const t=`${e}`.match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return t?Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0)):0};const yt={...U,...H,...se,...te,...Object.freeze({__proto__:null,cleanNumber:function(e,t=15){if("number"!=typeof e)return e;const r=parseFloat(e.toFixed(t));return countPlaces(r)===Math.min(t,countPlaces(e))?e:r}}),...be,...ye},Et=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),multiplyMatrix4Vector3=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]],multiplyMatrices4=(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3],e[0]*t[4]+e[4]*t[5]+e[8]*t[6]+e[12]*t[7],e[1]*t[4]+e[5]*t[5]+e[9]*t[6]+e[13]*t[7],e[2]*t[4]+e[6]*t[5]+e[10]*t[6]+e[14]*t[7],e[3]*t[4]+e[7]*t[5]+e[11]*t[6]+e[15]*t[7],e[0]*t[8]+e[4]*t[9]+e[8]*t[10]+e[12]*t[11],e[1]*t[8]+e[5]*t[9]+e[9]*t[10]+e[13]*t[11],e[2]*t[8]+e[6]*t[9]+e[10]*t[10]+e[14]*t[11],e[3]*t[8]+e[7]*t[9]+e[11]*t[10]+e[15]*t[11],e[0]*t[12]+e[4]*t[13]+e[8]*t[14]+e[12]*t[15],e[1]*t[12]+e[5]*t[13]+e[9]*t[14]+e[13]*t[15],e[2]*t[12]+e[6]*t[13]+e[10]*t[14]+e[14]*t[15],e[3]*t[12]+e[7]*t[13]+e[11]*t[14]+e[15]*t[15]],determinant4=e=>{const t=e[10]*e[15]-e[11]*e[14],r=e[9]*e[15]-e[11]*e[13],s=e[9]*e[14]-e[10]*e[13],o=e[8]*e[15]-e[11]*e[12],n=e[8]*e[14]-e[10]*e[12],a=e[8]*e[13]-e[9]*e[12];return e[0]*(e[5]*t-e[6]*r+e[7]*s)-e[1]*(e[4]*t-e[6]*o+e[7]*n)+e[2]*(e[4]*r-e[5]*o+e[7]*a)-e[3]*(e[4]*s-e[5]*n+e[6]*a)},invertMatrix4=e=>{const t=determinant4(e);if(Math.abs(t)<1e-6||Number.isNaN(t)||!Number.isFinite(e[12])||!Number.isFinite(e[13])||!Number.isFinite(e[14]))return;const r=e[10]*e[15]-e[11]*e[14],s=e[9]*e[15]-e[11]*e[13],o=e[9]*e[14]-e[10]*e[13],n=e[8]*e[15]-e[11]*e[12],a=e[8]*e[14]-e[10]*e[12],c=e[8]*e[13]-e[9]*e[12],i=e[6]*e[15]-e[7]*e[14],l=e[5]*e[15]-e[7]*e[13],d=e[5]*e[14]-e[6]*e[13],m=e[6]*e[11]-e[7]*e[10],p=e[5]*e[11]-e[7]*e[9],g=e[5]*e[10]-e[6]*e[9],u=e[4]*e[15]-e[7]*e[12],v=e[4]*e[14]-e[6]*e[12],h=e[4]*e[11]-e[7]*e[8],_=e[4]*e[10]-e[6]*e[8],b=e[4]*e[13]-e[5]*e[12],y=e[4]*e[9]-e[5]*e[8],E=[+(e[5]*r-e[6]*s+e[7]*o),-(e[1]*r-e[2]*s+e[3]*o),+(e[1]*i-e[2]*l+e[3]*d),-(e[1]*m-e[2]*p+e[3]*g),-(e[4]*r-e[6]*n+e[7]*a),+(e[0]*r-e[2]*n+e[3]*a),-(e[0]*i-e[2]*u+e[3]*v),+(e[0]*m-e[2]*h+e[3]*_),+(e[4]*s-e[5]*n+e[7]*c),-(e[0]*s-e[1]*n+e[3]*c),+(e[0]*l-e[1]*u+e[3]*b),-(e[0]*p-e[1]*h+e[3]*y),-(e[4]*o-e[5]*a+e[6]*c),+(e[0]*o-e[1]*a+e[2]*c),-(e[0]*d-e[1]*v+e[2]*b),+(e[0]*g-e[1]*_+e[2]*y)],A=1/t;return E.map((e=>e*A))},At=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0]),makeMatrix4Translate=(e=0,t=0,r=0)=>[...At,e,t,r,1],singleAxisRotate4=(e,t,r,s,o)=>{const n=makeMatrix4Translate(...t),a=Math.cos(e),c=Math.sin(e);return n[4*r+r]=a,n[4*r+s]=(o?1:-1)*c,n[4*s+r]=(o?-1:1)*c,n[4*s+s]=a,n},makeMatrix4Rotate=(e,t=[0,0,1],r=[0,0,0])=>{const s=[0,1,2].map((e=>r[e]||0)),[o,n,a]=resize(3,normalize(t)),c=Math.cos(e),i=Math.sin(e),l=1-c,d=makeMatrix4Translate(-s[0],-s[1],-s[2]),m=makeMatrix4Translate(s[0],s[1],s[2]);return multiplyMatrices4(m,multiplyMatrices4([l*o*o+c,l*n*o+a*i,l*a*o-n*i,0,l*o*n-a*i,l*n*n+c,l*a*n+o*i,0,l*o*a+n*i,l*n*a-o*i,l*a*a+c,0,0,0,0,1],d))},makePerspectiveMatrix4=(e,t,r,s)=>{const o=Math.tan(.5*Math.PI-.5*e),n=1/(r-s);return[o/t,0,0,0,0,o,0,0,0,0,(r+s)*n,-1,0,0,r*s*n*2,0]},makeOrthographicMatrix4=(e,t,r,s,o,n)=>[2/(t-s),0,0,0,0,2/(e-r),0,0,0,0,2/(o-n),0,(s+t)/(s-t),(r+e)/(r-e),(o+n)/(o-n),1];var kt=Object.freeze({__proto__:null,determinant4:determinant4,identity4x4:Et,invertMatrix4:invertMatrix4,isIdentity4x4:e=>Et.map(((t,r)=>Math.abs(t-e[r])<L)).reduce(((e,t)=>e&&t),!0),makeLookAtMatrix4:(e,t,r)=>{const s=normalize3(subtract3(e,t)),o=normalize3(cross3(r,s)),n=normalize3(cross3(s,o));return[o[0],o[1],o[2],0,n[0],n[1],n[2],0,s[0],s[1],s[2],0,e[0],e[1],e[2],1]},makeMatrix4ReflectZ:(e,t=[0,0])=>{const r=makeMatrix2Reflect(e,t);return[r[0],r[1],0,0,r[2],r[3],0,0,0,0,1,0,r[4],r[5],0,1]},makeMatrix4Rotate:makeMatrix4Rotate,makeMatrix4RotateX:(e,t=[0,0,0])=>singleAxisRotate4(e,t,1,2,!0),makeMatrix4RotateY:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,2,!1),makeMatrix4RotateZ:(e,t=[0,0,0])=>singleAxisRotate4(e,t,0,1,!0),makeMatrix4Scale:(e=[1,1,1],t=[0,0,0])=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,e[0]*-t[0]+t[0],e[1]*-t[1]+t[1],e[2]*-t[2]+t[2],1],makeMatrix4Translate:makeMatrix4Translate,makeOrthographicMatrix4:makeOrthographicMatrix4,makePerspectiveMatrix4:makePerspectiveMatrix4,multiplyMatrices4:multiplyMatrices4,multiplyMatrix4Line3:(e,t,r)=>({vector:[e[0]*t[0]+e[4]*t[1]+e[8]*t[2],e[1]*t[0]+e[5]*t[1]+e[9]*t[2],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]],origin:[e[0]*r[0]+e[4]*r[1]+e[8]*r[2]+e[12],e[1]*r[0]+e[5]*r[1]+e[9]*r[2]+e[13],e[2]*r[0]+e[6]*r[1]+e[10]*r[2]+e[14]]}),multiplyMatrix4Vector3:multiplyMatrix4Vector3});const quaternionFromTwoVectors=(e,t)=>{const r=cross3(e,t),s=[r[0],r[1],r[2],dot(e,t)];return s[3]+=magnitude(s),normalize(s)},matrix4FromQuaternion=e=>multiplyMatrices4([e[3],e[2],-e[1],e[0],-e[2],e[3],e[0],e[1],e[1],-e[0],e[3],e[2],-e[0],-e[1],-e[2],e[3]],[e[3],e[2],-e[1],-e[0],-e[2],e[3],e[0],-e[1],e[1],-e[0],e[3],-e[2],e[0],e[1],e[2],e[3]]);const xt={...J,...X,...ee,...kt,...Object.freeze({__proto__:null,matrix4FromQuaternion:matrix4FromQuaternion,quaternionFromTwoVectors:quaternionFromTwoVectors})},convexHullIndices=(e=[],t=!1,r=L)=>{if(e.length<2)return[];const s=radialSortPointIndices2(e,r).map((e=>1===e.length?e:(e=>e.concat(e.slice(0,-1).reverse()))(e))).flat();s.push(s[0]);const o=[s[0]];let n=1;const a={"-1":()=>o.pop(),1:e=>{o.push(e),n+=1},undefined:()=>{n+=1}};for(a[0]=t?a[1]:a[-1];n<s.length;){if(o.length<2){o.push(s[n]),n+=1;continue}const t=o[o.length-2],c=o[o.length-1],i=s[n];a[threePointTurnDirection(...[t,c,i].map((t=>e[t])),r)](i)}return o.pop(),o},convexHull=(e=[],t=!1,r=L)=>convexHullIndices(e,t,r).map((t=>e[t]));const recurseSkeleton=(e,t,r)=>{const s=e.map(((e,t)=>({vector:r[t],origin:e}))).map(((e,t,r)=>intersectLineLine(e,r[(t+1)%r.length],W,W))),o=t.map(((e,t)=>nearestPointOnLine(e,s[t],(e=>e))));if(3===e.length)return e.map((e=>({type:"skeleton",points:[e,s[0]]}))).concat([{type:"perpendicular",points:[o[0],s[0]]}]);const n=s.map(((e,t)=>distance(e,o[t])));let a=0;n.forEach(((e,t)=>{e<n[a]&&(a=t)}));const c=[{type:"skeleton",points:[e[a],s[a]]},{type:"skeleton",points:[e[(a+1)%e.length],s[a]]},{type:"perpendicular",points:[o[a],s[a]]}],i=clockwiseBisect2(flip(t[(a+t.length-1)%t.length].vector),t[(a+1)%t.length].vector),l=a===e.length-1;return e.splice(a,2,s[a]),t.splice(a,1),r.splice(a,2,i),l&&(e.splice(0,1),r.splice(0,1),t.push(t.shift())),c.concat(recurseSkeleton(e,t,r))},Ot={...Object.freeze({__proto__:null,convexHull:convexHull,convexHullIndices:convexHullIndices}),...we,...De,...oe,...ve,straightSkeleton:e=>{const t=e.map(((e,t,r)=>[e,r[(t+1)%r.length]])).map((e=>({vector:subtract(e[1],e[0]),origin:e[0]}))),r=e.map(((e,t,r)=>[(t-1+r.length)%r.length,t,(t+1)%r.length].map((e=>r[e])))).map((e=>[subtract(e[0],e[1]),subtract(e[2],e[1])])).map((e=>clockwiseBisect2(...e)));return recurseSkeleton([...e],t,r)}};const Mt={...yt,...xt,...Ot,...{...Object.freeze({__proto__:null,enclosingBoundingBoxes:(e,t,r=L)=>{const s=Math.min(e.min.length,t.min.length);for(let o=0;o<s;o+=1)if(t.min[o]<e.min[o]-r||t.max[o]>e.max[o]+r)return!1;return!0},enclosingPolygonPolygon:(e,t,r=include)=>{const s=e.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e||t),!1),o=t.map((e=>overlapConvexPolygonPoint(t,e,r))).reduce(((e,t)=>e&&t),!0);return!s&&o}}),...je,...Ce,...Ze,...Object.freeze({__proto__:null,splitConvexPolygon:(e,t)=>{const r=e.map(((e,r)=>({point:overlapLinePoint(t,e,D)?e:null,at_index:r}))).filter((e=>null!=e.point)),s=e.map(((e,t,r)=>({vector:subtract(e,r[(t+1)%r.length]),origin:r[(t+1)%r.length]}))).map(((e,r)=>({point:intersectLineLine(t,e,q,excludeS),at_index:r}))).filter((e=>null!=e.point));if(2===s.length){const t=s.slice().sort(((e,t)=>e.at_index-t.at_index)),r=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));r.push(t[0].point),r.push(t[1].point);const o=e.slice(t[0].at_index+1,t[1].at_index+1);return o.push(t[1].point),o.push(t[0].point),[r,o]}if(1===s.length&&1===r.length){r[0].type="v",s[0].type="e";const t=r.concat(s).sort(((e,t)=>e.at_index-t.at_index)),o=e.slice(t[1].at_index+1).concat(e.slice(0,t[0].at_index+1));"e"===t[0].type&&o.push(t[0].point),o.push(t[1].point);const n=e.slice(t[0].at_index+1,t[1].at_index+1);return"e"===t[1].type&&n.push(t[1].point),n.push(t[0].point),[o,n]}if(2===r.length){const t=r.slice().sort(((e,t)=>e.at_index-t.at_index));return[e.slice(t[1].at_index).concat(e.slice(0,t[0].at_index+1)),e.slice(t[0].at_index,t[1].at_index+1)]}return[e.slice()]}})}},cubrt=e=>e<0?-Math.pow(-e,1/3):Math.pow(e,1/3),normalAxiom6=(e,t,r,s)=>{if(Math.abs(1-dot2(e.normal,r)/e.distance)<.02)return[];const o=rotate90(e.normal),n=subtract2(add2(r,scale2(e.normal,e.distance)),scale2(s,2)),a=subtract2(scale2(e.normal,e.distance),r),c=dot2(s,t.normal)-t.distance,i=2*dot2(a,o),l=dot2(a,a),d=dot2(add2(n,a),o),m=dot2(n,a),p=dot2(o,t.normal),g=dot2(a,t.normal),u=p,v=c+d*p+g,h=c*i+m*p+d*g,_=c*l+m*g;let b=0;return Math.abs(h)>L&&(b=1),Math.abs(v)>L&&(b=2),Math.abs(u)>L&&(b=3),((e,t,r,s,o)=>{switch(e){case 1:return[-o/s];case 2:{const e=Math.pow(s,2)-4*r*o;if(e<-L)return[];const t=-s/(2*r);if(e<L)return[t];const n=Math.sqrt(e)/(2*r);return[t+n,t-n]}case 3:{const e=r/t,n=s/t,a=o/t,c=(3*n-Math.pow(e,2))/9,i=(9*e*n-27*a-2*Math.pow(e,3))/54,l=Math.pow(c,3)+Math.pow(i,2),d=-e/3;if(l>0){const e=Math.sqrt(l);return[d+cubrt(i+e)+cubrt(i-e)]}if(Math.abs(l)<L){const e=Math.pow(i,1/3);return i<0?[]:[d+2*e,d-e]}const m=Math.sqrt(-l),p=Math.atan2(m,i)/3,g=Math.pow(Math.pow(i,2)-l,1/6),u=g*Math.cos(p),v=g*Math.sin(p);return[d+2*u,d-u-Math.sqrt(3)*v,d-u+Math.sqrt(3)*v]}default:return[]}})(b,u,v,h,_).map((t=>add2(scale2(e.normal,e.distance),scale2(o,t)))).map((e=>({p:e,normal:normalize2(subtract2(e,r))}))).map((e=>({normal:e.normal,distance:dot2(e.normal,midpoint2(e.p,r))})))};var wt=Object.freeze({__proto__:null,normalAxiom1:(e,t)=>{const r=normalize2(rotate90(subtract2(t,e)));return{normal:r,distance:dot2(add2(e,t),r)/2}},normalAxiom2:(e,t)=>{const r=normalize2(subtract2(t,e));return{normal:r,distance:dot2(add2(e,t),r)/2}},normalAxiom3:(e,t)=>{const r=((e,t)=>{const r=cross2(e.normal,t.normal);if(Math.abs(r)<L)return;return[(e.distance*t.normal[1]-t.distance*e.normal[1])/r,(t.distance*e.normal[0]-e.distance*t.normal[0])/r]})(e,t);return void 0===r?[{normal:e.normal,distance:(e.distance+t.distance*dot2(e.normal,t.normal))/2}]:[add2,subtract2].map((r=>normalize2(r(e.normal,t.normal)))).map((e=>({normal:e,distance:dot2(r,e)})))},normalAxiom4:(e,t)=>{const r=rotate90(e.normal);return{normal:r,distance:dot2(t,r)}},normalAxiom5:(e,t,r)=>{const s=dot2(t,e.normal),o=e.distance-s,n=distance2(t,r);if(o>n)return[];const a=Math.sqrt(n*n-o*o),c=scale2(e.normal,o),i=add2(t,c),l=scale2(rotate90(e.normal),a);return(a<L?[i]:[add2(i,l),subtract2(i,l)]).map((e=>normalize2(subtract2(r,e)))).map((e=>({normal:e,distance:dot2(t,e)})))},normalAxiom6:normalAxiom6,normalAxiom7:(e,t,r)=>{const s=rotate90(e.normal),o=dot2(s,t.normal);if(Math.abs(o)<L)return;const n=dot2(r,s),a=dot2(r,t.normal);return{normal:s,distance:(t.distance+2*n*o-a)/(2*o)}}});var jt=Object.freeze({__proto__:null,axiom1:(e,t)=>({vector:normalize2(subtract2(...resizeUp(t,e))),origin:e}),axiom2:(e,t)=>({vector:normalize2(rotate90(subtract2(...resizeUp(t,e)))),origin:midpoint2(e,t)}),axiom3:(e,t)=>bisectLines2(e,t),axiom4:(e,t)=>({vector:rotate90(normalize2(e.vector)),origin:t}),axiom5:(e,t,r)=>(intersectCircleLine({radius:distance2(t,r),origin:t},e,D)||[]).map((e=>({vector:normalize2(rotate90(subtract2(...resizeUp(e,r)))),origin:midpoint2(r,e)}))),axiom6:(e,t,r,s)=>normalAxiom6(rayLineToUniqueLine(e),rayLineToUniqueLine(t),r,s).map(uniqueLineToRayLine),axiom7:(e,t,r)=>{const s=intersectLineLine(e,{vector:t.vector,origin:r},D,D);return void 0===s?void 0:{vector:normalize2(rotate90(subtract2(...resizeUp(s,r)))),origin:midpoint2(r,s)}}});const arrayify=(e,t)=>{switch(e){case 3:case"3":case 5:case"5":case 6:case"6":return t;case 7:case"7":return void 0===t?[]:[t];default:return[t]}},reflectPoint=(e,t)=>{const r=makeMatrix2Reflect(e.vector,e.origin);return multiplyMatrix2Vector2(r,t)},validateAxiom1=(e,t)=>e.points.map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0),Ft=validateAxiom1,validateAxiom3=(e,t,r)=>{const s=e.lines.map((e=>clipLineConvexPolygon(t,e,include,D)));if(void 0===s[0]||void 0===s[1])return[!1,!1];const o=r.map((e=>void 0===e?void 0:clipLineConvexPolygon(t,e,include,D))),n=[0,1].map((e=>void 0!==o[e])),a=r.map((e=>void 0===e?void 0:[reflectPoint(e,s[0][0]),reflectPoint(e,s[0][1])])).map((e=>void 0!==e&&(overlapLinePoint({vector:subtract(s[1][1],s[1][0]),origin:s[1][0]},e[0],includeS)||overlapLinePoint({vector:subtract(s[1][1],s[1][0]),origin:s[1][0]},e[1],includeS)||overlapLinePoint({vector:subtract(e[1],e[0]),origin:e[0]},s[1][0],includeS)||overlapLinePoint({vector:subtract(e[1],e[0]),origin:e[0]},s[1][1],includeS))));return[0,1].map((e=>!0===a[e]&&!0===n[e]))},validateAxiom4=(e,t)=>{const r=intersectLineLine(e.lines[0],{vector:rotate90(e.lines[0].vector),origin:e.points[0]},D,D);return[e.points[0],r].filter((e=>void 0!==e)).map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0)},validateAxiom5=(e,t,r)=>{if(0===r.length)return[];const s=e.points.map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0);return r.map((t=>reflectPoint(t,e.points[1]))).map((e=>overlapConvexPolygonPoint(t,e,include))).map((e=>e&&s))},validateAxiom6=function(e,t,r){if(0===r.length)return[];if(!e.points.map((e=>overlapConvexPolygonPoint(t,e,include))).reduce(((e,t)=>e&&t),!0))return r.map((()=>!1));const s=r.map((t=>reflectPoint(t,e.points[0]))).map((e=>overlapConvexPolygonPoint(t,e,include))),o=r.map((t=>reflectPoint(t,e.points[1]))).map((e=>overlapConvexPolygonPoint(t,e,include)));return r.map(((e,t)=>s[t]&&o[t]))},validateAxiom7=(e,t,r)=>{const s=overlapConvexPolygonPoint(t,e.points[0],include);if(void 0===r)return[!1];const o=reflectPoint(r,e.points[0]),n=overlapConvexPolygonPoint(t,o,include),a=void 0!==intersectConvexPolygonLine(t,e.lines[1],includeS,D),c=intersectLineLine(e.lines[1],r,D,D),i=!!c&&overlapConvexPolygonPoint(t,c,include);return s&&n&&a&&i},validateAxiom=(e,t,r,s)=>arrayify(e,[null,validateAxiom1,Ft,validateAxiom3,validateAxiom4,validateAxiom5,validateAxiom6,validateAxiom7][e](t,r,((e,t)=>{switch(e){case 3:case"3":case 5:case"5":case 6:case"6":return t;default:return t?t[0]:void 0}})(e,s)));var Pt=Object.freeze({__proto__:null,validateAxiom1:validateAxiom1,validateAxiom2:Ft,validateAxiom3:validateAxiom3,validateAxiom4:validateAxiom4,validateAxiom5:validateAxiom5,validateAxiom6:validateAxiom6,validateAxiom7:validateAxiom7,validateAxiom:validateAxiom});const spreadParams=e=>[...e.lines?e.lines:[],...e.points?e.points:[]],axiomInBoundary=(e,t={},r)=>{const s=arrayify(e,jt[`axiom${e}`](...spreadParams(t)));return r&&arrayify(e,Pt[`validateAxiom${e}`](t,r,s)).forEach(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete s[e])),s};var Ct=Object.freeze({__proto__:null,axiomInBoundary:axiomInBoundary,normalAxiomInBoundary:(e,t={},r)=>{const s=arrayify(e,wt[`normalAxiom${e}`](...spreadParams(t))).map((e=>uniqueLineToRayLine(e)));return r&&arrayify(e,Pt[`validateAxiom${e}`]((e=>({points:e.points,lines:e.lines.map(uniqueLineToRayLine)}))(t),r,s)).forEach(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>delete s[e])),s}});const axiom=(e,t={},r)=>axiomInBoundary(e,t,r);Object.keys(jt).forEach((e=>{axiom[e]=jt[e]})),Object.keys(wt).forEach((e=>{axiom[e]=wt[e]})),Object.keys(Ct).forEach((e=>{axiom[e]=Ct[e]})),axiom.validateAxiom1=validateAxiom1,axiom.validateAxiom2=Ft,axiom.validateAxiom3=validateAxiom3,axiom.validateAxiom4=validateAxiom4,axiom.validateAxiom5=validateAxiom5,axiom.validateAxiom6=validateAxiom6,axiom.validateAxiom7=validateAxiom7,axiom.validate=validateAxiom;const line_line_for_arrows=(e,t)=>intersectLineLine(e,t,D,D),diagram_reflect_point=(e,t)=>{const r=makeMatrix2Reflect(e.vector,e.origin);return multiplyMatrix2Vector2(r,t)},boundary_for_arrows$1=({vertices_coords:e})=>convexHull(e),widest_perp=(e,t,r)=>{const s=boundary_for_arrows$1(e);if(void 0===r){const e=clipLineConvexPolygon(s,t,exclude,D);r=midpoint(...e)}const o=rotate270(t.vector),n=clipLineConvexPolygon(s,{vector:o,origin:r},exclude,D).map((e=>distance(r,e))).sort(((e,t)=>e-t)).shift(),a=scale(normalize(o),n);return[add(r,flip(a)),add(r,a)]},between_2_segments=(e,t,r)=>{const s=t.map((e=>midpoint(e[0],e[1]))),o=pointsToLine(...s),n=intersect(r,o),a={vector:r.vector.rotate90(),origin:n};return segment(e.lines.map((e=>intersect(e,a))))},St=[null,(e,t)=>axiom(1,e).map((e=>[widest_perp(t,e)])),e=>[[...e.points]],(e,t)=>{const r=boundary_for_arrows$1(t),s=e.lines.map((e=>clipLineConvexPolygon(r,e,exclude,D))),o=s.map((e=>subtract(e[1],e[0]))),n=intersectLineLine({vector:o[0],origin:s[0][0]},{vector:o[1],origin:s[1][0]},excludeS,excludeS);return n?axiom(3,e).map((t=>((e,t,r,s)=>{const o=e.lines.map((e=>e.vector)),n=o.map(flip),a=o.concat(n).map((e=>ray(e,t))),c=a.filter((e=>dot(e.vector,r.vector)>0&&cross2(e.vector,r.vector)>0)).shift(),i=a.filter((e=>dot(e.vector,r.vector)>0&&cross2(e.vector,r.vector)<0)).shift(),l=a.filter((e=>dot(e.vector,r.vector)<0&&cross2(e.vector,r.vector)>0)).shift(),d=a.filter((e=>dot(e.vector,r.vector)<0&&cross2(e.vector,r.vector)<0)).shift(),m=[c,i,l,d].map((e=>intersectConvexPolygonLine(s,e,excludeS,W).shift().shift())),p=m.map((e=>distance(e,t)));return[[p[0]<p[1]?m[0]:m[1],p[0]<p[1]?add(i.origin,i.vector.normalize().scale(p[0])):add(c.origin,c.vector.normalize().scale(p[1]))],[p[2]<p[3]?m[2]:m[3],p[2]<p[3]?add(d.origin,d.vector.normalize().scale(p[2])):add(l.origin,l.vector.normalize().scale(p[3]))]]})(e,n,t,r))):[between_2_segments(e,s,axiom(3,e).filter((e=>void 0!==e)).shift())]},(e,t)=>axiom(4,e).map((r=>[widest_perp(t,r,line_line_for_arrows(r,e.lines[0]))])),e=>axiom(5,e).map((t=>[e.points[1],diagram_reflect_point(t,e.points[1])])),e=>axiom(6,e).map((t=>e.points.map((e=>[e,diagram_reflect_point(t,e)])))),(e,t)=>axiom(7,e).map((r=>[[e.points[0],diagram_reflect_point(r,e.points[0])],widest_perp(t,r,line_line_for_arrows(r,e.lines[1]))]))];delete St[0];const axiomArrows=(e,t={},...r)=>{const s=t.points?t.points.map((e=>getVector(e))):void 0,o=t.lines?t.lines.map((e=>getLine$1(e))):void 0;return St[e]({points:s,lines:o},...r)};Object.keys(St).forEach((e=>{axiomArrows[e]=(...t)=>axiomArrows(e,...t)}));var Nt=Object.assign(Object.create(null),{axiom_arrows:axiomArrows,simple_arrow:(e,t)=>{const r=(({vertices_coords:e})=>convexHull(e))(e),s=boundingBox$1(r),o=((e,t,r)=>{if(void 0===r){const s=clipLineConvexPolygon(e,t,exclude,D);if(void 0===s)return;r=midpoint(...s)}const s=rotate90(t.vector),o=clipLineConvexPolygon(e,{vector:s,origin:r},exclude,D).map((e=>distance(r,e))).sort(((e,t)=>e-t)).shift(),n=scale(normalize(s),o);return[add(r,flip(n)),add(r,n)]})(r,t);if(void 0===o)return;const n=subtract(o[1],o[0]),a=magnitude(n),c=dot(n,[1,0]),i=s.span[0]<s.span[1]?s.span[0]:s.span[1];return o.head={width:.1*i,height:.15*i},o.bend=c>0?.3:-.3,o.padding=.05*a,o}});var zt=Object.freeze({__proto__:null,flipFacesLayer:e=>invertMap(invertMap(e).reverse()),facesLayerToEdgesAssignments:(e,t)=>{const r=[],s=makeFacesWinding(e);return(e.edges_faces?e.edges_faces:makeEdgesFaces(e)).forEach(((e,o)=>{if(1===e.length&&(r[o]="B"),2===e.length){const n=e.map((e=>s[e]));if(n[0]===n[1])return void(r[o]="F");const a=e.map((e=>t[e])),c=a[0]<a[1],i=n[0]?c:!c;r[o]=i?"V":"M"}})),r},faceOrdersToMatrix:e=>{const t=[];e.forEach((e=>{t[e[0]]=void 0,t[e[1]]=void 0}));const r=t.map((()=>[]));return e.forEach((([e,t,s])=>{r[e][t]=s,r[t][e]=-s})),r}});const nudgeFacesWithFacesLayer=({faces_layer:e})=>{const t=[];return invertMap(e).forEach(((e,r)=>{t[e]={vector:[0,0,1],layer:r}})),t},nudgeFacesWithFaceOrders=({vertices_coords:e,faces_vertices:t,faceOrders:r})=>{const s=makeFacesNormal({vertices_coords:e,faces_vertices:t}),o=connectedComponents(makeVerticesVerticesUnsorted({edges_vertices:r.map((e=>[e[0],e[1]]))})),n=invertMap(o).map((e=>e.constructor===Array?e:[e])),a=n.map((e=>(({faceOrders:e,faces_normal:t},r)=>{if(!e)return[];const s={};r.forEach((e=>{s[e]=!0})),r[0];const o=[];r.forEach((e=>{o[e]=dot(t[e],t[r[0]])>0}));const n=[];r.forEach((e=>{n[e]=[]})),e.forEach((e=>{if(!s[e[0]])return;const t=-1===e[2]^!o[e[1]]?[e[1],e[0]]:[e[0],e[1]];n[t[0]].push(t[1])}));const a=[],c={},recurse=e=>{c[e]=!0,n[e].forEach((e=>{c[e]||recurse(e)})),a.push(e)};return r.forEach((e=>{c[e]||recurse(e)})),a})({faceOrders:r,faces_normal:s},e))),c=n.map((e=>s[e[0]])),i=[];return a.forEach(((e,t)=>e.forEach(((e,r)=>{i[e]={vector:c[t],layer:r}})))),i};var $t=Object.freeze({__proto__:null,nudgeFacesWithFacesLayer:nudgeFacesWithFacesLayer,nudgeFacesWithFaceOrders:nudgeFacesWithFaceOrders});const between=(e,t,r)=>t<r?e.slice(t+1,r):e.slice(r+1,t),validateTacoTacoFacePairs=e=>{const t=nonUniqueElements(e),r={};let s=0;for(let e=0;e<t.length;e+=1)if(void 0===r[t[e]])s+=1,r[t[e]]=s;else if(void 0!==r[t[e]]){if(r[t[e]]!==s)return!1;s-=1,r[t[e]]=void 0}return!0},build_layers=(e,t)=>e.map((e=>t[e])).filter((e=>void 0!==e)),validateLayerSolver=(e,t,r,s,o)=>{const n=flattenArrays(t);if(!((e,t,r=!0,s=L)=>{const o=invertMap(t),n=e.map((e=>e?e[1]:void 0)),a=e.map((e=>e?Math.min(...e):void 0)).map((e=>e+s)),c=e.map((e=>e?Math.max(...e):void 0)).map((e=>e-s)),i=o.length+(r?0:-1);for(let e=0;e<i;e+=1){const r=(e+1)%o.length;if(o[e]===o[r])continue;const s=between(t,o[e],o[r]).flat(),i=s.map((t=>n[e]<a[t])).reduce(((e,t)=>e&&t),!0),l=s.map((t=>n[e]>c[t])).reduce(((e,t)=>e&&t),!0);if(!i&&!l)return!1}return!0})(e,t,s,o))return!1;for(let e=0;e<r.length;e+=1){const t=build_layers(n,r[e]);if(!validateTacoTacoFacePairs(t))return!1}return!0},Vt={V:!0,v:!0,M:!0,m:!0},Tt={V:1,v:1,M:-1,m:-1},assignmentsToFacesVertical=e=>{let t=0;return e.slice(1).concat([e[0]]).map((e=>{const r=(s=e,t%2==0?Tt[s]||0:-(Tt[s]||0));var s;return t+=void 0===Tt[e]?0:1,r}))},foldStripWithAssignments=(e,t)=>{const r=(e=>{let t=0;const r=e.slice(1);return[!1].concat(r.map((e=>Vt[e]?++t:t)).map((e=>e%2==1)))})(t).map(((t,r)=>e[r]*(t?-1:1))),s=e.map((()=>{}));s[0]=[0,r[0]];for(let o=1;o<e.length&&("B"!==t[o]&&"b"!==t[o]);o+=1){const t=s[(o-1+e.length)%e.length][1];s[o]=[t,t+r[o]]}return s},Lt={B:!0,b:!0},singleVertexSolver=(e,t,r=L)=>{const s=foldStripWithAssignments(e,t),o=assignmentsToFacesVertical(t),n=t.map((e=>!Lt[e])).reduce(((e,t)=>e&&t),!0);if(n){const e=s[0][0],t=s[s.length-1][1];if(Math.abs(e-t)>r)return[]}const a=((e,t,r)=>{const s=e.map((e=>e?(e[0]+e[1])/2:void 0)),o=[];return e.forEach(((n,a)=>{if(!n)return;if(!t&&a===e.length-1)return;const c=n[1],i=c-2*r,l=c+2*r,d=[a,(a+1)%e.length],m=d.map((e=>s[e])).map((e=>e>c)),p=1*(!m[0]&&!m[1])+2*(m[0]&&m[1]),g=o.filter((e=>e.min<c&&e.max>c)).shift(),u={faces:d,taco_type:p};g?g.pairs.push(u):o.push({min:i,max:l,pairs:[u]})})),o.map((e=>e.pairs)).filter((e=>e.length>1)).map((e=>({both:e.filter((e=>0===e.taco_type)).map((e=>e.faces)),left:e.filter((e=>1===e.taco_type)).map((e=>e.faces)),right:e.filter((e=>2===e.taco_type)).map((e=>e.faces))})))})(s,n,r).map((e=>[e.left,e.right].map(invertMap).filter((e=>e.length>1)))).reduce(((e,t)=>e.concat(t)),[]),recurse=(t=[0],c=0,i=0)=>{const l=c+1,d=o[c],m=c>=e.length-1,p=n&&m;if(!validateLayerSolver(s,t,a,p,r))return[];if(p){const e=invertMap(t),r=e[0],s=e[c];if(d>0&&s>r)return[];if(d<0&&s<r)return[]}if(m)return[t];if(0===d)return t[i]=[l].concat(t[i]),recurse(t,l,i);const g=1===d?Array.from(Array(t.length-i)).map(((e,t)=>i+t+1)):Array.from(Array(i+1)).map(((e,t)=>t)),u=g.map((()=>clone(t)));return u.forEach(((e,t)=>e.splice(g[t],0,l))),u.map(((e,t)=>recurse(e,l,g[t]))).reduce(((e,t)=>e.concat(t)),[])};return recurse().map(invertMap)},maekawaAssignments=e=>{const t=(r=e).map(((e,t)=>t)).filter((e=>"U"===r[e]||"u"===r[e]));var r;const s=Array.from(Array(2**t.length)).map(((e,t)=>t.toString(2))).map((e=>Array(t.length-e.length+1).join("0")+e)).map((e=>Array.from(e).map((e=>"0"===e?"V":"M")))).map((r=>{const s=e.slice();return t.forEach(((e,t)=>{s[e]=r[t]})),s}));if(e.includes("B")||e.includes("b"))return s;const o=s.map((e=>e.filter((e=>"M"===e||"m"===e)).length)),n=s.map((e=>e.filter((e=>"V"===e||"v"===e)).length));return s.filter(((e,t)=>2===Math.abs(o[t]-n[t])))},make_lookup$1=e=>{const t=e[0].length,r=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(Math.pow(2,t))).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{r[0][e]=!1})),e.forEach((e=>{r[0][e]=!0})),Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(Math.pow(3,t))).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>((e,t,r)=>{const s=Array.from(r).map((e=>parseInt(e,10)));if(s.filter((e=>0===e)).length!==t)return;e[t][r]=!1;let o=!1;for(let r=0;r<s.length;r+=1){const n=[];if(0===s[r]){for(let o=1;o<=2;o+=1)s[r]=o,!1!==e[t-1][s.join("")]&&n.push([r,o]);s[r]=0,n.length>0&&!1===o&&(o=[]),1===n.length&&o.push(n[0])}}!1!==o&&0===o.length&&(o=!0),e[t][r]=o})(r,e,t)))));let s=[];Array.from(Array(t+1)).map(((e,r)=>t-r)).forEach((e=>{const t=[];Object.keys(r[e]).forEach((s=>{let o=r[e][s];o.constructor===Array&&(o=o[0]),t.push([s,o])})),s=s.concat(t)})),s.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const o={};return s.forEach((e=>{o[e[0]]=Object.freeze(e[1])})),Object.freeze(o)},It={taco_taco:make_lookup$1(["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"]),taco_tortilla:make_lookup$1(["112","121","212","221"]),tortilla_tortilla:make_lookup$1(["11","22"]),transitivity:make_lookup$1(["112","121","122","211","212","221"])},Bt={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]},pairArrayToSortedPairString$1=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`,Rt={taco_taco:e=>[pairArrayToSortedPairString$1([e[0],e[2]]),pairArrayToSortedPairString$1([e[1],e[3]]),pairArrayToSortedPairString$1([e[1],e[2]]),pairArrayToSortedPairString$1([e[0],e[3]]),pairArrayToSortedPairString$1([e[0],e[1]]),pairArrayToSortedPairString$1([e[2],e[3]])],taco_tortilla:e=>[pairArrayToSortedPairString$1([e[0],e[2]]),pairArrayToSortedPairString$1([e[0],e[1]]),pairArrayToSortedPairString$1([e[1],e[2]])],tortilla_tortilla:e=>[pairArrayToSortedPairString$1([e[0],e[2]]),pairArrayToSortedPairString$1([e[1],e[3]])],transitivity:e=>[pairArrayToSortedPairString$1([e[0],e[1]]),pairArrayToSortedPairString$1([e[1],e[2]]),pairArrayToSortedPairString$1([e[2],e[0]])]},Ut={0:0,1:1,2:-1},keysToFaceOrders$1=(e,t)=>{const r=Object.keys(e),s=r.map((e=>e.split(" ").map((e=>parseInt(e,10)))));return s.forEach(((s,o)=>{const n=-2*(1===Ut[e[r[o]]]^t[s[1]])+1;s.push(n)})),s},reformatSolution=(e,t)=>(e.orders&&(e.orders=e.orders.flatMap((e=>keysToFaceOrders$1(e,t)))),e.leaves&&(e.leaves=e.leaves.map((e=>keysToFaceOrders$1(e,t)))),e.partitions&&e.partitions.forEach((e=>reformatSolution(e,t))),e.node&&e.node.forEach((e=>reformatSolution(e,t))),e),Dt=Object.freeze(Object.keys(It)),qt={0:0,1:2,2:1},buildRuleAndLookup$1=(e,t,...r)=>{const s=Bt[e](t),o=s.map((e=>e[1]<e[0])),n=s.map(((e,t)=>o[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`)),a=n.map(((e,t)=>{for(let s=0;s<r.length;s+=1)if(r[s][e])return o[t]?qt[r[s][e]]:r[s][e];return 0})).join("");if(!0===It[e][a])return!0;if(!1===It[e][a])return!1;const c=It[e][a];return[n[c[0]],o[c[0]]?qt[c[1]]:c[1]]},getConstraintIndicesFromFacePairs$1=(e,t,r)=>{const s={};return Dt.forEach((o=>{const n=r.flatMap((e=>t[o][e]));s[o]=uniqueElements(n).filter((t=>e[o][t]))})),s},propagate$1=(e,t,r,...s)=>{let o=r;const n={};do{const r=getConstraintIndicesFromFacePairs$1(e,t,o),a={};for(let t=0;t<Dt.length;t+=1){const o=Dt[t],c=r[o];for(let t=0;t<c.length;t+=1){const r=buildRuleAndLookup$1(o,e[o][c[t]],...s,n);if(!0!==r){if(!1===r)return console.warn("invalid state found",o,e[o][c[t]]),!1;if(n[r[0]]){if(n[r[0]]!==r[1])return console.warn("order conflict",o,e[o][c[t]]),!1}else{const[e,t]=r;a[e]=!0,n[r[0]]=t}}}}o=Object.keys(a)}while(o.length);return n},getNeighborsArray=(e,t,r)=>{const s={};return Object.keys(t).forEach((o=>{const n=r[o][e];n&&n.map((e=>t[o][e])).map((e=>Rt[o](e).forEach((e=>{s[e]=!0}))))})),Object.keys(s)},coplanarOverlappingFacesGroups=({vertices_coords:e,faces_vertices:t,faces_faces:r},s=L)=>{r||(r=makeFacesFaces({faces_vertices:t}));const o=(({vertices_coords:e,faces_vertices:t},r=L)=>{const s=makeFacesNormal({vertices_coords:e,faces_vertices:t}),o=t.map((()=>[]));for(let e=0;e<t.length-1;e+=1)for(let n=e+1;n<t.length;n+=1)e!==n&&parallelNormalized(s[e],s[n],r)&&(o[e].push(n),o[n].push(e));const n=connectedComponents(o),a=invertMap(n).map((e=>"number"==typeof e?[e]:e)),c=a.map((e=>s[e[0]])),i=[];a.forEach(((e,t)=>e.forEach((e=>{i[e]=dot3(s[e],c[t])>0}))));const l=t.map((t=>e[t[0]])).map((e=>resize(3,e))),d=a.map(((e,t)=>e.map((e=>dot3(c[t],l[e]))))).map(((e,t)=>clusterScalars(e).map((e=>e.map((e=>a[t][e])))))),m=d.flatMap(((e,t)=>e.map((()=>[...c[t]])))),p=d.flat(),g=p.map((e=>e[0])).map((e=>l[e])).map(((e,t)=>dot3(m[t],e))).map(((e,t)=>scale3(m[t],e))),u=p.map(((e,t)=>({normal:m[t],origin:g[t]})));return p.map(((e,t)=>({faces:e,facesAligned:e.map((e=>i[e])),plane:u[t]})))})({vertices_coords:e,faces_vertices:t},s),n=[];o.forEach((e=>e.facesAligned.forEach(((t,r)=>{n[e.faces[r]]=t}))));const a=[0,0,1],c=o.map((e=>e.plane.normal)).map((e=>{const t=dot(e,a);return Math.abs(t+1)<.01?makeMatrix4Rotate(Math.PI,[1,0,0]):matrix4FromQuaternion(quaternionFromTwoVectors(e,a))})),i=((e,t,r,s)=>{const o=e.vertices_coords.map((e=>resize(3,e))),n=t.map((t=>t.faces.map(((r,s)=>t.facesAligned[s]?e.faces_vertices[r]:e.faces_vertices[r].slice().reverse())).map((e=>e.map((e=>o[e])))).map((e=>makePolygonNonCollinear(e,s))))),a=[],c=n.map(((e,t)=>e.map((e=>e.map((e=>multiplyMatrix4Vector3(r[t],e))).map((e=>[e[0],e[1]]))))));return t.map((e=>e.faces)).forEach(((e,t)=>e.forEach(((e,r)=>{a[e]=c[t][r]})))),a})({vertices_coords:e,faces_vertices:t},o,c,s),l=o.map((e=>e.faces)).map((e=>selfRelationalArraySubset(r,e))).map((e=>connectedComponents(e))),d=l.map((e=>invertMap(e).map((e=>e.constructor===Array?e:[e])))),m=l.map((e=>{const t=e.map(((e,t)=>t));return e.map((r=>t.filter((t=>e[t]!==r))))})),p=t.map((()=>[]));m.forEach((e=>e.forEach(((e,t)=>{for(let r=0;r<e.length;r+=1){const o=e[r],n=[t,o].map((e=>i[e]));overlapConvexPolygons(...n,s)&&(p[t][o]=!0,p[o][t]=!0)}}))));const g=m.map((e=>e.map(((e,t)=>e.filter((e=>p[t][e])))))),u=[];g.forEach(((e,t)=>{u[t]=[],e.forEach(((e,r)=>{const s=l[t][r],o=e.map((e=>l[t][e]));u[t][s]||(u[t][s]=new Set),o.forEach((e=>{u[t][e]||(u[t][e]=new Set)})),o.forEach((e=>{u[t][s].add(e),u[t][e].add(s)}))}))})),u.forEach(((e,t)=>e.forEach(((e,r)=>{u[t][r]=[...e]}))));const v=u.map((e=>invertMap(connectedComponents(e)).map((e=>e.constructor===Array?e:[e])))),h=v.flatMap(((e,t)=>e.map((()=>t)))),_=o.map(((e,t)=>v[t].map((e=>e.flatMap((e=>d[t][e])))))).flatMap(((e,t)=>e.map((e=>({faces:e,facesAligned:e.map((e=>n[e])),plane:o[t].plane}))))),b=h.map((e=>o[e].plane)),y=h.map((e=>c[e])),E=_.map((e=>e.faces));return{sets_faces:E,sets_plane:b,sets_transformXY:y,faces_set:invertMap(E),faces_winding:n}},makeTortillaTortillaFacesCrossing$1=(e,t,r)=>{const s=((e,t,r)=>{const s=makeFacesWinding(e),o=makeFacesPolygon(e,r);s.forEach(((e,t)=>{e||o[t].reverse()}));const n=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),a=n.map((t=>e.edges_vertices[t])).map((t=>t.map((t=>e.vertices_coords[t])))),c=a.map((e=>subtract2(e[1],e[0]))),i=[];return n.forEach((e=>{i[e]=[]})),n.map(((e,t)=>o.map((e=>clipLineConvexPolygon(e,{vector:c[t],origin:a[t][0]},exclude,excludeS,r))).map((e=>void 0!==e)))).forEach(((e,t)=>e.forEach(((e,r)=>{e&&i[n[t]].push(r)})))),i})(e,t,r);return s.map(((t,r)=>t.map((t=>[e.edges_faces[r],[t,t]])))).reduce(((e,t)=>e.concat(t)),[])},classify_faces_pair$1=e=>1===e[0]&&-1===e[1]||-1===e[0]&&1===e[1]?"both":1===e[0]&&1===e[1]?"right":-1===e[0]&&-1===e[1]?"left":void 0,makeTacosTortillas$1=(e,t=L)=>{const r=(e=>{const t={...e},r={};return t.edges_foldAngle.map(edgeFoldAngleIsFlat).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)).forEach((e=>{r[e]=!0})),filterKeysWithPrefix(e,"edges_").forEach((s=>{t[s]=[],e[s].forEach(((e,o)=>{r[o]&&(t[s][o]=JSON.parse(JSON.stringify(e)))}))})),t})(e),s=(e=>{const t=e.edges_vertices.map((t=>e.vertices_coords[t[0]])),r=e.edges_vertices.map((t=>subtract2(e.vertices_coords[t[1]],e.vertices_coords[t[0]])));return e.edges_faces.map(((s,o)=>s.map((s=>cross2(subtract2(e.faces_center[s],t[o]),r[o]))).map((e=>Math.sign(e)))))})(r),o=makeEdgesEdgesParallelOverlap(r,t),n=selfRelationalUniqueIndexPairs(o).filter((e=>e.map((e=>r.edges_faces[e].length>1)).reduce(((e,t)=>e&&t),!0))),a=n.map((e=>e.map((e=>r.edges_faces[e])))),c=((e,t,r)=>{const s=t.map((t=>e.edges_vertices[t[0]].map((t=>e.vertices_coords[t])))),o=s.map((e=>e[0])),n=s.map((e=>subtract2(e[1],e[0])));return r.map((t=>t.map((t=>t.map((t=>e.faces_center[t])))))).map(((e,t)=>e.map((e=>e.map((e=>cross2(subtract2(e,o[t]),n[t]))).map((e=>Math.sign(e)))))))})(r,n,a),i=c.map((e=>e.map(classify_faces_pair$1))),l=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"!==r[0]?a[t]:void 0;var r})).filter((e=>void 0!==e)),d=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"===r[0]?a[t]:void 0;var r})).map(((e,t)=>((e,t)=>{if(void 0!==e)return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]})(e,c[t]))).filter((e=>void 0!==e)),m=makeTortillaTortillaFacesCrossing$1(r,s,t),p=d.concat(m),g=i.map(((e,t)=>{return(r=e)[0]===r[1]||"both"!==r[0]&&"both"!==r[1]?void 0:((e,t,r)=>{const s="left"===t[0]||"left"===t[1]?-1:1,o="both"===t[0]?[...e[1]]:[...e[0]],n="both"===t[0]?0:1;return{taco:o,tortilla:r[n][0]===s?e[n][0]:e[n][1]}})(a[t],i[t],c[t]);var r})).filter((e=>void 0!==e)),u=makeEdgesFacesOverlap(r,t),v=booleanMatrixToIndexedArray(u).map(((e,t)=>s[t].length>1&&s[t][0]===s[t][1]?e:[])).map(((e,t)=>({taco:r.edges_faces[t],tortillas:e}))).filter((e=>e.tortillas.length)).flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));return{taco_taco:l,tortilla_tortilla:p,taco_tortilla:g.concat(v)}},Gt={0:0,1:2,2:1},Wt={M:1,m:1,V:2,v:2},doEdgesOverlap=(e,t,r,s=1e-6)=>{const o=((e,t,r=1e-6)=>{const s=e[0]<e[1]?e:[e[1],e[0]],o=t[0]<t[1]?t:[t[1],t[0]];return Math.min(s[1],o[1])-Math.max(s[0],o[0])>r})(...t.map((t=>e.edges_vertices[t].map((t=>e.vertices_coords[t])))).map((e=>e.map((e=>dot(e,r))))),s);return o},make3DTortillas=(e,t,r,s=1e-6)=>{const o=((e,t,r=1e-6)=>{const s=t.map((e=>e.join(" "))),o={};s.forEach(((e,t)=>{void 0===o[e]&&(o[e]=[]),o[e].push(t)})),Object.keys(o).filter((e=>o[e].length<2)).forEach((e=>delete o[e]));const n={};Object.keys(o).forEach((e=>{n[e]=chooseTwoPairs(o[e])}));const a={};Object.keys(n).forEach((t=>{const s=n[t][0][0],o=e.edges_vertices[s].map((t=>e.vertices_coords[t])),c=normalize(subtract(o[1],o[0]));a[t]=n[t].map((t=>doEdgesOverlap(e,t,c,r)))}));const c={};return Object.keys(n).forEach((e=>{c[e]=n[e].filter(((t,r)=>a[e][r]))})),Object.keys(c).flatMap((e=>c[e]))})(e,r,s),n=o.map((t=>t.map((t=>e.edges_faces[t]))));return n.forEach(((e,r)=>{t[e[0][0]]!==t[e[1][0]]&&n[r][1].reverse()})),n},make3DTacoTortillas=(e,t,r,s,o,n,a=1e-6)=>{if(t.length<2)return[];const c=t.map((e=>e.map((e=>e.split(" ").map((e=>parseInt(e,10))))))),i=c.map((e=>e.flat().sort(((e,t)=>e-t)))).map((e=>[...new Set(e)])),l=e.edges_faces.map((e=>{const t={};return e.forEach((e=>{t[e]={}})),t})),d=n.map(((e,t)=>e.flatMap((e=>i[e])).filter((e=>!l[t][e])))),m=n.map(((e,t)=>e.flatMap((e=>i[e])).filter((e=>l[t][e]))));d.map(((t,r)=>edgeFoldAngleIsFlat(e.edges_foldAngle[r])?r:void 0)).filter((e=>void 0!==e)).forEach((e=>{delete d[e],delete m[e]}));const p=d.map(((t,r)=>e.edges_vertices[r].map((t=>e.vertices_coords[t])))),g=d.map(((e,t)=>e.map((e=>((e,t,r)=>!!e.map((e=>overlapConvexPolygonPoint(t,e,exclude,r))).reduce(((e,t)=>e||t),!1)||!!intersectConvexPolygonLine(t,{vector:subtract2(e[1],e[0]),origin:e[0]},excludeS,excludeS,r))(p[t].map((t=>multiplyMatrix4Vector3(r[s[e]],t))),o[e],a))))),u=g.flatMap(((e,t)=>e.map(((e,r)=>e?{edge:t,face:d[t][r],otherFace:m[t][r]}:void 0)).filter((e=>void 0!==e))));return console.log("make3DTacoTortillas"),console.log("sets_facePairs",t),console.log("edges_sets",n),console.log("sets_face_pairs",c),console.log("sets_faces",i),console.log("edges_possibleOverlapFaces",d),console.log("edges_possibleOverlapOtherFaces",m),console.log("edges_segment3D",p),console.log("results",u),u},graphGroupCopies=(e,t,r)=>{const s=e.vertices_coords.map((e=>resize(3,e))),o=t.map((t=>subgraphWithFaces(e,t)));return r.forEach(((e,t)=>{o[t].vertices_coords=o[t].vertices_coords.map(((t,r)=>((e,t)=>{const r=multiplyMatrix4Vector3(e,t);return[r[0],r[1]]})(e,s[r])))})),o},prepare$1=(e,t=1e-6)=>{const r={...e};r.faces_edges||(r.faces_edges=makeFacesEdgesFromVertices(r)),r.edges_faces||(r.edges_faces=makeEdgesFacesUnsorted(r)),!r.edges_foldAngle&&r.edges_assignment&&(r.edges_foldAngle=makeEdgesFoldAngle(r));const{sets_faces:s,sets_transformXY:o,faces_set:n,faces_winding:a}=coplanarOverlappingFacesGroups(r,t),c=graphGroupCopies(r,s,o),i=[];c.map((e=>makeFacesPolygon(e,t))).forEach((e=>e.forEach(((e,t)=>{i[t]=e})))),a.map(((e,t)=>e?void 0:t)).filter((e=>void 0!==e)).forEach((e=>i[e].reverse()));const l=i.map((e=>e.reduce(((e,t)=>add2(e,t)),[0,0]).map((t=>t/e.length))));c.forEach((e=>{e.faces_center=e.faces_vertices.map(((e,t)=>l[t]))}));const d=((e,t,r,s)=>{const o=e.faces_vertices.map((()=>[]));return t.forEach((e=>{for(let t=0;t<e.length-1;t+=1)for(let n=t+1;n<e.length;n+=1){const a=[e[t],e[n]],c=a.map((e=>r[e]));overlapConvexPolygons(...c,s)&&(o[a[0]][a[1]]=!0,o[a[1]][a[0]]=!0)}})),o.map((e=>e.map(((e,t)=>t)).filter((e=>void 0!==e))))})(r,s,i,t),m=c.map((e=>makeTacosTortillas$1(e,t))),p=c.map((e=>((e,t,r=L)=>{const s=makeFacesPolygon(e,r),o=e.faces_vertices.map((()=>[]));s.forEach(((e,n)=>t[n].forEach((e=>{if(e<=n)return;const t=clipPolygonPolygon(s[n],s[e],r);t&&(o[n][e]=t)}))));const n=[];return o.forEach(((e,t)=>e.forEach(((e,a)=>{a<=t||!o[t][a]||o.forEach(((o,c)=>{c<=t||c<=a||clipPolygonPolygon(e,s[c],r)&&n.push([t,a,c].sort(((e,t)=>e-t)))}))})))),n})(e,d,t))),g=p.map(((e,t)=>((e,t)=>{const r={};return t.taco_taco.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{r[e]=!0})))),t.taco_tortilla.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{r[e]=!0})),e.filter((e=>void 0===r[e.join(" ")]))})(e,m[t]))),u=m.map(((e,t)=>((e,t)=>{const r={};return r.taco_taco=e.taco_taco.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),r.taco_tortilla=e.taco_tortilla.map((e=>[e.taco[0],e.tortilla,e.taco[1]])),r.tortilla_tortilla=e.tortilla_tortilla.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]])),r.transitivity=t.map((e=>[e[0],e[1],e[2]])),r})(e,g[t]))),v=selfRelationalUniqueIndexPairs(d),h=v.map((e=>e.join(" "))),_=v.map((e=>n[e[0]])),b=invertMap(_).map((e=>e.constructor===Array?e:[e])).map((e=>e.map((e=>h[e])))),y=u.map(((e,t)=>b[t]?b[t]:[])),E=((e,t)=>{const r=e.edges_vertices.map((()=>({})));t.forEach(((t,s)=>e.faces_edges[s].forEach((e=>{r[e][t]=!0}))));const s=r.map((e=>Object.keys(e).map((e=>parseInt(e,10)))));return s.forEach(((e,t)=>{2!==e.length&&delete s[t]})),s.forEach(((e,t)=>{e[0]>e[1]&&s[t].reverse()})),s})(r,n),A=make3DTortillas(r,n,E,t).map((e=>[...e[0],...e[1]])),k=make3DTacoTortillas(r,y,o,n,i,E,t);k.map((e=>[e.face,e.otherFace].map((e=>a[e]))));const x=k.map((e=>e.face<e.otherFace)),O=k.map(((e,t)=>x[t]?[e.face,e.otherFace]:[e.otherFace,e.face])).map((e=>e.join(" "))),M={"-1":2,1:1,0:0},w=k.map((e=>Math.sign(r.edges_foldAngle[e.edge]))).map((e=>M[e]));console.log("tacoTortillas3D",k);const j={taco_taco:[],taco_tortilla:[],tortilla_tortilla:[],transitivity:[]};u.forEach((e=>{j.taco_taco.push(...e.taco_taco),j.taco_tortilla.push(...e.taco_tortilla),j.tortilla_tortilla.push(...e.tortilla_tortilla),j.transitivity.push(...e.transitivity)})),j.tortilla_tortilla.push(...A);const F=(e=>{const t={};return Object.keys(e).forEach((e=>{t[e]={}})),Object.keys(e).forEach((r=>{e[r].forEach(((e,s)=>Rt[r](e).forEach((e=>{void 0===t[r][e]&&(t[r][e]=[]),t[r][e].push(s)}))))})),t})(j),P=y.flat(),C=((e,t,r)=>{const s={};t.forEach((e=>{s[e]=!0}));const o={};return e.edges_faces.forEach(((t,n)=>{const a=e.edges_assignment[n],c=Wt[a];if(t.length<2||void 0===c)return;const i=r[t[0]]?c:Gt[c],l=`${t[0]} ${t[1]}`,d=`${t[1]} ${t[0]}`;l in s&&(o[l]=i),d in s&&(o[d]=Gt[i])})),o})(r,h,a);return console.log("constraints",j),console.log("constraintsLookup",F),console.log("facePairsFlat",P),console.log("edgeAdjacentOrders",C),O.forEach(((e,t)=>{C[e]=w[t]})),{constraints:j,constraintsLookup:F,facePairs:P,edgeAdjacentOrders:C,faces_winding:a}},allSolutions=(e,...t)=>{const r=e.orders?[...t,e.orders]:[...t];if(e.partitions){const t=e.partitions.map((e=>allSolutions(e)));return(e=>{const t=e.map((e=>e.length)),r=t.slice();for(let e=r.length-2;e>=0;e-=1)r[e]*=r[e+1];r[0]>2**28&&console.warn("allSolutions() might fail: too many");const s=r.slice();return s.push(1),s.shift(),Array.from(Array(r[0])).map(((e,t)=>t)).map((e=>s.map(((r,s)=>Math.floor(e/r)%t[s]))))})(t).map((e=>e.flatMap(((e,r)=>t[r][e])))).map((e=>[...r,...e]))}const s=[];if(e.leaves&&e.leaves.forEach((e=>s.push([...r,e]))),e.node){const t=e.node.flatMap((e=>allSolutions(e,...r)));s.push(...t)}return e.leaves||e.node||s.push([...r]),s},anySolution=e=>{const t=e.orders?e.orders:[];return e.partitions?[...t,...e.partitions.flatMap((e=>anySolution(e)))]:e.leaves?[...t,...e.leaves[0]]:e.node?[...t,...anySolution(e.node[0])]:t},Ht={anySolution:function(){return anySolution(this)},allSolutions:function(){return this.allSolutionsMemo||(this.allSolutionsMemo=allSolutions(this)),this.allSolutionsMemo},count:function(){return this.allSolutions().length}},solveNonBranchingNode=(e,t,r,s,...o)=>{if(!r.length)return{};const n=r[0],a=[],c=[];[1,2].forEach((i=>{const l=propagate$1(e,t,[n],...s,...o,{[n]:i});if(!1===l)return;l[n]=i;(Object.keys(l).length===r.length?a:c).push(l)}));const i={leaves:a,node:c.map((n=>solveNode(e,t,r.filter((e=>!(e in n))),[...s,...o],n)))};return 0===i.leaves.length&&delete i.leaves,0===i.node.length&&delete i.node,i},solveNode=(e,t,r,s,...o)=>{if(!r.length)return{orders:o};const n=((e,t,r,s={})=>{const o={};e.forEach((e=>{o[e]=!0}));let n=0;const a=[];for(;n<e.length;){if(!o[e[n]]){n+=1;continue}const c=[],i=[e[n]],l={[e[n]]:!0};do{const e=i.shift();delete o[e],c.push(e);const n=s[e]?s[e]:getNeighborsArray(e,t,r);s[e]=n;const a=n.filter((e=>o[e]&&!l[e]));i.push(...a),a.forEach((e=>{l[e]=!0}))}while(i.length);n+=1,a.push(c)}return a})(r,e,t);return n.length>1?{orders:o,partitions:n.map((r=>solveNonBranchingNode(e,t,r,s,...o)))}:{orders:o,...solveNonBranchingNode(e,t,n[0],s,...o)}},make_lookup=e=>{const t=e[0].length,r=Array.from(Array(t+1)).map((()=>({})));Array.from(Array(Math.pow(2,t))).map(((e,t)=>t.toString(2))).map((e=>Array.from(e).map((e=>parseInt(e,10)+1)).join(""))).map((e=>`11111${e}`.slice(-t))).forEach((e=>{r[0][e]=!1})),e.forEach((e=>{r[0][e]=!0})),Array.from(Array(t)).map(((e,t)=>t+1)).map((e=>Array.from(Array(Math.pow(3,t))).map(((e,t)=>t.toString(3))).map((e=>`000000${e}`.slice(-t))).forEach((t=>((e,t,r)=>{const s=Array.from(r).map((e=>parseInt(e,10)));if(s.filter((e=>0===e)).length!==t)return;e[t][r]=!1;let o=!1;for(let r=0;r<s.length;r+=1){const n=[];if(0===s[r]){for(let o=1;o<=2;o+=1)s[r]=o,!1!==e[t-1][s.join("")]&&n.push([r,o]);s[r]=0,n.length>0&&!1===o&&(o=[]),1===n.length&&o.push(n[0])}}!1!==o&&0===o.length&&(o=!0),e[t][r]=o})(r,e,t)))));let s=[];Array.from(Array(t+1)).map(((e,r)=>t-r)).forEach((e=>{const t=[];Object.keys(r[e]).forEach((s=>{let o=r[e][s];o.constructor===Array&&(o=o[0]),t.push([s,o])})),s=s.concat(t)})),s.sort(((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)));const o={};return s.forEach((e=>{o[e[0]]=Object.freeze(e[1])})),Object.freeze(o)},Jt={taco_taco:make_lookup(["111112","111121","111222","112111","121112","121222","122111","122212","211121","211222","212111","212221","221222","222111","222212","222221"]),taco_tortilla:make_lookup(["112","121","212","221"]),tortilla_tortilla:make_lookup(["11","22"]),transitivity:make_lookup(["112","121","122","211","212","221"])},Zt={taco_taco:e=>[[e[0],e[2]],[e[1],e[3]],[e[1],e[2]],[e[0],e[3]],[e[0],e[1]],[e[2],e[3]]],taco_tortilla:e=>[[e[0],e[2]],[e[0],e[1]],[e[1],e[2]]],tortilla_tortilla:e=>[[e[0],e[2]],[e[1],e[3]]],transitivity:e=>[[e[0],e[1]],[e[1],e[2]],[e[2],e[0]]]},pairArrayToSortedPairString=e=>e[0]<e[1]?`${e[0]} ${e[1]}`:`${e[1]} ${e[0]}`,Yt={taco_taco:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[0],e[3]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[2],e[3]])],taco_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]])],tortilla_tortilla:e=>[pairArrayToSortedPairString([e[0],e[2]]),pairArrayToSortedPairString([e[1],e[3]])],transitivity:e=>[pairArrayToSortedPairString([e[0],e[1]]),pairArrayToSortedPairString([e[1],e[2]]),pairArrayToSortedPairString([e[2],e[0]])]},Xt={0:0,1:1,2:-1},Kt=Object.freeze(Object.keys(Jt)),Qt={0:0,1:2,2:1},buildRuleAndLookup=(e,t,...r)=>{const s=Zt[e](t),o=s.map((e=>e[1]<e[0])),n=s.map(((e,t)=>o[t]?`${e[1]} ${e[0]}`:`${e[0]} ${e[1]}`)),a=n.map(((e,t)=>{for(let s=0;s<r.length;s+=1)if(r[s][e])return o[t]?Qt[r[s][e]]:r[s][e];return 0})).join("");if(!0===Jt[e][a])return!0;if(!1===Jt[e][a])return!1;const c=Jt[e][a];return[n[c[0]],o[c[0]]?Qt[c[1]]:c[1]]},getConstraintIndicesFromFacePairs=(e,t,r)=>{const s={};return Kt.forEach((o=>{const n=r.flatMap((e=>t[o][e]));s[o]=uniqueElements(n).filter((t=>e[o][t]))})),s},propagate=(e,t,r,...s)=>{let o=r;const n={};do{const r=getConstraintIndicesFromFacePairs(e,t,o),a={};for(let t=0;t<Kt.length;t+=1){const o=Kt[t],c=r[o];for(let t=0;t<c.length;t+=1){const r=buildRuleAndLookup(o,e[o][c[t]],...s,n);if(!0!==r){if(!1===r)return console.warn("invalid state found",o,e[o][c[t]]),!1;if(n[r[0]]){if(n[r[0]]!==r[1])return console.warn("order conflict",o,e[o][c[t]]),!1}else{const[e,t]=r;a[e]=!0,n[r[0]]=t}}}}o=Object.keys(a)}while(o.length);return n},getBranches=(e,t,r,s={})=>{const o=Object.keys(t),n={};e.forEach((e=>{n[e]=!0}));let a=0;const c=[];for(;a<e.length;){if(!n[e[a]]){a+=1;continue}const i=[],l=[e[a]],d={[e[a]]:!0};do{const e=l.shift();let a;if(delete n[e],i.push(e),s[e])a=s[e];else{const n={};o.forEach((s=>{const o=r[s][e];o&&o.map((e=>t[s][e])).map((e=>Yt[s](e).forEach((e=>{n[e]=!0}))))})),a=Object.keys(n),s[e]=a}const c=a.filter((e=>n[e])).filter((e=>!d[e]));l.push(...c),c.forEach((e=>{d[e]=!0}))}while(l.length);a+=1,c.push(i)}return c},makeTortillaTortillaFacesCrossing=(e,t,r)=>{const s=((e,t,r)=>{const s=makeFacesWinding(e),o=makeFacesPolygon(e,r);for(let e=0;e<o.length;e+=1)s[e]||o[e].reverse();const n=t.map((e=>2===e.length&&e[0]!==e[1])).map(((e,t)=>e?t:void 0)).filter((e=>void 0!==e)),a=n.map((t=>e.edges_vertices[t])).map((t=>t.map((t=>e.vertices_coords[t])))),c=a.map((e=>subtract2(e[1],e[0]))),i=[];return n.forEach((e=>{i[e]=[]})),n.map(((e,t)=>o.map((e=>clipLineConvexPolygon(e,{vector:c[t],origin:a[t][0]},exclude,excludeS,r))).map((e=>void 0!==e)))).forEach(((e,t)=>e.forEach(((e,r)=>{e&&i[n[t]].push(r)})))),i})(e,t,r);return s.map(((t,r)=>t.map((t=>[e.edges_faces[r],[t,t]])))).reduce(((e,t)=>e.concat(t)),[])},classify_faces_pair=e=>1===e[0]&&-1===e[1]||-1===e[0]&&1===e[1]?"both":1===e[0]&&1===e[1]?"right":-1===e[0]&&-1===e[1]?"left":void 0,makeTacosTortillas=(e,t=L)=>{const r=makeFacesConvexCenter(e),s=((e,t)=>{const r=e.edges_vertices.map((t=>e.vertices_coords[t[0]])),s=e.edges_vertices.map((t=>subtract2(e.vertices_coords[t[1]],e.vertices_coords[t[0]])));return e.edges_faces.map(((e,o)=>e.map((e=>cross2(subtract2(t[e],r[o]),s[o]))).map((e=>Math.sign(e)))))})(e,r),o=(e=>{const t=Array.from(Array(e.length)).map((()=>Array(e.length).fill(!1)));return e.forEach(((e,r)=>e.forEach((e=>{t[r][e]=!0})))),t})(makeEdgesEdgesParallelOverlap(e,t)),n=booleanMatrixToUniqueIndexPairs(o).filter((t=>t.map((t=>e.edges_faces[t].length>1)).reduce(((e,t)=>e&&t),!0))),a=n.map((t=>t.map((t=>e.edges_faces[t])))),c=((e,t,r,s)=>{const o=r.map((t=>e.edges_vertices[t[0]].map((t=>e.vertices_coords[t])))),n=o.map((e=>e[0])),a=o.map((e=>subtract2(e[1],e[0])));return s.map((e=>e.map((e=>e.map((e=>t[e])))))).map(((e,t)=>e.map((e=>e.map((e=>cross2(subtract2(e,n[t]),a[t]))).map((e=>Math.sign(e)))))))})(e,r,n,a),i=c.map((e=>e.map(classify_faces_pair))),l=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"!==r[0]?a[t]:void 0;var r})).filter((e=>void 0!==e)),d=i.map(((e,t)=>{return(r=e)[0]===r[1]&&"both"===r[0]?a[t]:void 0;var r})).map(((e,t)=>((e,t)=>{if(void 0!==e)return t[0][0]===t[1][0]?e:[e[0],[e[1][1],e[1][0]]]})(e,c[t]))).filter((e=>void 0!==e)),m=makeTortillaTortillaFacesCrossing(e,s,t),p=d.concat(m),g=i.map(((e,t)=>{return(r=e)[0]===r[1]||"both"!==r[0]&&"both"!==r[1]?void 0:((e,t,r)=>{const s="left"===t[0]||"left"===t[1]?-1:1,o="both"===t[0]?[...e[1]]:[...e[0]],n="both"===t[0]?0:1;return{taco:o,tortilla:r[n][0]===s?e[n][0]:e[n][1]}})(a[t],i[t],c[t]);var r})).filter((e=>void 0!==e)),u=makeEdgesFacesOverlap(e,t),v=booleanMatrixToIndexedArray(u).map(((e,t)=>s[t].length>1&&s[t][0]===s[t][1]?e:[])).map(((t,r)=>({taco:e.edges_faces[r],tortillas:t}))).filter((e=>e.tortillas.length)).flatMap((e=>e.tortillas.map((t=>({taco:[...e.taco],tortilla:t})))));return{taco_taco:l,tortilla_tortilla:p,taco_tortilla:g.concat(v)}},er={0:0,1:2,2:1},tr={M:1,m:1,V:2,v:2},prepare=(e,t=1e-6)=>{const r=getFacesFaces2DOverlap(e,t),s=makeFacesWinding(e),o=makeTacosTortillas(e,t),n=((e,t,r,s=L)=>{t||(t=getFacesFaces2DOverlap(e,s)),r||(r=makeFacesWinding(e));const o=e.faces_vertices.map((t=>t.map((t=>e.vertices_coords[t]))));o.forEach(((e,t)=>{r[t]||e.reverse()}));const n=e.faces_vertices.map((()=>[]));for(let e=0;e<n.length-1;e+=1)for(let r=e+1;r<n.length;r+=1){if(!t[e][r])continue;const a=clipPolygonPolygon(o[e],o[r],s);a&&(n[e][r]=a)}const a=[];for(let e=0;e<n.length-1;e+=1)for(let r=e+1;r<n.length;r+=1)if(n[e][r])for(let c=r+1;c<n.length;c+=1)e!==c&&r!==c&&t[e][c]&&t[r][c]&&clipPolygonPolygon(n[e][r],o[c],s)&&a.push([e,r,c].sort(((e,t)=>e-t)));return a})(e,r,s,t),a=((e,t)=>{const r={};return t.taco_taco.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]].sort(((e,t)=>e-t)))).forEach((e=>[`${e[0]} ${e[1]} ${e[2]}`,`${e[0]} ${e[1]} ${e[3]}`,`${e[0]} ${e[2]} ${e[3]}`,`${e[1]} ${e[2]} ${e[3]}`].forEach((e=>{r[e]=!0})))),t.taco_tortilla.map((e=>[e.taco[0],e.taco[1],e.tortilla].sort(((e,t)=>e-t)).join(" "))).forEach((e=>{r[e]=!0})),e.filter((e=>void 0===r[e.join(" ")]))})(n,o),c=((e,t)=>{const r={};return r.taco_taco=e.taco_taco.map((e=>[e[0][0],e[1][0],e[0][1],e[1][1]])),r.taco_tortilla=e.taco_tortilla.map((e=>[e.taco[0],e.tortilla,e.taco[1]])),r.tortilla_tortilla=e.tortilla_tortilla.map((e=>[e[0][0],e[0][1],e[1][0],e[1][1]])),r.transitivity=t.map((e=>[e[0],e[1],e[2]])),r})(o,a),i=(e=>{const t={};return Object.keys(e).forEach((e=>{t[e]={}})),Object.keys(e).forEach((r=>{e[r].forEach(((e,s)=>Yt[r](e).forEach((e=>{void 0===t[r][e]&&(t[r][e]=[]),t[r][e].push(s)}))))})),t})(c),l=((e,t)=>(t||(t=getFacesFaces2DOverlap(e)),booleanMatrixToUniqueIndexPairs(t).map((e=>e.join(" ")))))(e,r),d=((e,t,r)=>{r||(r=makeFacesWinding(e));const s={};t.forEach((e=>{s[e]=!0}));const o={};return e.edges_faces.forEach(((t,n)=>{const a=e.edges_assignment[n],c=tr[a];if(t.length<2||void 0===c)return;const i=r[t[0]]?c:er[c],l=`${t[0]} ${t[1]}`,d=`${t[1]} ${t[0]}`;l in s&&(o[l]=i),d in s&&(o[d]=er[i])})),o})(e,l,s);return console.log("overlap",r),console.log("graph",e),console.log("facesWinding",s),console.log("tacos_tortillas",o),console.log("unfiltered_trios",n),console.log("transitivity_trios",a),console.log("facePairs",l),console.log("constraints",c),console.log("constraintsLookup",i),console.log("edgeAdjacentOrders",d),{constraints:c,constraintsLookup:i,facePairs:l,edgeAdjacentOrders:d}},rr={allSolutions:function(){return(e=>{const recurse=(e,t=[])=>{e.faceOrders&&t.push(e.faceOrders);const r=e.finished?e.finished.map((e=>[...t,e.faceOrders])):void 0;if(e.unfinished){const s=e.unfinished.map((e=>recurse(e,JSON.parse(JSON.stringify(t))))),o=s.length>1?((e,t)=>{const r=[];for(let s=0;s<e.length;s+=1)for(let o=0;o<t.length;o+=1)r.push([e[s],t[o]]);return r})(...s):s;o.forEach((e=>{e.branch=!0})),r.forEach((e=>e.push(...o)))}return r.finished=!0,r};return recurse(e)})(this)}},solveBranch=(e,t,r,s,o,...n)=>{if(!s.length)return[];const a=s[0],c=[],i=[];[1,2].forEach((r=>{const o=propagate(e,t,[a],...n,{[a]:r});!1!==o&&(o[a]=r,Object.keys(o).length===s.length?c.push(o):i.push(o))}));const l=i.map((e=>({faceOrders:e}))),d=i.map(((o,a)=>{const c=s.filter((e=>!(e in o)));return getBranches(c,e,t,r).map((s=>solveBranch(e,t,r,s,l[a],...n,o)))}));return c.length&&(o.finished=c.map((e=>({faceOrders:e})))),l.length&&(o.unfinished=l),l.length>1&&c.length&&console.log("HAPPENED"),c.map((e=>[...n,e])).concat(...d)};var sr=Object.assign(Object.create(null),{solver:(e,t=1e-6)=>{const{constraints:r,constraintsLookup:s,facePairs:o,edgeAdjacentOrders:n,faces_winding:a}=prepare$1(e,t),c=((e,t,r,s,o)=>{const n=propagate$1(e,t,Object.keys(s),s);if(!n)return;const a=r.filter((e=>!(e in s))).filter((e=>!(e in n))),c=solveNode(e,t,a,[],s,n);return reformatSolution(c,o)})(r,s,o,n,a);return Object.assign(Object.create(Ht),c)},solver2d:(e,t=1e-6)=>{const r=new Date,{constraints:s,constraintsLookup:o,facePairs:n,edgeAdjacentOrders:a}=prepare(e,t),c=Date.now()-r,i=new Date,l=propagate(s,o,Object.keys(a),a);if(!l)return;console.log("2D initialResult",JSON.parse(JSON.stringify(l)));const d={},m=n.filter((e=>!(e in a))).filter((e=>!(e in l))),p={},g=getBranches(m,s,o,p);console.log("branches",g);const u=g.map((()=>({}))),v=g.map(((e,t)=>solveBranch(s,o,p,e,u[t],a,l)));u.length&&(d.unfinished=u),d.faceOrders={...a,...l},console.log("2D solution",JSON.parse(JSON.stringify(d.faceOrders)));const h=e.faces_normal?e.faces_normal:makeFacesNormal(e),_=[0,0,1],recurse=e=>{e.faceOrders&&(e.faceOrders=((e,t,r)=>{const s=t.map((e=>dot(e,r)>0)),o=Object.keys(e),n=o.map((e=>e.split(" ").map((e=>parseInt(e,10)))));return n.forEach(((t,r)=>{const n=Xt[e[o[r]]],a=s[t[1]]?n:-n;t.push(a)})),n})(e.faceOrders,h,_)),e.finished&&e.finished.forEach((e=>recurse(e))),e.unfinished&&e.unfinished.forEach((e=>recurse(e)))};recurse(d),console.log("2D solution final",JSON.parse(JSON.stringify(d.faceOrders)));const b=Date.now()-i;return console.log(`prep ${c}ms solver ${b}ms`),console.log("solution",d),console.log("branches",v),Object.assign(Object.create(rr),d)},topologicalOrder:(e,t)=>{if(!e)return[];const r=[];Object.keys(e).forEach((t=>{const s=t.split(" ").map((e=>parseInt(e,10)));-1===e[t]&&s.reverse(),void 0===r[s[0]]&&(r[s[0]]=[]),r[s[0]].push(s[1])})),t&&t.faces_vertices&&t.faces_vertices.forEach(((e,t)=>{void 0===r[t]&&(r[t]=[])}));const s=[],o=[];let n=0;for(let e=0;e<r.length;e+=1){if(o[e])continue;const t=[e];for(;t.length&&n<2*r.length;){const e=t[t.length-1];if(r[e]&&r[e].length){const s=r[e].pop();o[s]||t.push(s)}else s.push(e),o[e]=!0,t.pop(),n+=1}}return n>=2*r.length&&console.warn("fix protection in topological order"),s},singleVertexSolver:singleVertexSolver,singleVertexAssignmentSolver:(e,t,r)=>{null==t&&(t=e.map((()=>"U")));const s=maekawaAssignments(t),o=s.map((t=>singleVertexSolver(e,t,r)));return s.map(((e,t)=>t)).filter((e=>o[e].length>0)).map((e=>({assignment:s[e],layer:o[e]})))},foldStripWithAssignments:foldStripWithAssignments},zt,$t);var or=Object.freeze({__proto__:null,kawasakiSolutions:({vertices_coords:e,vertices_edges:t,edges_vertices:r,edges_vectors:s},o)=>{s||(s=makeEdgesVector({vertices_coords:e,edges_vertices:r})),t||(t=makeVerticesEdgesUnsorted({edges_vertices:r}));const n=t[o].map((e=>s[e])),a=counterClockwiseOrder2(n).map((e=>n[e]));return kawasakiSolutionsVectors(a)}}),nr=Object.assign(Object.create(null),{maekawaAssignments:maekawaAssignments,foldAngles4:(e,t,r=0)=>{const s=(e=>{let t=0,r=0;for(let s=0;s<e.length;s+=1)"M"!==e[s]&&"m"!==e[s]||(t+=1),"V"!==e[s]&&"v"!==e[s]||(r+=1);for(let s=0;s<e.length;s+=1){if(t>r&&("V"===e[s]||"v"===e[s]))return s;if(r>t&&("M"===e[s]||"m"===e[s]))return s}})(t);if(void 0===s)return;const o=e[(s+1)%e.length],n=e[(s+2)%e.length],a=Math.PI*r,c=-Math.cos(o)*Math.cos(n)+Math.sin(o)*Math.sin(n)*Math.cos(Math.PI-a),i=Math.cos(Math.PI-a)-Math.sin(Math.PI-a)**2*Math.sin(o)*Math.sin(n)/(1-c),l=-Math.acos(i)+Math.PI;return s%2==0?[l,a,l,a].map(((e,t)=>s===t?-e:e)):[a,l,a,l].map(((e,t)=>s===t?-e:e))}},Ye,or,et),ar={axioms:{ar:[null,"   ","        ","        ","          ","         ","            ","          "],de:[null,"Falte eine Linie durch zwei Punkte","Falte zwei Punkte aufeinander","Falte zwei Linien aufeinander","Falte eine Linie auf sich selbst, falte dabei durch einen Punkt","Falte einen Punkt auf eine Linie, falte dabei durch einen anderen Punkt","Falte einen Punkt auf eine Linie und einen weiteren Punkt auf eine weitere Linie","Falte einen Punkt auf eine Linie und eine weitere Linie in sich selbst zusammen"],en:[null,"fold a line through two points","fold two points together","fold two lines together","fold a line on top of itself, creasing through a point","fold a point to a line, creasing through another point","fold a point to a line and another point to another line","fold a point to a line and another line onto itself"],es:[null,"dobla una lnea entre dos puntos","dobla dos puntos juntos","dobla y une dos lneas","dobla una lnea sobre s misma, doblndola hacia un punto","dobla un punto hasta una lnea, doblndola a travs de otro punto","dobla un punto hacia una lnea y otro punto hacia otra lnea","dobla un punto hacia una lnea y otra lnea sobre s misma"],fr:[null,"crez un pli passant par deux points","pliez pour superposer deux points","pliez pour superposer deux lignes","rabattez une ligne sur elle-mme  l'aide d'un pli qui passe par un point","rabattez un point sur une ligne  l'aide d'un pli qui passe par un autre point","rabattez un point sur une ligne et un autre point sur une autre ligne","rabattez un point sur une ligne et une autre ligne sur elle-mme"],hi:[null,"        ","         ","        ","                  ","                 ","                   ","                      "],jp:[null,"2","2","2","","","",""],ko:[null,"    ","   ","   ","      ","  ,    ","       ","       "],ms:[null,"lipat garisan melalui dua titik","lipat dua titik bersama","lipat dua garisan bersama","lipat satu garisan di atasnya sendiri, melipat melalui satu titik","lipat satu titik ke garisan, melipat melalui titik lain","lipat satu titik ke garisan dan satu lagi titik ke garisan lain","lipat satu titik ke garisan dan satu lagi garisan di atasnya sendiri"],pt:[null,"dobre uma linha entre dois pontos","dobre os dois pontos para uni-los","dobre as duas linhas para uni-las","dobre uma linha sobre si mesma, criando uma dobra ao longo de um ponto","dobre um ponto at uma linha, criando uma dobra ao longo de outro ponto","dobre um ponto at uma linha e outro ponto at outra linha","dobre um ponto at uma linha e outra linha sobre si mesma"],ru:[null,"    ","   ","   ","   ,   ","   ,    ","         ","        "],tr:[null,"iki noktadan geen bir izgi boyunca katla","iki noktay birbirine katla","iki izgiyi birbirine katla","bir noktadan kvrarak kendi zerindeki bir izgi boyunca katla","baka bir noktadan kvrarak bir noktay bir izgiye katla","bir noktay bir izgiye ve baka bir noktay baka bir izgiye katla","bir noktay bir izgiye ve baka bir izgiyi kendi zerine katla"],vi:[null,"to mt np gp i qua hai im","to np gp bng cch gp mt im ny sang im khc","to np gp bng cch gp mt ng ln mt ng khc","to mt np gp i qua mt im v a mt ng ln trn chnh n","to mt np gp i qua im u tin v a im th hai ln ng thng","to mt np gp mang im u tin n ng u tin v im th hai cho ng th hai","to mt np gp mang li mt im cho mt ng v a mt ng th hai ln trn chnh n"],zh:[null,"","","","","","",""]},instructions:{fold:{es:"doblez"},"valley fold":{es:"doblez de valle",zh:""},"mountain fold":{es:"doblez de montaa",zh:""},"inside reverse fold":{zh:""},"outside reverse fold":{zh:""},sink:{},"open sink":{zh:""},"closed sink":{zh:""},"rabbit ear":{zh:""},"double rabbit ear":{zh:""},"petal fold":{zh:""},blintz:{zh:""},squash:{zh:""},"flip over":{es:"dale la vuelta a tu papel"}}};const pairify=e=>e.map(((e,t,r)=>[e,r[(t+1)%r.length]])),getContainingValue=(e,t)=>Array.from(e.children).filter((e=>e.attributes.length&&void 0!==Array.from(e.attributes).filter((e=>e.nodeValue===t)).shift())).shift(),cr={children:[{textContent:"0"}]},ir=["F","B","M","V","U"],setMetadata=(e,t)=>{const r={file_description:"memo",file_author:"originalAuthorName",file_title:"title"};Object.keys(r).forEach((t=>{r[t]=((e,t)=>{const r=getContainingValue(e,t),s=r?Array.from(r.children).shift():null;return s?s.textContent:void 0})(e,r[t])})),Object.keys(r).filter((e=>r[e])).forEach((e=>{t[e]=r[e]})),t.file_classes=["singleModel"],t.frame_classes=["creasePattern"]},flattenDomTree=e=>null!=e.children&&e.children.length?Array.from(e.children).flatMap((e=>flattenDomTree(e))):[e],getAttributeValue=(e,t,r,s=[])=>{const o=r.style?r.style.match(new RegExp(`${e}[\\s]*:[^;]*;`)):null;if(o)return o[0].split(":")[1].replace(";","");const n=((e,t,r,s=[])=>{const o=r.class?r.class.split(/\s/).filter(Boolean).map((e=>e.trim())).map((e=>`.${e}`)):[],n=r.id?`#${r.id}`:null;if(n)for(let t=0;t<s.length;t+=1)if(s[t][n]&&s[t][n][e])return s[t][n][e];for(let r=0;r<s.length;r+=1){for(let t=0;t<o.length;t+=1)if(s[r][o[t]]&&s[r][o[t]][e])return s[r][o[t]][e];if(s[r][t]&&s[r][t][e])return s[r][t][e]}})(e,t,r,s);return void 0!==n?n:r[e]?r[e]:null};var lr={line:{x1:1,y1:1,x2:1,y2:1},rect:{x:1,y:1,width:1,height:1},circle:{cx:1,cy:1,r:1},ellipse:{cx:1,cy:1,rx:1,ry:1},polygon:{points:1},polyline:{points:1},path:{d:1}};const getAttributesFloatValue=(e,t)=>t.map((t=>e.getAttribute(t))).map((e=>null==e?"0":e)).map(parseFloat),PolygonToSegments=e=>(e=>{const t=e.split(/[\s,]+/).map((e=>parseFloat(e)));return Array.from(Array(Math.floor(t.length/2))).map(((e,r)=>[t[2*r+0],t[2*r+1]]))})(e.getAttribute("points")||"").map(((e,t,r)=>[r[t][0],r[t][1],r[(t+1)%r.length][0],r[(t+1)%r.length][1]])),fr={L:!0,V:!0,H:!0,Z:!0},dr={line:e=>[getAttributesFloatValue(e,["x1","y1","x2","y2"])],rect:function(e){const[t,r,s,o]=getAttributesFloatValue(e,["x","y","width","height"]);return[[t,r,t+s,r],[t+s,r,t+s,r+o],[t+s,r+o,t,r+o],[t,r+o,t,r]]},polygon:PolygonToSegments,polyline:function(e){const t=PolygonToSegments(e);return t.pop(),t},path:e=>T.svg.core.parsePathCommandsEndpoints(e.getAttribute("d")||"").filter((e=>fr[e.command.toUpperCase()])).map((e=>[e.start,e.end])).filter((e=>!fnEpsilonEqualVectors(...e))).map((e=>e.flat()))};var mr={black:"#000000",silver:"#c0c0c0",gray:"#808080",white:"#ffffff",maroon:"#800000",red:"#ff0000",purple:"#800080",fuchsia:"#ff00ff",green:"#008000",lime:"#00ff00",olive:"#808000",yellow:"#ffff00",navy:"#000080",blue:"#0000ff",teal:"#008080",aqua:"#00ffff",orange:"#ffa500",aliceblue:"#f0f8ff",antiquewhite:"#faebd7",aquamarine:"#7fffd4",azure:"#f0ffff",beige:"#f5f5dc",bisque:"#ffe4c4",blanchedalmond:"#ffebcd",blueviolet:"#8a2be2",brown:"#a52a2a",burlywood:"#deb887",cadetblue:"#5f9ea0",chartreuse:"#7fff00",chocolate:"#d2691e",coral:"#ff7f50",cornflowerblue:"#6495ed",cornsilk:"#fff8dc",crimson:"#dc143c",cyan:"#00ffff",darkblue:"#00008b",darkcyan:"#008b8b",darkgoldenrod:"#b8860b",darkgray:"#a9a9a9",darkgreen:"#006400",darkgrey:"#a9a9a9",darkkhaki:"#bdb76b",darkmagenta:"#8b008b",darkolivegreen:"#556b2f",darkorange:"#ff8c00",darkorchid:"#9932cc",darkred:"#8b0000",darksalmon:"#e9967a",darkseagreen:"#8fbc8f",darkslateblue:"#483d8b",darkslategray:"#2f4f4f",darkslategrey:"#2f4f4f",darkturquoise:"#00ced1",darkviolet:"#9400d3",deeppink:"#ff1493",deepskyblue:"#00bfff",dimgray:"#696969",dimgrey:"#696969",dodgerblue:"#1e90ff",firebrick:"#b22222",floralwhite:"#fffaf0",forestgreen:"#228b22",gainsboro:"#dcdcdc",ghostwhite:"#f8f8ff",gold:"#ffd700",goldenrod:"#daa520",greenyellow:"#adff2f",grey:"#808080",honeydew:"#f0fff0",hotpink:"#ff69b4",indianred:"#cd5c5c",indigo:"#4b0082",ivory:"#fffff0",khaki:"#f0e68c",lavender:"#e6e6fa",lavenderblush:"#fff0f5",lawngreen:"#7cfc00",lemonchiffon:"#fffacd",lightblue:"#add8e6",lightcoral:"#f08080",lightcyan:"#e0ffff",lightgoldenrodyellow:"#fafad2",lightgray:"#d3d3d3",lightgreen:"#90ee90",lightgrey:"#d3d3d3",lightpink:"#ffb6c1",lightsalmon:"#ffa07a",lightseagreen:"#20b2aa",lightskyblue:"#87cefa",lightslategray:"#778899",lightslategrey:"#778899",lightsteelblue:"#b0c4de",lightyellow:"#ffffe0",limegreen:"#32cd32",linen:"#faf0e6",magenta:"#ff00ff",mediumaquamarine:"#66cdaa",mediumblue:"#0000cd",mediumorchid:"#ba55d3",mediumpurple:"#9370db",mediumseagreen:"#3cb371",mediumslateblue:"#7b68ee",mediumspringgreen:"#00fa9a",mediumturquoise:"#48d1cc",mediumvioletred:"#c71585",midnightblue:"#191970",mintcream:"#f5fffa",mistyrose:"#ffe4e1",moccasin:"#ffe4b5",navajowhite:"#ffdead",oldlace:"#fdf5e6",olivedrab:"#6b8e23",orangered:"#ff4500",orchid:"#da70d6",palegoldenrod:"#eee8aa",palegreen:"#98fb98",paleturquoise:"#afeeee",palevioletred:"#db7093",papayawhip:"#ffefd5",peachpuff:"#ffdab9",peru:"#cd853f",pink:"#ffc0cb",plum:"#dda0dd",powderblue:"#b0e0e6",rosybrown:"#bc8f8f",royalblue:"#4169e1",saddlebrown:"#8b4513",salmon:"#fa8072",sandybrown:"#f4a460",seagreen:"#2e8b57",seashell:"#fff5ee",sienna:"#a0522d",skyblue:"#87ceeb",slateblue:"#6a5acd",slategray:"#708090",slategrey:"#708090",snow:"#fffafa",springgreen:"#00ff7f",steelblue:"#4682b4",tan:"#d2b48c",thistle:"#d8bfd8",tomato:"#ff6347",turquoise:"#40e0d0",violet:"#ee82ee",wheat:"#f5deb3",whitesmoke:"#f5f5f5",yellowgreen:"#9acd32"};const hexToRGB=e=>{const t=e.replace(/#(?=\S)/g,""),r=Array.from(Array(6)).map(((e,r)=>t[r]||"0")),s=t.length<=4?[0,0,1,1,2,2].map((e=>r[e])).join(""):r.join(""),o=parseInt(s,16);return[o>>16&255,o>>8&255,255&o].map((e=>e/255))},parseCSSColor=e=>{if(mr[e])return hexToRGB(mr[e]);if("#"===e[0])return hexToRGB(e);if("rgba"===e.substring(0,4)||"rgb"===e.substring(0,3)){const t=(e=>{const t=e.match(/\(([^\)]+)\)/g);if(null!=t&&t.length)return t[0].substring(1,t[0].length-1).split(/[\s,]+/).map(parseFloat)})(e);return[0,1,2].forEach(((e,r)=>{t[r]/=255})),t}return[0,0,0]},pr={M:[1,0,0],V:[0,0,1],F:[1,1,0],U:[1,0,1],C:[0,1,0]},parseCSSStyleSheet=e=>{if(!e.cssRules)return{};const t={};for(let r=0;r<e.cssRules.length;r+=1){const s=e.cssRules[r];if(1!==s.type)continue;const o=s.selectorText.split(/,/gm).filter(Boolean).map((e=>e.trim())),n={};Object.values(s.style).forEach((e=>{n[e]=s.style[e]})),o.forEach((e=>{t[e]=n}))}return t},parseStyleElement=e=>{if(e.sheet)return parseCSSStyleSheet(e.sheet);if(!((e=>{let t=e;for(;null!=t.parentNode;)t=t.parentNode;return t})(e).constructor===RabbitEarWindow().HTMLDocument)){const t=e.parentNode;null!=t&&t.removeChild(e);const r=null!=RabbitEarWindow().document.body?RabbitEarWindow().document.body:RabbitEarWindow().document.createElement("body");r.appendChild(e);const s=parseCSSStyleSheet(e.sheet);return r.removeChild(e),null!=t&&t.appendChild(e),s}return{}},objectifyAttributeList=function(e){const t={};return e.forEach((e=>{t[e.nodeName]=e.value})),t},svgToBasicGraph=e=>{const t="string"==typeof e?((e,t="text/xml")=>(new(RabbitEarWindow().DOMParser)).parseFromString(e,t).documentElement)(e,"image/svg+xml"):e,r=flattenDomTree(t),s=r.filter((e=>"style"===e.nodeName)).map(parseStyleElement),o=(e=>e.filter((e=>dr[e.tagName])).flatMap((e=>dr[e.tagName](e).map((t=>{return{nodeName:e.tagName,segment:t,attributes:objectifyAttributeList((r=e,Array.from(r.attributes).filter((e=>!lr[r.nodeName][e.nodeName]))))};var r})))))(r),n=o.map((e=>getAttributeValue("stroke",e.nodeName,e.attributes,s)||"black")).map((e=>(e=>{if(null==e||"string"!=typeof e)return"U";const t=parseCSSColor(e).slice(0,3),r=t.reduce(((e,t)=>e+t),0)/3,s="F",o=distance3(t,[r,r,r]),n=Object.keys(pr).map((e=>({key:e,distance:distance3(t,pr[e])}))).sort(((e,t)=>e.distance-t.distance)).shift();return o<n.distance?s:n.key})(e))),a=o.map((e=>getAttributeValue("opacity",e.nodeName,e.attributes,s)||"1")).map(((e,t)=>((e,t)=>{switch(t){case"M":case"m":return-180*e;case"V":case"v":return 180*e;default:return 0}})(e,n[t])));return{vertices_coords:o.map((e=>e.segment)).flatMap((e=>[[e[0],e[1]],[e[2],e[3]]])),edges_vertices:o.map(((e,t)=>[2*t,2*t+1])),edges_assignment:n,edges_foldAngle:a}};var gr={objToFold:e=>{const t=e.split("\n").map((e=>e.trim().split(/\s+/))),r=(()=>{const e={};return e.file_spec=pt,e.file_creator=gt,e.file_classes=["singleModel"],e.frame_classes=[],e.frame_attributes=[],e.vertices_coords=[],e.faces_vertices=[],e})();for(let e=0;e<t.length;e+=1)switch(t[e][0].toLowerCase()){case"f":r.faces_vertices.push(t[e].slice(1).map((e=>parseInt(e,10)-1)));break;case"v":r.vertices_coords.push(t[e].slice(1).map((e=>parseFloat(e))))}return r.faces_normal=makeFacesNormal(r),r.faces_center=makeFacesConvexCenter(r),r.edges_vertices=(({faces_vertices:e})=>{const t={},r=[];return e.flatMap(pairify).forEach((e=>{const s=[e.join(" "),`${e[1]} ${e[0]}`];s[0]in t||s[1]in t||(r.push(e),t[s[0]]=!0)})),r})(r),r.faces_edges=makeFacesEdgesFromVertices(r),r.edges_faces=makeEdgesFacesUnsorted(r),r.edges_foldAngle=makeEdgesFoldAngleFromFaces(r),r.edges_assignment=makeEdgesAssignment(r),r.vertices_vertices=makeVerticesVerticesFromFaces(r),delete r.faces_normal,delete r.faces_center,delete r.edges_faces,(e=>{if(!e.edges_foldAngle||!e.edges_foldAngle.length)return;let t=!0;for(let r=0;r<e.edges_foldAngle.length;r+=1)if(0!==e.edges_foldAngle[r]&&-180!==e.edges_foldAngle[r]&&180!==e.edges_foldAngle[r]){t=!1;break}e.frame_classes.push(t?"creasePattern":"foldedForm"),e.frame_attributes.push(t?"2D":"3D")})(r),r},opxToFold:(e,t)=>{try{const r=(new(RabbitEarWindow().DOMParser)).parseFromString(e,"text/xml"),s=Array.from(r.documentElement.children).filter((e=>Array.from(e.classList).includes("oripa.DataSet"))).shift(),o=((e,t)=>{const r={};if(r.vertices_coords=e.flatMap((e=>[[e[1],e[3]],[e[2],e[4]]])),r.edges_vertices=e.map(((e,t)=>[2*t,2*t+1])),r.edges_assignment=e.map((e=>ir[e[0]])),r.edges_foldAngle=makeEdgesFoldAngle(r),void 0===t){const{span:e}=boundingBox$1(r.vertices_coords);t=1e-6*Math.min(...e)}removeDuplicateVertices(r,t),r.vertices_vertices=makeVerticesVertices(r);const s=makePlanarFaces(r);return r.faces_vertices=s.map((e=>e.vertices)),r.faces_edges=s.map((e=>e.edges)),r})((e=>e.map((e=>{const t=Array.from(e.children[0].children);return["type","x0","x1","y0","y1"].map((e=>parseFloat((t.filter((t=>t.attributes[0].nodeValue===e)).shift()||cr).children[0].textContent)))})))((e=>{const t=getContainingValue(e,"lines"),r=t?Array.from(t.children).filter((e=>"oripa.OriLineProxy"===e.className)).shift():void 0;return r?Array.from(r.children):[]})(s)),t);return setMetadata(s,o),o}catch(e){console.error(e)}},svgToFold:e=>{const t=(e=>{const t={...e};removeDuplicateVertices(t),fragment(t),t.vertices_vertices=makeVerticesVertices(t);const r=makePlanarFaces(t);t.faces_vertices=r.map((e=>e.vertices)),t.faces_edges=r.map((e=>e.edges));const{edges:s}=planarBoundary(t);return s.forEach((e=>{t.edges_assignment[e]="B"})),t})(svgToBasicGraph(e));return{file_spec:1.1,file_creator:"Rabbit Ear",frame_classes:["creasePattern"],...t}}};const addClassToClassList=(e,...t)=>{if(!e)return;const r={},s=e.getAttribute("class"),o=s?s.split(" "):[];o.push(...t),o.forEach((e=>{r[e]=!0}));const n=Object.keys(r).join(" ");e.setAttribute("class",n)},ur={},vr={stroke:b},hr={},_r={M:{stroke:"red"},m:{stroke:"red"},V:{stroke:"blue"},v:{stroke:"blue"},F:{stroke:"lightgray"},f:{stroke:"lightgray"}},edgesPathData=e=>(({vertices_coords:e,edges_vertices:t})=>e&&t?t.map((t=>t.map((t=>e[t])))):[])(e).map((e=>{return`M${(t=e)[0][0]} ${t[0][1]}L${t[1][0]} ${t[1][1]}`;var t})).join(""),edgesPathDataAssign=({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{if(!e||!t)return{};if(!r)return{u:edgesPathData({vertices_coords:e,edges_vertices:t})};const s=(e=>{const t={u:[],f:[],v:[],m:[],b:[]},r=e[m].map((e=>e.toLowerCase()));return e[l].map(((e,t)=>r[t]||"u")).forEach(((e,r)=>t[e].push(r))),t})({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(s).forEach((r=>{s[r]=edgesPathData({vertices_coords:e,edges_vertices:s[r].map((e=>t[e]))})})),Object.keys(s).forEach((e=>{""===s[e]&&delete s[e]})),s},applyEdgesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),edgesPaths=(e,t={})=>{const r=T.svg.g();if(!e)return r;const s=isFoldedForm(e),o=(({vertices_coords:e,edges_vertices:t,edges_assignment:r})=>{const s=edgesPathDataAssign({vertices_coords:e,edges_vertices:t,edges_assignment:r});return Object.keys(s).forEach((e=>{const t=T.svg.path(s[e]);addClassToClassList(t,fe[e]),s[e]=t})),s})(e);return Object.keys(o).forEach((e=>{addClassToClassList(o[e],fe[e]),applyEdgesStyle(o[e],s?hr[e]:_r[e]),applyEdgesStyle(o[e],t[e]),applyEdgesStyle(o[e],t[fe[e]]),r.appendChild(o[e]),Object.defineProperty(r,fe[e],{get:()=>o[e]})})),applyEdgesStyle(r,s?ur:vr),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},edgesLines=(e,t={})=>{const r=T.svg.g();if(!e)return r;const s=isFoldedForm(e),o=(e.edges_assignment?e.edges_assignment:makeEdgesAssignment(e)).map((e=>e.toLowerCase())),n={};["b","m","v","f","u"].forEach((e=>{const o=T.svg.g();r.appendChild(o),addClassToClassList(o,fe[e]),applyEdgesStyle(o,s?hr[e]:_r[e]),applyEdgesStyle(o,t[fe[e]]),Object.defineProperty(r,fe[e],{get:()=>o}),n[e]=o}));const a=e.edges_vertices.map((t=>t.map((t=>e.vertices_coords[t])))).map((e=>T.svg.line(e[0][0],e[0][1],e[1][0],e[1][1])));return e.edges_foldAngle&&a.forEach(((t,r)=>{const s=e.edges_foldAngle[r];var o;0!==s&&180!==s&&-180!==s&&t.setAttributeNS(null,"opacity",(o=s,Math.abs(o)/180))})),a.forEach(((e,t)=>n[o[t]].appendChild(e))),applyEdgesStyle(r,s?ur:vr),applyEdgesStyle(r,t.stroke?{stroke:t.stroke}:{}),r},br={back:{fill:y},front:{fill:"#ddd"}},yr={back:{opacity:.1},front:{opacity:.1}},Er={},Ar={stroke:b,"stroke-linejoin":"bevel"},kr={stroke:E,fill:b,"stroke-linejoin":"bevel"},xr={fill:E},applyFacesStyle=(e,t={})=>Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r]))),finalize_faces=(e,t,r,s)=>{const o=isFoldedForm(e),n=null!=e[g],a=[[v],[h]],c=makeFacesWinding(e);c.map((e=>e?a[0]:a[1])).forEach(((e,r)=>{addClassToClassList(t[r],e),applyFacesStyle(t[r],o?n?br[e]:yr[e]:Er[e]),applyFacesStyle(t[r],s[e])}));const i=n?function(e,t){const r=t.faces_vertices.length||t.faces_edges.length;return Array.from(Array(r)).map(((e,t)=>t)).filter((t=>null==e[t])).concat(invertMap(e))}(e[g],e).map((e=>t[e])):t;return i.forEach((e=>r.appendChild(e))),Object.defineProperty(r,v,{get:()=>t.filter(((e,t)=>c[t]))}),Object.defineProperty(r,h,{get:()=>t.filter(((e,t)=>!c[t]))}),applyFacesStyle(r,o?n?Ar:kr:xr),r},Or={fill:E},Mr={stroke:b,fill:y},wr={vertices:(e,t={})=>{const r=T.svg.g();return e&&e.vertices_coords?(e.vertices_coords.map((e=>T.svg.circle(e[0],e[1],.01))).forEach((e=>r.appendChild(e))),r.setAttributeNS(null,"fill",E),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r):r},edges:(e,t)=>edgesFoldAngleAreAllFlat(e)?edgesPaths(e,t):edgesLines(e,t),faces:(e,t)=>e&&e.faces_vertices?((e,t={})=>{const r=T.svg.g();if(!e||!e.vertices_coords||!e.faces_vertices)return r;const o=e.faces_vertices.map((t=>t.map((t=>[0,1].map((r=>e.vertices_coords[t][r])))))).map((e=>T.svg.polygon(e)));return o.forEach(((e,t)=>e.setAttributeNS(null,s,t))),r.setAttributeNS(null,"fill",y),finalize_faces(e,o,r,t)})(e,t):e&&e[d]?function(e,t={}){const r=T.svg.g();if(!e||d in e==0||l in e==0||i in e==0)return r;const o=e[d].map((t=>t.map((t=>e[l][t])).map(((e,t,r)=>{const s=r[(t+1)%r.length];return e[1]===s[0]||e[1]===s[1]?e[0]:e[1]})).map((t=>[0,1].map((r=>e[i][t][r])))))).map((e=>T.svg.polygon(e)));return o.forEach(((e,t)=>e.setAttributeNS(null,s,t))),r.setAttributeNS(null,"fill","white"),finalize_faces(e,o,r,t)}(e,t):T.svg.g(),boundaries:(e,t={})=>{const r=T.svg.g();if(!(e&&e.vertices_coords&&e.edges_vertices&&e.edges_assignment))return r;const s=boundary(e).vertices.map((t=>[0,1].map((r=>e.vertices_coords[t][r]))));if(0===s.length)return r;const o=T.svg.polygon(s);return addClassToClassList(o,u),r.appendChild(o),((e,t={})=>{Object.keys(t).forEach((r=>e.setAttributeNS(null,r,t[r])))})(r,isFoldedForm(e)?Or:Mr),Object.keys(t).forEach((e=>r.setAttributeNS(null,e,t[e]))),r}},drawGroup=(e,t,r)=>{const s=!1===r?T.svg.g():wr[e](t,r);return addClassToClassList(s,e),s},DrawGroups=(e,t={})=>[c,a,n,o].map((r=>drawGroup(r,e,t[r])));[c,a,n,o].forEach((e=>{DrawGroups[e]=function(t,r={}){return drawGroup(e,t,r[e])}}));const getBoundingRect=({vertices_coords:e})=>{if(null==e||0===e.length)return;const t=Array(2).fill(1/0),r=Array(2).fill(-1/0);e.forEach((e=>{e[0]<t[0]&&(t[0]=e[0]),e[0]>r[0]&&(r[0]=e[0]),e[1]<t[1]&&(t[1]=e[1]),e[1]>r[1]&&(r[1]=e[1])}));return Number.isNaN(t[0])||Number.isNaN(t[1])||Number.isNaN(r[0])||Number.isNaN(r[1])?void 0:[t[0],t[1],r[0]-t[0],r[1]-t[1]]},findSVGInParents=e=>"SVG"===(e.nodeName||"").toUpperCase()?e:e.parentNode?findSVGInParents(e.parentNode):void 0,applyTopLevelOptions=(e,t,r,s)=>{const o=t[3]&&t[3].childNodes.length;if(!(s.strokeWidth||s.viewBox||o))return;const n=getBoundingRect(r),a=n?Math.max(n[2],n[3]):1,c=findSVGInParents(e);if(c&&s.viewBox){const e=n?n.join(" "):"0 0 1 1";c.setAttributeNS(null,"viewBox",e)}if(c&&s.padding){const e=c.getAttribute("viewBox");if(null!=e){const t=s.padding*a,r=e.split(" ").map((e=>parseFloat(e))),o=[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e)).join(" ");c.setAttributeNS(null,"viewBox",o)}}if(s.strokeWidth||s["stroke-width"]){const t=s.strokeWidth?s.strokeWidth:s["stroke-width"],o=(({vertices_coords:e,edges_vertices:t,edges_length:r})=>{if(!e||!t)return;r||(r=makeEdgesLength({vertices_coords:e,edges_vertices:t}));const s=r.slice().sort(((e,t)=>e-t));return s[Math.floor(.1*s.length)]})(r);let n;n=o?"number"==typeof t?10*o*t:10*o*.01:"number"==typeof t?a*t:.01*a,e.setAttributeNS(null,"stroke-width",n)}if(o){const e=s.vertices&&null!=s.vertices.radius?s.vertices.radius:s.radius,r="string"==typeof e?parseFloat(e):e,o="number"!=typeof r||Number.isNaN(r)?.02*a:a*r;((e,t)=>{for(let r=0;r<e.childNodes.length;r+=1)e.childNodes[r].setAttributeNS(null,"r",t)})(t[3],o)}},drawInto=(e,t,r={})=>{const s=DrawGroups(t,r);return s.filter((e=>e.childNodes.length>0)).forEach((t=>e.appendChild(t))),applyTopLevelOptions(e,s,t,r),((e,t)=>{const r=[t.file_classes||[],t.frame_classes||[]].flat();r.length&&addClassToClassList(e,...r)})(e,t),Object.keys(DrawGroups).map(((e,t)=>({key:e,i:t}))).filter((t=>null==e[t.key])).forEach((t=>Object.defineProperty(e,t.key,{get:()=>s[t.i]}))),e},FOLDtoSVG=(e,t)=>drawInto(T.svg(),e,t);Object.keys(DrawGroups).forEach((e=>{FOLDtoSVG[e]=DrawGroups[e]})),FOLDtoSVG.drawInto=drawInto,FOLDtoSVG.getViewBox=e=>{const t=getBoundingRect(e);return void 0===t?"":t.join(" ")},Object.defineProperty(FOLDtoSVG,"linker",{enumerable:!1,value:function(e){e.graph.svg=this;const t={svg:this};Object.keys(t).forEach((r=>{e.graph.prototype[r]=function(){return t[r](this,...arguments)}}))}.bind(FOLDtoSVG)});const jr={init:()=>{}};function SVG(){return jr.init(...arguments)}const Fr="class",Pr="function",Cr="undefined",Sr="number",Nr="string",zr="object",$r="svg",Vr="path",Tr="id",Lr="style",Ir="viewBox",Br="transform",Rr="points",Ur="stroke",Dr="none",qr="arrow",Gr="head",Wr="tail",Hr=typeof window!==Cr&&typeof window.document!==Cr,Jr=typeof process!==Cr&&null!=process.versions&&null!=process.versions.node,Zr=[];Zr[10]='"error 010: window" not set. if using node/deno, include package @xmldom/xmldom, set to the main export ( ear.window = xmldom; )';const Yr={window:void 0};Hr&&(Yr.window=window);const SVGWindow=()=>{if(void 0===Yr.window)throw Zr[10];return Yr.window};var Xr="http://www.w3.org/2000/svg",Kr={s:["svg"],d:["defs"],h:["desc","filter","metadata","style","script","title","view"],c:["cdata"],g:["g"],v:["circle","ellipse","line","path","polygon","polyline","rect"],t:["text"],i:["marker","symbol","clipPath","mask"],p:["linearGradient","radialGradient","pattern"],cT:["textPath","tspan"],cG:["stop"],cF:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]};const svg_add2=(e,t)=>[e[0]+t[0],e[1]+t[1]],svg_sub2=(e,t)=>[e[0]-t[0],e[1]-t[1]],svg_scale2=(e,t)=>[e[0]*t,e[1]*t],svg_magnitudeSq2=e=>e[0]**2+e[1]**2,svg_magnitude2=e=>Math.sqrt(svg_magnitudeSq2(e)),svg_distanceSq2=(e,t)=>svg_magnitudeSq2(svg_sub2(e,t)),svg_distance2=(e,t)=>Math.sqrt(svg_distanceSq2(e,t)),svg_polar_to_cart=(e,t)=>[Math.cos(e)*t,Math.sin(e)*t];var Qr=Object.freeze({__proto__:null,svg_add2:svg_add2,svg_sub2:svg_sub2,svg_scale2:svg_scale2,svg_magnitudeSq2:svg_magnitudeSq2,svg_magnitude2:svg_magnitude2,svg_distanceSq2:svg_distanceSq2,svg_distance2:svg_distance2,svg_polar_to_cart:svg_polar_to_cart});const arcPath=(e,t,r,s,o,n=!1)=>{if(null==o)return"";const a=svg_polar_to_cart(s,r),c=svg_polar_to_cart(o,r),i=[c[0]-a[0],c[1]-a[1]],l=a[0]*c[1]-a[1]*c[0],d=a[0]*c[0]+a[1]*c[1],m=Math.atan2(l,d)>0?0:1;let p=n?`M ${e},${t} l ${a[0]},${a[1]} `:`M ${e+a[0]},${t+a[1]} `;return p+=["a ",r,r,0,m,1,i[0],i[1]].join(" "),n&&(p+=" Z"),p},arcArguments=(e,t,r,s,o)=>[arcPath(e,t,r,s,o,!1)];var es={arc:{nodeName:Vr,attributes:["d"],args:arcArguments,methods:{setArc:(e,...t)=>e.setAttribute("d",arcArguments(...t))}}};const wedgeArguments=(e,t,r,s,o)=>[arcPath(e,t,r,s,o,!0)];var ts={wedge:{nodeName:Vr,args:wedgeArguments,attributes:["d"],methods:{setArc:(e,...t)=>e.setAttribute("d",wedgeArguments(...t))}}};const parabolaArguments=(e=-1,t=0,r=2,s=1)=>Array.from(Array(129)).map(((e,t)=>(t-128)/128*2+1)).map((o=>[e+(o+1)*r*.5,t+o**2*s]));var rs={parabola:{nodeName:"polyline",attributes:[Rr],args:(e,t,r,s)=>[parabolaArguments(e,t,r,s).map((e=>`${e[0]},${e[1]}`)).join(" ")]}};const regularPolygonArguments=(e,t,r,s)=>{const o=[t,r];return Array.from(Array(e)).map(((t,r)=>2*Math.PI*(r/e))).map((e=>[Math.cos(e),Math.sin(e)])).map((e=>o.map(((t,r)=>t+s*e[r]))))};var ss={regularPolygon:{nodeName:"polygon",attributes:[Rr],args:(e,t=0,r=0,s=1)=>[regularPolygonArguments(e,t,r,s).map((e=>`${e[0]},${e[1]}`)).join(" ")]}};var os={roundRect:{nodeName:Vr,attributes:["d"],args:(e,t,r,s,o=0)=>{o>r/2&&(o=r/2),o>s/2&&(o=s/2);const n=r-2*o,a=s-2*o,c=`A${o} ${o} 0 0 1`;return[[`M${e+(r-n)/2},${t}`,`h${n}`,c,`${e+r},${t+(s-a)/2}`,`v${a}`,c,`${e+r-o},${t+s}`,"h"+-n,c,`${e},${t+s-o}`,"v"+-a,c,`${e+o},${t}`].join(" ")]}}},ns={toCamel:e=>e.replace(/([-_][a-z])/gi,(e=>e.toUpperCase().replace("-","").replace("_",""))),toKebab:e=>e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase(),capitalized:e=>e.charAt(0).toUpperCase()+e.slice(1)};const svg_is_iterable=e=>null!=e&&typeof e[Symbol.iterator]===Pr,svg_semi_flatten_arrays=function(){switch(arguments.length){case void 0:case 0:return Array.from(arguments);case 1:return svg_is_iterable(arguments[0])&&typeof arguments[0]!==Nr?svg_semi_flatten_arrays(...arguments[0]):[arguments[0]];default:return Array.from(arguments).map((e=>svg_is_iterable(e)?[...svg_semi_flatten_arrays(e)]:e))}};var coordinates=(...e)=>e.filter((e=>typeof e===Sr)).concat(e.filter((e=>typeof e===zr&&null!==e)).map((e=>typeof e.x===Sr?[e.x,e.y]:typeof e[0]===Sr?[e[0],e[1]]:void 0)).filter((e=>void 0!==e)).reduce(((e,t)=>e.concat(t)),[]));const as=[Wr,Gr],stringifyPoint=e=>e.join(","),pointsToPath=e=>"M"+e.map((e=>e.join(","))).join("L")+"Z",setArrowheadOptions=(e,t,r)=>{"boolean"==typeof t?e.options[r].visible=t:typeof t===zr?(Object.assign(e.options[r],t),null==t.visible&&(e.options[r].visible=!0)):null==t&&(e.options[r].visible=!0)},setArrowStyle=(e,t={},r=Gr)=>{const s=e.getElementsByClassName(`${qr}-${r}`)[0];Object.keys(t).map((e=>({key:e,fn:s[ns.toCamel(e)]}))).filter((e=>typeof e.fn===Pr&&"class"!==e.key)).forEach((e=>e.fn(t[e.key]))),Object.keys(t).filter((e=>"class"===e)).forEach((e=>s.classList.add(t[e])))},redraw=e=>{const t=function(e){let t=[[0,1],[2,3]].map((t=>t.map((t=>e.points[t]||0)))),r=svg_sub2(t[1],t[0]),s=svg_add2(t[0],svg_scale2(r,.5));const o=svg_magnitude2(r),n=as.map((t=>e[t].visible?(1+e[t].padding)*e[t].height*2.5:0)).reduce(((e,t)=>e+t),0);if(o<n){const e=0===o?[n,0]:svg_scale2(r,n/o);t=[svg_sub2,svg_add2].map((t=>t(s,svg_scale2(e,.5)))),r=svg_sub2(t[1],t[0])}let a=[r[1],-r[0]],c=svg_add2(s,svg_scale2(a,e.bend));const i=t.map((e=>svg_sub2(c,e))),l=i.map((e=>svg_magnitude2(e))),d=i.map(((e,t)=>0===l[t]?e:svg_scale2(e,1/l[t]))),m=d.map((e=>svg_scale2(e,-1))),p=m.map((e=>[e[1],-e[0]])),g=as.map(((t,r)=>e[t].padding?e[t].padding:e.padding?e.padding:0)),u=as.map(((t,r)=>e[t].height*(e[t].visible?1:0))).map(((e,t)=>e+g[t])),v=t.map(((e,t)=>svg_add2(e,svg_scale2(d[t],u[t]))));r=svg_sub2(v[1],v[0]),a=[r[1],-r[0]],s=svg_add2(v[0],svg_scale2(r,.5)),c=svg_add2(s,svg_scale2(a,e.bend));const h=v.map(((t,r)=>svg_add2(t,svg_scale2(svg_sub2(c,t),e.pinch)))),_=as.map(((t,r)=>[svg_add2(v[r],svg_scale2(m[r],e[t].height)),svg_add2(v[r],svg_scale2(p[r],e[t].width/2)),svg_add2(v[r],svg_scale2(p[r],-e[t].width/2))]));return{line:`M${stringifyPoint(v[0])}C${stringifyPoint(h[0])},${stringifyPoint(h[1])},${stringifyPoint(v[1])}`,tail:pointsToPath(_[0]),head:pointsToPath(_[1])}}(e.options);return Object.keys(t).map((t=>({path:t,element:e.getElementsByClassName(`${qr}-${t}`)[0]}))).filter((e=>e.element)).map((e=>(e.element.setAttribute("d",t[e.path]),e))).filter((t=>e.options[t.path])).forEach((t=>t.element.setAttribute("visibility",e.options[t.path].visible?"visible":"hidden"))),e},setPoints$3=(e,...t)=>(e.options.points=coordinates(...svg_semi_flatten_arrays(...t)).slice(0,4),redraw(e));var cs={setPoints:setPoints$3,points:setPoints$3,bend:(e,t)=>(e.options.bend=t,redraw(e)),pinch:(e,t)=>(e.options.pinch=t,redraw(e)),padding:(e,t)=>(e.options.padding=t,redraw(e)),head:(e,t)=>(setArrowheadOptions(e,t,Gr),setArrowStyle(e,t,Gr),redraw(e)),tail:(e,t)=>(setArrowheadOptions(e,t,Wr),setArrowStyle(e,t,Wr),redraw(e)),getLine:e=>e.getElementsByClassName(`${qr}-line`)[0],getHead:e=>e.getElementsByClassName(`${qr}-${Gr}`)[0],getTail:e=>e.getElementsByClassName(`${qr}-${Wr}`)[0]};const is=Object.keys({head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]});var ls={arrow:{nodeName:"g",attributes:[],args:()=>[],methods:cs,init:function(e,...t){e.classList.add(qr);const r=["line",Wr,Gr].map((t=>SVG.path().addClass(`${qr}-${t}`).appendTo(e)));r[0].setAttribute(Lr,"fill:none;"),r[1].setAttribute(Ur,Dr),r[2].setAttribute(Ur,Dr),e.options={head:{visible:!1,width:8,height:10,padding:0},tail:{visible:!1,width:8,height:10,padding:0},bend:0,padding:0,pinch:.618,points:[]},cs.setPoints(e,...t);const s=((...e)=>{for(let t=0;t<e.length;t+=1){if(typeof e[t]!==zr)continue;const r=Object.keys(e[t]);for(let s=0;s<r.length;s+=1)if(is.includes(r[s]))return e[t]}})(...t);return s&&Object.keys(s).filter((e=>cs[e])).forEach((t=>cs[t](e,s[t]))),e}}};const svg_flatten_arrays=function(){return svg_semi_flatten_arrays(arguments).reduce(((e,t)=>e.concat(t)),[])},makeCurvePath=(e=[],t=0,r=.5)=>{const s=[e[0]||0,e[1]||0],o=[e[2]||0,e[3]||0],n=svg_sub2(o,s),a=svg_add2(s,svg_scale2(n,.5)),c=[n[1],-n[0]],i=svg_add2(a,svg_scale2(c,t)),l=svg_add2(s,svg_scale2(svg_sub2(i,s),r)),d=svg_add2(o,svg_scale2(svg_sub2(i,o),r));return`M${s[0]},${s[1]}C${l[0]},${l[1]} ${d[0]},${d[1]} ${o[0]},${o[1]}`},getNumbersFromPathCommand=e=>e.slice(1).split(/[, ]+/).map((e=>parseFloat(e))),getCurveEndpoints=e=>{const t=(e=>e.match(/[Mm][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift(),r=(e=>e.match(/[Cc][(0-9), .-]+/).map((e=>getNumbersFromPathCommand(e))))(e).shift();return[...t?[t[t.length-2],t[t.length-1]]:[0,0],...r?[r[r.length-2],r[r.length-1]]:[0,0]]},setPoints$2=(e,...t)=>{const r=coordinates(...svg_flatten_arrays(...t)).slice(0,4);return e.setAttribute("d",makeCurvePath(r,e._bend,e._pinch)),e};var fs={curve:{nodeName:Vr,attributes:["d"],args:(...e)=>[makeCurvePath(coordinates(...svg_flatten_arrays(...e)))],methods:{setPoints:setPoints$2,bend:(e,t)=>(e._bend=t,setPoints$2(e,...getCurveEndpoints(e.getAttribute("d")))),pinch:(e,t)=>(e._pinch=t,setPoints$2(e,...getCurveEndpoints(e.getAttribute("d"))))}}};const ds={};Object.assign(ds,es,ts,rs,ss,os,ls,fs);const ms=Object.keys(ds),ps=[Kr.h,Kr.p,Kr.i],gs=[Kr.g,Kr.v,Kr.t,ms],us={svg:[Kr.s,Kr.d].concat(ps).concat(gs),g:gs,text:[Kr.cT],linearGradient:[Kr.cG],radialGradient:[Kr.cG],defs:ps,filter:[Kr.cF],marker:gs,symbol:gs,clipPath:gs,mask:gs},vs=Object.create(null);Object.keys(us).forEach((e=>{vs[e]=us[e].reduce(((e,t)=>e.concat(t)),[])}));const viewBoxValue=function(e,t,r,s,o=0){const n=r/1-r;return[e-n-o,t-n-o,r+2*n+2*o,s+2*n+2*o].join(" ")};function viewBox$1(){const e=coordinates(...svg_flatten_arrays(arguments));return 2===e.length&&e.unshift(0,0),4===e.length?viewBoxValue(...e):void 0}const cdata=e=>(new(SVGWindow().DOMParser)).parseFromString("<root></root>","text/xml").createCDATASection(`${e}`),removeChildren=e=>{for(;e.lastChild;)e.removeChild(e.lastChild);return e},moveChildren=(e,t)=>{for(;t.childNodes.length>0;){const r=t.childNodes[0];t.removeChild(r),e.appendChild(r)}return e},assignSVG=(e,t)=>(Array.from(t.attributes).forEach((t=>e.setAttribute(t.name,t.value))),moveChildren(e,t));var hs={removeChildren:removeChildren,appendTo:(e,t)=>(null!=t&&t.appendChild(e),e),setAttributes:(e,t)=>Object.keys(t).forEach((r=>e.setAttribute(ns.toKebab(r),t[r])))};const filterWhitespaceNodes=e=>{if(null===e)return e;for(let t=e.childNodes.length-1;t>=0;t-=1){const r=e.childNodes[t];3===r.nodeType&&r.data.match(/^\s*$/)&&e.removeChild(r),1===r.nodeType&&filterWhitespaceNodes(r)}return e},parse=e=>(new(SVGWindow().DOMParser)).parseFromString(e,"text/xml"),checkParseError=e=>{const t=e.getElementsByTagName("parsererror");if(t.length>0)throw new Error(t[0]);return filterWhitespaceNodes(e.documentElement)},sync=function(e){if(typeof e===Nr||e instanceof String)try{return checkParseError(parse(e))}catch(e){return e}if(null!=e.childNodes)return e},Load=e=>(e=>typeof e===Nr&&/^[\w,\s-]+\.[A-Za-z]{3}$/.test(e)&&e.length<1e4)(e)&&Hr&&typeof SVGWindow().fetch===Pr?function(e){return new Promise(((t,r)=>{if(typeof e===Nr||e instanceof String)fetch(e).then((e=>e.text())).then((e=>checkParseError(parse(e)))).then((e=>e.nodeName===$r?e:e.getElementsByTagName($r)[0])).then((e=>null==e?r(new Error("valid XML found, but no SVG element")):t(e))).catch((e=>r(e)));else if(e instanceof SVGWindow().Document)return asyncDone(e)}))}(e):sync(e);const save=function(e,t){if((t=Object.assign({download:!1,output:Nr,windowStyle:!1,filename:"image.svg"},t)).windowStyle){const t=SVGWindow().document.createElementNS(Xr,Lr);t.setAttribute("type","text/css"),t.innerHTML=function(){const e=[];if(SVGWindow().document.styleSheets)for(let t=0;t<SVGWindow().document.styleSheets.length;t+=1){const r=SVGWindow().document.styleSheets[t];try{const t="cssRules"in r?r.cssRules:r.rules;for(let r=0;r<t.length;r+=1){const s=t[r];"cssText"in s?e.push(s.cssText):e.push(`${s.selectorText} {\n${s.style.cssText}\n}\n`)}}catch(e){console.warn(e)}}return e.join("\n")}(),e.appendChild(t)}const r=function vkXML(e,t){const r=e.replace(/>\s{0,}</g,"><").replace(/</g,"~::~<").replace(/\s*xmlns\:/g,"~::~xmlns:").split("~::~"),s=r.length;let o=!1,n=0,a="";const c=null!=t&&"string"==typeof t?t:"\t",i=["\n"];for(let e=0;e<100;e+=1)i.push(i[e]+c);for(let e=0;e<s;e+=1)r[e].search(/<!/)>-1?(a+=i[n]+r[e],o=!0,(r[e].search(/-->/)>-1||r[e].search(/\]>/)>-1||r[e].search(/!DOCTYPE/)>-1)&&(o=!1)):r[e].search(/-->/)>-1||r[e].search(/\]>/)>-1?(a+=r[e],o=!1):/^<\w/.exec(r[e-1])&&/^<\/\w/.exec(r[e])&&/^<[\w:\-\.\,]+/.exec(r[e-1])==/^<\/[\w:\-\.\,]+/.exec(r[e])[0].replace("/","")?(a+=r[e],o||(n-=1)):r[e].search(/<\w/)>-1&&-1===r[e].search(/<\//)&&-1===r[e].search(/\/>/)?a=a+=o?r[e]:i[n++]+r[e]:r[e].search(/<\w/)>-1&&r[e].search(/<\//)>-1?a=a+=o?r[e]:i[n]+r[e]:r[e].search(/<\//)>-1?a=a+=o?r[e]:i[--n]+r[e]:r[e].search(/\/>/)>-1?a=a+=o?r[e]:i[n]+r[e]:r[e].search(/<\?/)>-1||r[e].search(/xmlns\:/)>-1||r[e].search(/xmlns\=/)>-1?a+=i[n]+r[e]:a+=r[e];return"\n"===a[0]?a.slice(1):a}((new(SVGWindow().XMLSerializer)).serializeToString(e));return t.download&&Hr&&!Jr&&function(e,t){const r=new(SVGWindow().Blob)([t],{type:"text/plain"}),s=SVGWindow().document.createElement("a");s.setAttribute("href",SVGWindow().URL.createObjectURL(r)),s.setAttribute("download",e),SVGWindow().document.body.appendChild(s),s.click(),SVGWindow().document.body.removeChild(s)}(t.filename,r),t.output===$r?e:r},setViewBox=(e,...t)=>{const r=1===t.length&&typeof t[0]===Nr?t[0]:viewBox$1(...t);return r&&e.setAttribute(Ir,r),e},getViewBox=function(e){const t=e.getAttribute(Ir);return null==t?void 0:t.split(" ").map((e=>parseFloat(e)))},convertToViewBox=function(e,t,r){const s=e.createSVGPoint();s.x=t,s.y=r;const o=s.matrixTransform(e.getScreenCTM().inverse());return[o.x,o.y]};var _s=Object.freeze({__proto__:null,setViewBox:setViewBox,getViewBox:getViewBox,convertToViewBox:convertToViewBox});const loadSVG=(e,t)=>{const r=Load(t);if(null!=r)return typeof r.then===Pr?r.then((t=>assignSVG(e,t))):assignSVG(e,r)},getFrame=function(e){const t=getViewBox(e);if(void 0!==t)return t;if(typeof e.getBoundingClientRect===Pr){const t=e.getBoundingClientRect();return[t.x,t.y,t.width,t.height]}return[]},bs="svg-background-rectangle",stylesheet=function(e,t){let r=function(e){const t=e.getElementsByTagName(Lr);return 0===t.length?void 0:t[0]}(e);return null==r&&(r=this.Constructor(Lr),e.insertBefore(r,e.firstChild)),r.textContent="",r.appendChild(cdata(t)),r};var ys={clear:e=>(Array.from(e.attributes).filter((e=>"xmlns"!==e)).forEach((t=>e.removeAttribute(t.name))),removeChildren(e)),size:setViewBox,setViewBox:setViewBox,getViewBox:getViewBox,padding:function(e,t){const r=getViewBox(e);return void 0!==r&&setViewBox(e,...[-t,-t,2*t,2*t].map(((e,t)=>r[t]+e))),e},background:function(e,t){let r=Array.from(e.childNodes).filter((e=>e.getAttribute(Fr)===bs)).shift();return null==r&&(r=this.Constructor("rect",null,...getFrame(e)),r.setAttribute(Fr,bs),r.setAttribute(Ur,Dr),e.insertBefore(r,e.firstChild)),r.setAttribute("fill",t),e},getWidth:e=>getFrame(e)[2],getHeight:e=>getFrame(e)[3],stylesheet:function(e,t){return stylesheet.call(this,e,t)},load:loadSVG,save:save};const Es={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"],leave:["mouseleave","touchcancel"]},As=Object.values(Es).reduce(((e,t)=>e.concat(t)),[]),defineGetter=(e,t,r)=>Object.defineProperty(e,t,{get:()=>r,enumerable:!0,configurable:!0}),assignPress=(e,t)=>{["pressX","pressY"].filter((t=>!Object.prototype.hasOwnProperty.call(e,t))).forEach(((r,s)=>defineGetter(e,r,t[s]))),Object.prototype.hasOwnProperty.call(e,"press")||defineGetter(e,"press",[...t])},TouchEvents=function(e){let t=[];const r=[];Object.keys(Es).forEach((e=>{Es[e].forEach((e=>{r[e]=[]}))}));const s={press:(e,r)=>{t=r,assignPress(e,t)},release:()=>{},leave:()=>{},move:(e,r)=>{e.buttons>0&&void 0===t[0]?t=r:0===e.buttons&&void 0!==t[0]&&(t=[]),assignPress(e,t)}};Object.keys(Es).forEach((t=>{const o=`on${ns.capitalized(t)}`;Object.defineProperty(e,o,{set:o=>{null!=o?Es[t].forEach((n=>{const handlerFunc=r=>{const n=null!=r.touches?r.touches[0]:r;if(void 0!==n){const o=convertToViewBox(e,n.clientX,n.clientY).map((e=>Number.isNaN(e)?void 0:e));["x","y"].filter((e=>!Object.prototype.hasOwnProperty.call(r,e))).forEach(((e,t)=>defineGetter(r,e,o[t]))),Object.prototype.hasOwnProperty.call(r,"position")||defineGetter(r,"position",[...o]),s[t](r,o)}o(r)};e.addEventListener&&(r[n].push(handlerFunc),e.addEventListener(n,handlerFunc))})):(t=>{Es[t].forEach((t=>r[t].forEach((r=>e.removeEventListener(t,r)))))})(t)},enumerable:!0})})),Object.defineProperty(e,"off",{value:()=>((e,t)=>As.forEach((r=>{t[r].forEach((t=>e.removeEventListener(r,t))),t[r]=[]})))(e,r)})};var UUID=()=>Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5);const ks=[["cx","cy"],["x","y"]],controlPoint=function(e,t={}){const r=[0,0],s={selected:!1,svg:void 0,updatePosition:e=>e},updateSVG=()=>{s.svg&&(s.svg.parentNode||e.appendChild(s.svg),ks.filter((e=>null!=s.svg[e[0]])).forEach((e=>e.forEach(((e,t)=>{s.svg.setAttribute(e,r[t])})))))},o=new Proxy(r,{set:(e,t,r)=>(e[t]=r,updateSVG(),!0)}),setPosition=function(...e){coordinates(...svg_flatten_arrays(...e)).forEach(((e,t)=>{r[t]=e})),updateSVG(),typeof r.delegate===Pr&&r.delegate.apply(r.pointsContainer,[o,r.pointsContainer])};return r.delegate=void 0,r.setPosition=setPosition,r.onMouseMove=e=>s.selected?setPosition(s.updatePosition(e)):void 0,r.onMouseUp=()=>{s.selected=!1},r.distance=e=>Math.sqrt(svg_distanceSq2(e,r)),["x","y"].forEach(((e,t)=>Object.defineProperty(r,e,{get:()=>r[t],set:e=>{r[t]=e}}))),[$r,"updatePosition","selected"].forEach((e=>Object.defineProperty(r,e,{get:()=>s[e],set:t=>{s[e]=t}}))),Object.defineProperty(r,"remove",{value:()=>{var e;(e=s.svg)&&e.parentNode&&e.parentNode.removeChild(e),r.delegate=void 0}}),o},controls=function(e,t,r){let s,o;const n=Array.from(Array(t)).map((()=>controlPoint(e,r))),protocol=e=>typeof o===Pr?o.call(n,e,s,n):void 0;n.forEach((e=>{e.delegate=protocol,e.pointsContainer=n}));e.onPress=function(e){n.length>0&&(s=n.map(((t,r)=>({i:r,d:svg_distanceSq2(t,[e.x,e.y])}))).sort(((e,t)=>e.d-t.d)).shift().i,n[s].selected=!0)},e.onMove=function(e){n.forEach((t=>t.onMouseMove(e)))},e.onRelease=function(){n.forEach((e=>e.onMouseUp())),s=void 0},Object.defineProperty(n,"selectedIndex",{get:()=>s}),Object.defineProperty(n,"selected",{get:()=>n[s]}),Object.defineProperty(n,"add",{value:t=>{n.push(controlPoint(e,t))}}),n.removeAll=()=>{for(;n.length>0;)n.pop().remove()};const a={onChange:(e,t)=>{if(o=e,!0===t){const t=n.length-1;e.call(n,n[t],t,n)}},position:e=>n.forEach(((t,r)=>t.setPosition(e.call(n,t,r,n)))),svg:e=>n.forEach(((t,r)=>{t.svg=e.call(n,t,r,n)}))};return Object.keys(a).forEach((e=>{n[e]=function(){return typeof arguments[0]===Pr&&a[e](...arguments),n}})),n.parent=function(e){return null!=e&&null!=e.appendChild&&n.forEach((t=>{e.appendChild(t.svg)})),n},n},applyControlsToSVG=e=>{e.controls=(...t)=>controls.call(e,e,...t)};var xs={svg:{args:(...e)=>[viewBox$1(coordinates(...e))].filter((e=>null!=e)),methods:ys,init:(e,...t)=>{t.filter((e=>typeof e===Nr)).forEach((t=>loadSVG(e,t))),t.filter((e=>null!=e)).filter((e=>typeof e.appendChild===Pr)).forEach((t=>t.appendChild(e))),TouchEvents(e),function(e){let t;const r={};let s,o=0;const removeHandlers=()=>{SVGWindow().cancelAnimationFrame&&SVGWindow().cancelAnimationFrame(s),Object.keys(r).forEach((e=>delete r[e])),t=void 0,o=0};Object.defineProperty(e,"play",{set:e=>{if(removeHandlers(),null==e)return;const n=UUID();r[n]=a=>{t||(t=a,o=0),e({time:.001*(a-t),frame:o}),o+=1,r[n]&&(s=SVGWindow().requestAnimationFrame(r[n]))},SVGWindow().requestAnimationFrame&&(s=SVGWindow().requestAnimationFrame(r[n]))},enumerable:!0}),Object.defineProperty(e,"stop",{value:removeHandlers,enumerable:!0})}(e),applyControlsToSVG(e)}}};const loadGroup=(e,...t)=>{const r=t.map((e=>sync(e))).filter((e=>void 0!==e));return r.filter((e=>e.tagName===$r)).forEach((t=>moveChildren(e,t))),r.filter((e=>e.tagName!==$r)).forEach((t=>e.appendChild(t))),e};var Os={g:{init:loadGroup,methods:{load:loadGroup}}},Ms=Object.assign(Object.create(null),{svg:[Ir],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:[Rr],polyline:[Rr],path:["d"],text:["x","y"],mask:[Tr],symbol:[Tr],clipPath:[Tr,"clip-rule"],marker:[Tr,"markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]});const setRadius=(e,t)=>(e.setAttribute(Ms.circle[2],t),e),setOrigin=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(Ms.circle[r],t))),e);var ws={circle:{args:(e,t,r,s)=>{const o=coordinates(...svg_flatten_arrays(e,t,r,s));switch(o.length){case 0:case 1:return[,,...o];case 2:case 3:return o;default:return((e,t,r,s)=>[e,t,svg_distance2([e,t],[r,s])])(...o)}},methods:{radius:setRadius,setRadius:setRadius,origin:setOrigin,setOrigin:setOrigin,center:setOrigin,setCenter:setOrigin,position:setOrigin,setPosition:setOrigin}}};const setRadii=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Ms.ellipse[r],t))),e),setCenter=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(Ms.ellipse[r],t))),e);var js={ellipse:{args:(e,t,r,s)=>{const o=coordinates(...svg_flatten_arrays(e,t,r,s)).slice(0,4);switch(o.length){case 0:case 1:case 2:return[,,...o];default:return o}},methods:{radius:setRadii,setRadius:setRadii,origin:setCenter,setOrigin:setCenter,center:setCenter,setCenter:setCenter,position:setCenter,setPosition:setCenter}}};const Args$1=(...e)=>coordinates(...svg_semi_flatten_arrays(...e)).slice(0,4);var Fs={line:{args:Args$1,methods:{setPoints:(e,...t)=>(Args$1(...t).forEach(((t,r)=>e.setAttribute(Ms.line[r],t))),e)}}};const Ps={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"},add2path=(e,t)=>[e[0]+(t[0]||0),e[1]+(t[1]||0)];Object.keys(Ps).forEach((e=>{const t=Ps[e];Ps[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));const Cs=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g,Ss=/-?[0-9]*\.?\d+/g,parsePathCommands=e=>{const t=[];let r;for(;null!==(r=Cs.exec(e));)t.push(r);return t.map(((t,r,s)=>[t[0],t.index,r===s.length-1?e.length-1:s[(r+1)%s.length].index-1])).map((t=>{const r=t[0],s=e.substring(t[1]+1,t[2]).match(Ss);return{command:r,values:s?s.map(parseFloat):[]}}))};var Ns=Object.freeze({__proto__:null,pathCommandNames:Ps,parsePathCommands:parsePathCommands,parsePathCommandsEndpoints:e=>{let t=[0,0];const r=parsePathCommands(e);if(!r.length)return r;r.forEach(((e,s)=>{r[s].end=((e,t,r=[0,0])=>{const s=e.toUpperCase(),o=e===s?[0,0]:r;switch(s){case"M":case"L":case"V":case"H":case"T":return add2path(o,t);case"A":return add2path(o,[t[5],t[6]]);case"C":return add2path(o,[t[4],t[5]]);case"S":case"Q":return add2path(o,[t[2],t[3]]);case"Z":return;default:return o}})(e.command,e.values,t),r[s].start=0===s?t:r[s-1].end,t=r[s].end}));const s=r[r.length-1],o=r.filter((e=>"M"!==e.command.toUpperCase()&&"Z"!==e.command.toUpperCase())).shift();return"Z"===s.command.toUpperCase()&&(s.end=[...o.start]),r}});const getD=e=>{const t=e.getAttribute("d");return null==t?"":t},appendPathCommand=(e,t,...r)=>(e.setAttribute("d",`${getD(e)}${t}${svg_flatten_arrays(...r).join(" ")}`),e),getCommands=e=>parsePathCommands(getD(e)),zs={addCommand:appendPathCommand,appendCommand:appendPathCommand,clear:e=>(e.removeAttribute("d"),e),getCommands:getCommands,get:getCommands,getD:e=>e.getAttribute("d")};Object.keys(Ps).forEach((e=>{zs[Ps[e]]=(t,...r)=>appendPathCommand(t,e,...r)}));var $s={path:{methods:zs}};const setRectSize=(e,t,r)=>([,,t,r].forEach(((t,r)=>e.setAttribute(Ms.rect[r],t))),e),setRectOrigin=(e,t,r)=>([...coordinates(...svg_flatten_arrays(t,r)).slice(0,2)].forEach(((t,r)=>e.setAttribute(Ms.rect[r],t))),e),fixNegatives=function(e){return[0,1].forEach((t=>{e[2+t]<0&&(void 0===e[0+t]&&(e[0+t]=0),e[0+t]+=e[2+t],e[2+t]=-e[2+t])})),e};var Vs={rect:{args:(e,t,r,s)=>{const o=coordinates(...svg_flatten_arrays(e,t,r,s)).slice(0,4);switch(o.length){case 0:case 1:case 2:case 3:return fixNegatives([,,...o]);default:return fixNegatives(o)}},methods:{origin:setRectOrigin,setOrigin:setRectOrigin,center:setRectOrigin,setCenter:setRectOrigin,size:setRectSize,setSize:setRectSize}}},Ts={style:{init:(e,t)=>{e.textContent="",e.appendChild(cdata(t))},methods:{setTextContent:(e,t)=>(e.textContent="",e.appendChild(cdata(t)),e)}}},Ls={text:{args:(e,t,r)=>coordinates(...svg_flatten_arrays(e,t,r)).slice(0,2),init:(e,t,r,s,o)=>{const n=[t,r,s,o].filter((e=>typeof e===Nr)).shift();n&&e.appendChild(SVGWindow().document.createTextNode(n))}}};const makeIDString=function(){return Array.from(arguments).filter((e=>typeof e===Nr||e instanceof String)).shift()||UUID()},maskArgs=(...e)=>[makeIDString(...e)];var Is={mask:{args:maskArgs},clipPath:{args:maskArgs},symbol:{args:maskArgs},marker:{args:maskArgs,methods:{size:setViewBox,setViewBox:setViewBox}}};const getPoints=e=>{const t=e.getAttribute(Rr);return null==t?"":t},polyString=function(){return Array.from(Array(Math.floor(arguments.length/2))).map(((e,t)=>`${arguments[2*t+0]},${arguments[2*t+1]}`)).join(" ")},stringifyArgs=(...e)=>[polyString(...coordinates(...svg_semi_flatten_arrays(...e)))],setPoints=(e,...t)=>(e.setAttribute(Rr,stringifyArgs(...t)[0]),e),addPoint=(e,...t)=>(e.setAttribute(Rr,[getPoints(e),stringifyArgs(...t)[0]].filter((e=>""!==e)).join(" ")),e),Args=function(...e){return 1===e.length&&typeof e[0]===Nr?[e[0]]:stringifyArgs(...e)};var Bs={polyline:{args:Args,methods:{setPoints:setPoints,addPoint:addPoint}},polygon:{args:Args,methods:{setPoints:setPoints,addPoint:addPoint}}},Rs=Object.assign({},xs,Os,ws,js,Fs,$s,Vs,Ts,Ls,Is,Bs),Us={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]};Object.values(Kr).reduce(((e,t)=>e.concat(t)),[]).filter((e=>void 0===Ms[e])).forEach((e=>{Ms[e]=[]})),[[[$r,"defs","g"].concat(Kr.v,Kr.t),Us.presentation],[["filter"],Us.effects],[Kr.cT.concat("text"),Us.text],[Kr.cF,Us.effects],[Kr.cG,Us.gradient]].forEach((e=>e[0].forEach((t=>{Ms[t]=Ms[t].concat(e[1])}))));const getClassList=e=>{if(null==e)return[];const t=e.getAttribute(Fr);return null==t?[]:t.split(" ").filter((e=>""!==e))};var Ds={addClass:(e,t)=>{const r=getClassList(e).filter((e=>e!==t));r.push(t),e.setAttributeNS(null,Fr,r.join(" "))},removeClass:(e,t)=>{const r=getClassList(e).filter((e=>e!==t));e.setAttributeNS(null,Fr,r.join(" "))},setClass:(e,t)=>{e.setAttributeNS(null,Fr,t)},setId:(e,t)=>{e.setAttributeNS(null,Tr,t)}};const getAttr=e=>{const t=e.getAttribute(Br);return null==t||""===t?void 0:t},qs={clearTransform:e=>(e.removeAttribute(Br),e)};["translate","rotate","scale","matrix"].forEach((e=>{qs[e]=(t,...r)=>t.setAttribute(Br,[getAttr(t),`${e}(${r.join(" ")})`].filter((e=>void 0!==e)).join(" "))}));const Gs={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((e=>{Gs[ns.toCamel(e)]=(t,r)=>t.setAttribute(e,function(e){if(null==e)return"";if(typeof e===Nr)return"url"===e.slice(0,3)?e:`url(#${e})`;if(null!=e.getAttribute)return`url(#${e.getAttribute(Tr)})`;return""}(r))}));const Ws={};Kr.v.push(...Object.keys(ds)),Object.keys(ds).forEach((e=>{ds[e].attributes=void 0===ds[e].attributes?[...Us.presentation]:ds[e].attributes.concat(Us.presentation)})),Object.assign(Ws,Rs,ds),Object.keys(Kr).forEach((e=>Kr[e].filter((e=>void 0===Ws[e])).forEach((e=>{Ws[e]={}}))));const passthrough=function(){return Array.from(arguments)};Object.keys(Ws).forEach((e=>{Ws[e].nodeName||(Ws[e].nodeName=e),Ws[e].init||(Ws[e].init=passthrough),Ws[e].args||(Ws[e].args=passthrough),Ws[e].methods||(Ws[e].methods={}),Ws[e].attributes||(Ws[e].attributes=Ms[e]||[])}));const assignMethods=(e,t)=>{e.forEach((e=>Object.keys(t).forEach((r=>{Ws[e].methods[r]=function(){return t[r](...arguments),arguments[0]}}))))};assignMethods(svg_flatten_arrays(Kr.t,Kr.v,Kr.g,Kr.s,Kr.p,Kr.i,Kr.h,Kr.d),Ds),assignMethods(svg_flatten_arrays(Kr.t,Kr.v,Kr.g,Kr.s,Kr.p,Kr.i,Kr.h,Kr.d),hs),assignMethods(svg_flatten_arrays(Kr.v,Kr.g,Kr.s),qs),assignMethods(svg_flatten_arrays(Kr.t,Kr.v,Kr.g),Gs);const Hs={svg:{version:"1.1",xmlns:Xr},style:{type:"text/css"}},Js={},constructor=(e,t,...r)=>{const s=SVGWindow().document.createElementNS(Xr,Ws[e].nodeName);return t&&t.appendChild(s),((e,t)=>{Hs[t]&&Object.keys(Hs[t]).forEach((r=>e.setAttribute(r,Hs[t][r])))})(s,e),Ws[e].init(s,...r),Ws[e].args(...r).forEach(((t,r)=>{null!=Ws[e].attributes[r]&&s.setAttribute(Ws[e].attributes[r],t)})),Ws[e].attributes.forEach((e=>{Object.defineProperty(s,ns.toCamel(e),{value:function(){return s.setAttribute(e,...arguments),s}})})),Object.keys(Ws[e].methods).forEach((t=>Object.defineProperty(s,t,{value:function(){return Ws[e].methods[t].call(Js,s,...arguments)}}))),vs[e]&&vs[e].forEach((e=>{const value=function(){return constructor(e,s,...arguments)};Ws[e].static&&Object.keys(Ws[e].static).forEach((t=>{value[t]=function(){return Ws[e].static[t](s,...arguments)}})),Object.defineProperty(s,e,{value:value})})),s};Js.Constructor=constructor;const Zs={};Object.keys(Kr).forEach((e=>Kr[e].forEach((e=>{Zs[e]=(...t)=>constructor(e,null,...t)}))));const link_rabbitear_math=(e,t)=>{["segment","circle","ellipse","rect","polygon"].filter((e=>t[e]&&t[e].prototype)).forEach((r=>{t[r].prototype.svg=function(){return e.path(this.svgPath())}})),t.vector},initialize=function(e,...t){t.filter((e=>typeof e===Pr)).forEach((t=>t.call(e,e)))};jr.init=function(){const e=constructor($r,null,...arguments);return"loading"===SVGWindow().document.readyState?SVGWindow().document.addEventListener("DOMContentLoaded",(()=>initialize(e,...arguments))):initialize(e,...arguments),e},SVG.NS=Xr,SVG.linker=function(e){e.graph&&e.origami&&(e.svg=this,link_rabbitear_math(this,e),((e,t)=>{const r="origami";Ws[r]={nodeName:"g",init:function(e,...r){return t.graph.svg.drawInto(e,...r)},args:()=>[],methods:Ws.g.methods,attributes:Ws.g.attributes,static:{}},Object.keys(t.graph.svg).forEach((e=>{Ws[r].static[e]=(r,...s)=>{const o=t.graph.svg[e](...s);return r.appendChild(o),o}})),vs[r]=[...vs.g],vs.svg.push(r),vs.g.push(r),e[r]=(...e)=>constructor(r,null,...e),Object.keys(t.graph.svg).forEach((s=>{e[r][s]=t.graph.svg[s]}))})(this,e))}.bind(SVG),Object.assign(SVG,Zs),SVG.core=Object.assign(Object.create(null),{load:Load,save:save,coordinates:coordinates,flatten:svg_flatten_arrays,attributes:Ms,children:vs,cdata:cdata},ns,Ds,hs,Qr,Ns,qs,_s),Object.defineProperty(SVG,"window",{enumerable:!1,set:e=>{var t;(t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),Yr.window=t,Yr.window}});const compileShader=(e,t,r)=>{const s=e.createShader(r);if(e.shaderSource(s,t),e.compileShader(s),!e.getShaderParameter(s,e.COMPILE_STATUS))throw new Error(e.getShaderInfoLog(s));return s},createProgram=(e,t,r)=>((e,t,r)=>{const s=e.createProgram();if(e.attachShader(s,t),e.attachShader(s,r),e.linkProgram(s),!e.getProgramParameter(s,e.LINK_STATUS))throw new Error(e.getProgramInfoLog(s));return e.deleteShader(t),e.deleteShader(r),s})(e,compileShader(e,t,e.VERTEX_SHADER),compileShader(e,r,e.FRAGMENT_SHADER));var Ys=Object.freeze({__proto__:null,rebuildViewport:(e,t)=>{if(!e)return;const r=window.devicePixelRatio||1,s=[t.clientWidth,t.clientHeight].map((e=>e*r));t.width===s[0]&&t.height===s[1]||(t.width=s[0],t.height=s[1]),e.viewport(0,0,e.canvas.width,e.canvas.height)},makeProjectionMatrix:(e,t="perspective",r=45)=>{if(!e)return Et;const s=[e.clientWidth,e.clientHeight],o=Math.min(...s),n=[0,1].map((e=>(s[e]-o)/o/2)).map((e=>e+.5));return"orthographic"===t?makeOrthographicMatrix4(n[1],n[0],-n[1],-n[0],-100,100):makePerspectiveMatrix4(r*(Math.PI/180),s[0]/s[1],.1,20)},makeModelMatrix:e=>{if(!e)return Et;const t=boundingBox(e);if(!t)return Et;const r=Math.max(...t.span),s=[r,0,0,0,0,r,0,0,0,0,r,0,...resize(3,midpoint(t.min,t.max)),1];return invertMatrix4(s)}});const uniformFunc=(e,t,r,s)=>{if("uniformMatrix4fv"===r)e[r](t,!1,s);else e[r](t,s)};var Xs=Object.freeze({__proto__:null,drawProgram:(e,t,r,s={})=>{e.useProgram(r.program),r.flags.forEach((t=>e.enable(t)));const o=e.getProgramParameter(r.program,e.ACTIVE_UNIFORMS);for(let t=0;t<o;t+=1){const o=e.getActiveUniform(r.program,t).name,n=s[o];if(n){const t=e.getUniformLocation(r.program,o);uniformFunc(e,t,n.func,n.value)}}r.vertexArrays.forEach((t=>{e.bindBuffer(e.ARRAY_BUFFER,t.buffer),e.bufferData(e.ARRAY_BUFFER,t.data,e.STATIC_DRAW),e.vertexAttribPointer(t.location,t.length,t.type,!1,0,0),e.enableVertexAttribArray(t.location)})),r.elementArrays.forEach((r=>{e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,r.buffer),e.bufferData(e.ELEMENT_ARRAY_BUFFER,r.data,e.STATIC_DRAW),e.drawElements(r.mode,r.data.length,2===t?e.UNSIGNED_INT:e.UNSIGNED_SHORT,r.buffer)})),r.flags.forEach((t=>e.disable(t)))},deallocProgram:(e,t)=>{t.vertexArrays.forEach((t=>e.disableVertexAttribArray(t.location))),t.vertexArrays.forEach((t=>e.deleteBuffer(t.buffer))),t.elementArrays.forEach((t=>e.deleteBuffer(t.buffer))),e.deleteProgram(t.program)}});const makeFacesVertexData=(e,t={})=>{const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0)))),s=makeVerticesNormal(e),o=r.map(((e,t)=>t%3)).map((e=>[0===e?1:0,1===e?1:0,2===e?1:0])),n=e.faces_edges.map((t=>t.map((t=>e.edges_assignment[t])).map((e=>"J"===e||"j"===e))));if(!t.showTrianglulation)for(let e=0;e<n.length;e+=1)n[e][0]&&(o[3*e+0][2]=o[3*e+1][2]=100),n[e][1]&&(o[3*e+1][0]=o[3*e+2][0]=100),n[e][2]&&(o[3*e+0][1]=o[3*e+2][1]=100);return{vertices_coords:r,vertices_normal:s,vertices_barycentric:o}},Ks={B:[.3,.3,.3],b:[.3,.3,.3],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.2,.2,.2],f:[.2,.2,.2],C:[1,.75,.25],c:[1,.75,.25],U:[.2,.2,.2],u:[.2,.2,.2]},makeThickEdgesVertexData=(e,t=Ks)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return[];const r=e.vertices_coords.map((e=>[...e].concat(Array(3-e.length).fill(0)))),s=e.edges_vertices.flatMap((e=>e.map((e=>r[e])))).flatMap((e=>[e,e,e,e])),o=makeEdgesVector(e);return{vertices_coords:s,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>Array(8).fill(t[e]))):e.edges_vertices.flatMap((()=>Array(8).fill(t.U))),verticesEdgesVector:o.flatMap((e=>[e,e,e,e,e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[0,1],[-1,0],[0,-1],[1,0],[0,1],[-1,0],[0,-1]]))}};var Qs=Object.freeze({__proto__:null,makeFacesVertexData:makeFacesVertexData,makeThickEdgesVertexData:makeThickEdgesVertexData});const makeFoldedVertexArrays=(e,t,r,s={})=>{if(!r||!r.vertices_coords||!r.faces_vertices)return[];const{vertices_coords:o,vertices_normal:n,vertices_barycentric:a}=makeFacesVertexData(r,s);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:o[0].length,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_normal"),buffer:e.createBuffer(),type:e.FLOAT,length:n[0].length,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"v_barycentric"),buffer:e.createBuffer(),type:e.FLOAT,length:3,data:new Float32Array(a.flat())}].filter((e=>-1!==e.location))},makeFoldedElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(r.faces_vertices.flat()):new Uint16Array(r.faces_vertices.flat())}]:[],makeThickEdgesVertexArrays=(e,t,r,s={})=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:o,vertices_color:n,verticesEdgesVector:a,vertices_vector:c}=makeThickEdgesVertexData(r,s.assignment_color);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:o[0].length,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:n[0].length,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a[0].length,data:new Float32Array(a.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:c[0].length,data:new Float32Array(c.flat())}].filter((e=>-1!==e.location))},makeThickEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>8*t)).flatMap((e=>[e+0,e+1,e+4,e+4,e+1,e+5,e+1,e+2,e+5,e+5,e+2,e+6,e+2,e+3,e+6,e+6,e+3,e+7,e+3,e+0,e+7,e+7,e+0,e+4]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]};var eo=Object.freeze({__proto__:null,makeFoldedVertexArrays:makeFoldedVertexArrays,makeFoldedElementArrays:makeFoldedElementArrays,makeThickEdgesVertexArrays:makeThickEdgesVertexArrays,makeThickEdgesElementArrays:makeThickEdgesElementArrays});const makeExplodedGraph=(e,t=1e-5)=>{const r=JSON.parse(JSON.stringify(e));if(!r.edges_assignment){const t=count.edges(e)||countImplied.edges(e);r.edges_assignment=Array(t).fill("U")}let s=[];r.faceOrders?s=nudgeFacesWithFaceOrders(r):r.faces_layer&&(s=nudgeFacesWithFacesLayer(r));const o=triangulate(r);if(explode(r),o.faces){invertMap(o.faces.map).forEach(((e,o)=>{const n=s[e];n&&r.faces_vertices[o].forEach((e=>{const s=scale(n.vector,n.layer*t);r.vertices_coords[e]=add(resize(3,r.vertices_coords[e]),s)}))}))}return r},makeUniforms$1=(e,{projectionMatrix:t,viewMatrix:r,modelMatrix:s,canvas:o,opacity:n,touchPoint:a,frontColor:c,backColor:i,strokeWidth:l})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(multiplyMatrices4(t,r),s)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:multiplyMatrices4(r,s)},u_opacity:{func:"uniform1f",value:n},u_touch:{func:"uniform2fv",value:a},u_resolution:{func:"uniform2fv",value:[o.clientWidth,o.clientHeight].map((e=>e*window.devicePixelRatio||1))},u_frontColor:{func:"uniform3fv",value:hexToRGB(c)},u_backColor:{func:"uniform3fv",value:hexToRGB(i)},u_strokeWidth:{func:"uniform1f",value:l}});const foldedFormFaces=(e,t=1,r={},s={})=>{const o=makeExplodedGraph(r,s.layerNudge),n=1===t?createProgram(e,"#version 100\n\nattribute vec3 v_position;\nattribute vec3 v_normal;\n\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 front_color;\nvarying vec3 back_color;\n\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 100\nprecision mediump float;\n\nuniform float u_opacity;\nvarying vec3 front_color;\nvarying vec3 back_color;\n\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tgl_FragColor = vec4(color, u_opacity);\n}\n"):createProgram(e,"#version 300 es\n\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\n\nin vec3 v_position;\nin vec3 v_normal;\nout vec3 front_color;\nout vec3 back_color;\n\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform float u_opacity;\nin vec3 front_color;\nin vec3 back_color;\nout vec4 outColor;\n\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(color, u_opacity);\n}\n");return{program:n,vertexArrays:makeFoldedVertexArrays(e,n,o,s),elementArrays:makeFoldedElementArrays(e,t,o),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormEdges=(e,t=1,r={},s={})=>{const o=1===t?createProgram(e,"#version 100\n\nattribute vec3 v_position;\nattribute vec3 v_color;\nattribute vec3 edge_vector;\nattribute vec2 vertex_vector;\n\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\nvarying vec3 blend_color;\n\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n","#version 100\nprecision mediump float;\n\nvarying vec3 blend_color;\n\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n"):createProgram(e,"#version 300 es\n\nuniform mat4 u_matrix;\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform float u_strokeWidth;\n\nin vec3 v_position;\nin vec3 v_color;\nin vec3 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\n\nvoid main () {\n\tvec3 edge_norm = normalize(edge_vector);\n\t// axis most dissimilar to edge_vector\n\tvec3 absNorm = abs(edge_norm);\n\tvec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);\n\tvec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;\n\t// two perpendiculars. with edge_vector these make basis vectors\n\tvec3 one = cross(axis, edge_norm);\n\tvec3 two = cross(one, edge_norm);\n\tvec3 displaceNormal = normalize(\n\t\tone * vertex_vector.x + two * vertex_vector.y\n\t);\n\tvec3 displace = displaceNormal * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(v_position + displace, 1);\n\tblend_color = v_color;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n");return{program:o,vertexArrays:makeThickEdgesVertexArrays(e,o,r,s),elementArrays:makeThickEdgesElementArrays(e,t,r),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}},foldedFormFacesOutlined=(e,t=1,r={},s={})=>{const o=makeExplodedGraph(r,s.layerNudge),n=1===t?createProgram(e,"#version 100\n\nattribute vec3 v_position;\nattribute vec3 v_normal;\nattribute vec3 v_barycentric;\n\nuniform mat4 u_projection;\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\nvarying vec3 normal_color;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\n\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tbarycentric = v_barycentric;\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 100\nprecision mediump float;\n\nuniform float u_opacity;\nvarying vec3 barycentric;\nvarying vec3 front_color;\nvarying vec3 back_color;\n\nvoid main () {\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\tvec3 boundary = vec3(0.0, 0.0, 0.0)\n\t// gl_FragDepth = 0.5;\n\tgl_FragColor = any(lessThan(barycentric, vec3(0.02)))\n\t\t? vec4(boundary, u_opacity)\n\t\t: vec4(color, u_opacity);\n}\n"):createProgram(e,"#version 300 es\n\nuniform mat4 u_modelView;\nuniform mat4 u_matrix;\nuniform vec3 u_frontColor;\nuniform vec3 u_backColor;\n\nin vec3 v_position;\nin vec3 v_normal;\nin vec3 v_barycentric;\nin float v_rawEdge;\n\nout vec3 front_color;\nout vec3 back_color;\nout vec3 barycentric;\n// flat out int rawEdge;\nflat out int provokedVertex;\n\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 1);\n\tprovokedVertex = gl_VertexID;\n\tbarycentric = v_barycentric;\n\t// rawEdge = int(v_rawEdge);\n\tvec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));\n\tfloat brightness = 0.5 + light.x * 0.15 + light.z * 0.35;\n\tfront_color = u_frontColor * brightness;\n\tback_color = u_backColor * brightness;\n}\n","#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nuniform float u_opacity;\n\nin vec3 front_color;\nin vec3 back_color;\nin vec3 barycentric;\nout vec4 outColor;\n\nfloat edgeFactor(vec3 barycenter) {\n\tvec3 d = fwidth(barycenter);\n\tvec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);\n\treturn min(min(a3.x, a3.y), a3.z);\n}\n\nvoid main () {\n\tgl_FragDepth = gl_FragCoord.z;\n\tvec3 color = gl_FrontFacing ? front_color : back_color;\n\toutColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);\n}\n");return{program:n,vertexArrays:makeFoldedVertexArrays(e,n,o,s),elementArrays:makeFoldedElementArrays(e,t,o),flags:[e.DEPTH_TEST],makeUniforms:makeUniforms$1}};var to=Object.freeze({__proto__:null,foldedFormFaces:foldedFormFaces,foldedFormEdges:foldedFormEdges,foldedFormFacesOutlined:foldedFormFacesOutlined});const ro={B:[.3,.3,.3],b:[.3,.3,.3],V:[.2,.4,.6],v:[.2,.4,.6],M:[.75,.25,.15],m:[.75,.25,.15],F:[.2,.2,.2],f:[.2,.2,.2],U:[.2,.2,.2],u:[.2,.2,.2]},make2D$1=e=>e.map((e=>[0,1].map((t=>e[t]||0)))),makeCPEdgesVertexData=(e,t=ro)=>{if(!e||!e.vertices_coords||!e.edges_vertices)return[];const r=make2D$1(e.edges_vertices.flatMap((t=>t.map((t=>e.vertices_coords[t])))).flatMap((e=>[e,e]))),s=make2D$1(makeEdgesVector(e));return{vertices_coords:r,vertices_color:e.edges_assignment?e.edges_assignment.flatMap((e=>[t[e],t[e],t[e],t[e]])):e.edges_vertices.flatMap((()=>[t.U,t.U,t.U,t.U])),verticesEdgesVector:s.flatMap((e=>[e,e,e,e])),vertices_vector:e.edges_vertices.flatMap((()=>[[1,0],[-1,0],[-1,0],[1,0]]))}};var so=Object.freeze({__proto__:null,makeCPEdgesVertexData:makeCPEdgesVertexData});const makeCPEdgesVertexArrays=(e,t,r)=>{if(!r||!r.vertices_coords||!r.edges_vertices)return[];const{vertices_coords:s,vertices_color:o,verticesEdgesVector:n,vertices_vector:a}=makeCPEdgesVertexData(r);return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array(s.flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:o[0].length,data:new Float32Array(o.flat())},{location:e.getAttribLocation(t,"edge_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:n[0].length,data:new Float32Array(n.flat())},{location:e.getAttribLocation(t,"vertex_vector"),buffer:e.createBuffer(),type:e.FLOAT,length:a[0].length,data:new Float32Array(a.flat())}].filter((e=>-1!==e.location))},makeCPEdgesElementArrays=(e,t=1,r={})=>{if(!r||!r.edges_vertices)return[];const s=r.edges_vertices.map(((e,t)=>4*t)).flatMap((e=>[e+0,e+1,e+2,e+2,e+3,e+0]));return[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(s):new Uint16Array(s)}]},makeCPFacesVertexArrays=(e,t,r)=>{if(!r||!r.vertices_coords)return[];const s=r.vertices_coords.map((()=>[.11,.11,.11]));return[{location:e.getAttribLocation(t,"v_position"),buffer:e.createBuffer(),type:e.FLOAT,length:2,data:new Float32Array((o=r.vertices_coords,o.map((e=>[0,1].map((t=>e[t]||0))))).flat())},{location:e.getAttribLocation(t,"v_color"),buffer:e.createBuffer(),type:e.FLOAT,length:s[0].length,data:new Float32Array(s.flat())}].filter((e=>-1!==e.location));var o},makeCPFacesElementArrays=(e,t=1,r={})=>r&&r.vertices_coords&&r.faces_vertices?[{mode:e.TRIANGLES,buffer:e.createBuffer(),data:2===t?new Uint32Array(triangulateConvexFacesVertices(r).flat()):new Uint16Array(triangulateConvexFacesVertices(r).flat())}]:[];var oo=Object.freeze({__proto__:null,makeCPEdgesVertexArrays:makeCPEdgesVertexArrays,makeCPEdgesElementArrays:makeCPEdgesElementArrays,makeCPFacesVertexArrays:makeCPFacesVertexArrays,makeCPFacesElementArrays:makeCPFacesElementArrays});const makeUniforms=(e,{projectionMatrix:t,viewMatrix:r,modelMatrix:s,strokeWidth:o})=>({u_matrix:{func:"uniformMatrix4fv",value:multiplyMatrices4(multiplyMatrices4(t,r),s)},u_projection:{func:"uniformMatrix4fv",value:t},u_modelView:{func:"uniformMatrix4fv",value:multiplyMatrices4(r,s)},u_strokeWidth:{func:"uniform1f",value:o/2}});var no="#version 100\nprecision mediump float;\n\nvarying vec3 blend_color;\n\nvoid main () {\n\tgl_FragColor = vec4(blend_color.rgb, 1);\n}\n",ao="#version 300 es\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n  precision highp float;\n#else\n  precision mediump float;\n#endif\n\nin vec3 blend_color;\nout vec4 outColor;\n \nvoid main() {\n\toutColor = vec4(blend_color.rgb, 1);\n}\n";const cpFacesV1=(e,t=1,r={})=>{const s=createProgram(e,"#version 100\n\nuniform mat4 u_matrix;\n\nattribute vec2 v_position;\nattribute vec3 v_color;\nvarying vec3 blend_color;\n\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = v_color;\n}\n",no);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,r),elementArrays:makeCPFacesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}},cpEdgesV1=(e,t=1,r={})=>{const s=createProgram(e,"#version 100\n\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\n\nattribute vec2 v_position;\nattribute vec3 v_color;\nattribute vec2 edge_vector;\nattribute vec2 vertex_vector;\nvarying vec3 blend_color;\n\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",no);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,r),elementArrays:makeCPEdgesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}},cpFacesV2=(e,t=2,r={})=>{const s=createProgram(e,"#version 300 es\n\nuniform mat4 u_matrix;\n\nin vec2 v_position;\nin vec3 v_color;\nout vec3 blend_color;\n\nvoid main () {\n\tgl_Position = u_matrix * vec4(v_position, 0, 1);\n\tblend_color = v_color;\n}\n",ao);return{program:s,vertexArrays:makeCPFacesVertexArrays(e,s,r),elementArrays:makeCPFacesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}},cpEdgesV2=(e,t=2,r={})=>{const s=createProgram(e,"#version 300 es\n\nuniform mat4 u_matrix;\nuniform float u_strokeWidth;\n\nin vec2 v_position;\nin vec3 v_color;\nin vec2 edge_vector;\nin vec2 vertex_vector;\nout vec3 blend_color;\n\nvoid main () {\n\tfloat sign = vertex_vector[0];\n\tvec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * u_strokeWidth;\n\tgl_Position = u_matrix * vec4(side + v_position, 0, 1);\n\tblend_color = v_color;\n}\n",ao);return{program:s,vertexArrays:makeCPEdgesVertexArrays(e,s,r),elementArrays:makeCPEdgesElementArrays(e,t,r),flags:[],makeUniforms:makeUniforms}};var co=Object.freeze({__proto__:null,cpFacesV1:cpFacesV1,cpEdgesV1:cpEdgesV1,cpFacesV2:cpFacesV2,cpEdgesV2:cpEdgesV2});var io=Object.assign(Object.create(null),{createProgram:createProgram,initialize:(e,t)=>{const r=[null,"webgl","webgl2"],s=window.devicePixelRatio||1;if(e.width=e.clientWidth*s,e.height=e.clientHeight*s,t)return{gl:e.getContext(r[t]),version:t};const o=e.getContext(r[2]);if(o)return{gl:o,version:2};const n=e.getContext(r[1]);if(n)return{gl:n,version:1};throw new Error(S)},foldedForm:(e,t=1,r={},s={})=>{const o=[];return!1!==s.faces&&(!1===s.outlines?o.push(foldedFormFaces(e,t,r,s)):o.push(foldedFormFacesOutlined(e,t,r,s))),!0===s.edges&&o.push(foldedFormEdges(e,t,r,s)),o},creasePattern:(e,t=1,r={})=>1===t?[cpFacesV1(e,t,r),cpEdgesV1(e,t,r)]:[cpFacesV2(e,t,r),cpEdgesV2(e,t,r)]},Ys,Xs,eo,Qs,to,oo,so,co);const lo=Object.assign(T,vt,{math:Mt,axiom:axiom,diagram:Nt,layer:sr,singleVertex:nr,text:ar,convert:gr,webgl:io});return Object.defineProperty(lo,"use",{enumerable:!1,value:function(e){null!=e&&"function"==typeof e.linker&&e.linker(this)}.bind(lo)}),k||(lo.use(FOLDtoSVG),lo.use(SVG)),Object.defineProperty(lo,"window",{enumerable:!1,set:e=>{var t;(t=e).document||(t.document=(e=>(new e.DOMParser).parseFromString("<!DOCTYPE html><title>.</title>","text/html"))(t)),V.window=t,V.window,SVG.window=e}}),lo}));
