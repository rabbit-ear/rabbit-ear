/* Rabbit Ear 0.9.33 alpha 2023-02-21 (c) Kraft, MIT License */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.ear = factory());
})(this, (function () { 'use strict';

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// this is a really verbose way of coding this but so far this is the best
	// way i can find to compress references in the minified .js file
	const _undefined = "undefined";
	const _number = "number";
	const _object = "object";
	const _index = "index";

	const _vertices = "vertices";
	const _edges = "edges";
	const _faces = "faces";
	const _boundaries = "boundaries";
	const _vertices_coords = "vertices_coords";
	const _edges_vertices = "edges_vertices";
	const _faces_vertices = "faces_vertices";
	const _faces_edges = "faces_edges";
	const _edges_assignment = "edges_assignment";
	const _edges_foldAngle = "edges_foldAngle";
	const _frame_parent = "frame_parent";
	const _frame_inherit = "frame_inherit";
	const _faces_layer = "faces_layer";

	const _boundary = "boundary";
	const _front = "front";
	const _back = "back";
	const _foldedForm = "foldedForm";
	const _black = "black";
	const _white = "white";
	const _none = "none";

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// compare to "undefined", the string
	const isBrowser$1 = typeof window !== _undefined
		&& typeof window.document !== _undefined;

	const isNode = typeof process !== _undefined
		&& process.versions != null
		&& process.versions.node != null;

	// // for debugging, uncomment to log system on boot
	// const operating_systems = [
	//   isBrowser ? "browser" : undefined,
	//   isWebWorker ? "web-worker" : undefined,
	//   isNode ? "node" : undefined,
	// ].filter(a => a !== undefined).join(" ");
	// console.log(`RabbitEar [${operating_systems}]`);

	var Messages$1 = {
		planarize: "graph could not planarize",
		manifold: "valid manifold required",
		graphCycle: "cycle not allowed",
		planarBoundary: "planar boundary detection error, bad graph",
		circularEdge: "circular edges not allowed",
		replaceModifyParam: "replace() index < value. indices parameter modified",
		replaceUndefined: "replace() generated undefined",
		flatFoldAngles: "foldAngles cannot be determined from flat-folded faces without an assignment",
		noWebGL: "WebGl not Supported",
		convexFace: "only convex faces are supported",
		window: "window not set; if using node/deno include package @xmldom/xmldom and set ear.window = xmldom",
		nonConvexTriangulation: "non-convex triangulation requires vertices_coords",
		backendStylesheet: "svgToFold found <style> in <svg>. rendering will be incomplete unless run in a major browser.",
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const windowContainer = { window: undefined };

	const buildDocument = (newWindow) => new newWindow.DOMParser()
		.parseFromString("<!DOCTYPE html><title>.</title>", "text/html");

	const setWindow = (newWindow) => {
		// make sure window has a document. xmldom does not, and requires it be built.
		if (!newWindow.document) { newWindow.document = buildDocument(newWindow); }
		windowContainer.window = newWindow;
		return windowContainer.window;
	};
	// if we are in the browser, by default use the browser's "window".
	if (isBrowser$1) { windowContainer.window = window; }
	/**
	 * @description get the "window" object, which should have
	 * DOMParser, XMLSerializer, and document.
	 */
	const RabbitEarWindow = () => {
		if (windowContainer.window === undefined) {
			throw new Error(Messages$1.window);
		}
		return windowContainer.window;
	};

	/* Math (c) Kraft, MIT License */
	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description this epsilon is used throughout the library
	 * @constant {number}
	 * @default
	 * @linkcode Math ./src/general/constants.js 6
	 */
	const EPSILON = 1e-6;
	/**
	 * @description radians to degrees
	 * @constant {number}
	 * @default
	 * @linkcode Math ./src/general/constants.js 11
	 */
	const R2D = 180 / Math.PI;
	/**
	 * @description degrees to radians
	 * @constant {number}
	 * @default
	 * @linkcode Math ./src/general/constants.js 16
	 */
	const D2R = Math.PI / 180;
	/**
	 * @description pi x 2
	 * @constant {number}
	 * @default
	 * @linkcode Math ./src/general/constants.js 21
	 */
	const TWO_PI = Math.PI * 2;

	var constant = /*#__PURE__*/Object.freeze({
		__proto__: null,
		D2R: D2R,
		EPSILON: EPSILON,
		R2D: R2D,
		TWO_PI: TWO_PI
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * algebra operations on vectors (mostly).
	 *
	 * vectors are assumed to be Javascript Arrays objects /
	 * contain the Javascript Array prototype, as these methods depend
	 * on the use of "map", "reduce" and other Array functions.
	 *
	 * ({x: y:} vectors as Javascript Objects will not work)
	 *
	 * many of these operations can handle vectors of arbitrary dimension
	 * in which case there are two vectors as input, it will be noted that
	 * "dimensions match first parameter", you should verify that the second
	 * parameter is at least as long as the first (okay if it is longer)
	 *
	 * when a function name ends with a number (magnitude2) the input vector's
	 * dimension is assumed to be this number.
	 */
	/**
	 * @description many methods here are operations on two arrays where
	 * the first array determines the number of loops. it's possible the
	 * array sizes mismatch, in which case, fill in any empty data with 0.
	 */
	const safeAdd = (a, b) => a + (b || 0);
	/**
	 * @description compute the magnitude an n-dimensional vector
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 32
	 */
	const magnitude = v => Math.sqrt(v
		.map(n => n * n)
		.reduce(safeAdd, 0));
	/**
	 * @description compute the magnitude a 2D vector
	 * @param {number[]} v one 2D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 41
	 */
	const magnitude2 = v => Math.sqrt(v[0] * v[0] + v[1] * v[1]);
	/**
	 * @description compute the magnitude a 3D vector
	 * @param {number[]} v one 3D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 48
	 */
	const magnitude3 = v => Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
	/**
	 * @description compute the square-magnitude an n-dimensional vector
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 55
	 */
	const magSquared = v => v
		.map(n => n * n)
		.reduce(safeAdd, 0);
	/**
	 * @description normalize the input vector and return a new vector as a copy
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number[]} one vector, dimension matching the input vector
	 * @linkcode Math ./src/algebra/vectors.js 64
	 */
	const normalize = (v) => {
		const m = magnitude(v);
		return m === 0 ? v : v.map(c => c / m);
	};
	/**
	 * @description normalize the input vector and return a new vector as a copy
	 * @param {number[]} v one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 74
	 */
	const normalize2 = (v) => {
		const m = magnitude2(v);
		return m === 0 ? v : [v[0] / m, v[1] / m];
	};
	/**
	 * @description normalize the input vector and return a new vector as a copy
	 * @param {number[]} v one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 84
	 */
	const normalize3 = (v) => {
		const m = magnitude3(v);
		return m === 0 ? v : [v[0] / m, v[1] / m, v[2] / m];
	};
	/**
	 * @description scale an input vector by one number, return a copy.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number} s one scalar
	 * @returns {number[]} one vector
	 * @linkcode Math ./src/algebra/vectors.js 95
	 */
	const scale$1 = (v, s) => v.map(n => n * s);
	/**
	 * @description scale an input vector by one number, return a copy.
	 * @param {number[]} v one 2D vector
	 * @param {number} s one scalar
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 103
	 */
	const scale2 = (v, s) => [v[0] * s, v[1] * s];
	/**
	 * @description scale an input vector by one number, return a copy.
	 * @param {number[]} v one 3D vector
	 * @param {number} s one scalar
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 111
	 */
	const scale3 = (v, s) => [v[0] * s, v[1] * s, v[2] * s];
	/**
	 * @description add two vectors and return the sum as another vector,
	 * do not modify the input vectors.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number[]} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 120
	 */
	const add = (v, u) => v.map((n, i) => n + (u[i] || 0));
	/**
	 * @description add two vectors and return the sum as another vector,
	 * do not modify the input vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 129
	 */
	const add2 = (v, u) => [v[0] + u[0], v[1] + u[1]];
	/**
	 * @description add two vectors and return the sum as another vector,
	 * do not modify the input vectors.
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 138
	 */
	const add3 = (v, u) => [v[0] + u[0], v[1] + u[1], v[2] + u[2]];
	/**
	 * @description subtract the second vector from the first, return the result as a copy.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number[]} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 146
	 */
	const subtract = (v, u) => v.map((n, i) => n - (u[i] || 0));
	/**
	 * @description subtract the second vector from the first, return the result as a copy.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 154
	 */
	const subtract2 = (v, u) => [v[0] - u[0], v[1] - u[1]];
	/**
	 * @description subtract the second vector from the first, return the result as a copy.
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 162
	 */
	const subtract3 = (v, u) => [v[0] - u[0], v[1] - u[1], v[2] - u[2]];
	/**
	 * @description compute the dot product of two vectors.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 170
	 */
	const dot = (v, u) => v
		.map((_, i) => v[i] * u[i])
		.reduce(safeAdd, 0);
	/**
	 * @description compute the dot product of two 2D vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 180
	 */
	const dot2 = (v, u) => v[0] * u[0] + v[1] * u[1];
	/**
	 * @description compute the dot product of two 3D vectors.
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 188
	 */
	const dot3 = (v, u) => v[0] * u[0] + v[1] * u[1] + v[2] * u[2];
	/**
	 * @description compute the midpoint of two vectors.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 196
	 */
	const midpoint = (v, u) => v.map((n, i) => (n + u[i]) / 2);
	/**
	 * @description compute the midpoint of two 2D vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 204
	 */
	const midpoint2 = (v, u) => scale2(add2(v, u), 0.5);
	/**
	 * @description compute the midpoint of two 2D vectors.
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 212
	 */
	const midpoint3 = (v, u) => scale3(add3(v, u), 0.5);
	/**
	 * @description the average of N number of vectors (not numbers),
	 * similar to midpoint but this can accept more than 2 inputs.
	 * @param {number[]} ...args any number of input vectors
	 * @returns {number[]} one vector, dimension matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 220
	 */
	const average = function () {
		if (arguments.length === 0) { return []; }
		const dimension = (arguments[0].length > 0) ? arguments[0].length : 0;
		const sum = Array(dimension).fill(0);
		Array.from(arguments)
			.forEach(vec => sum
				.forEach((_, i) => { sum[i] += vec[i] || 0; }));
		return sum.map(n => n / arguments.length);
	};
	/**
	 * @description linear interpolate between two vectors
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @param {number} t one scalar between 0 and 1 (not clamped)
	 * @returns {number[]} one vector, dimensions matching first parameter
	 * @linkcode Math ./src/algebra/vectors.js 237
	 */
	const lerp = (v, u, t) => {
		const inv = 1.0 - t;
		return v.map((n, i) => n * inv + (u[i] || 0) * t);
	};
	/**
	 * @description the determinant of the matrix of the 2 vectors
	 * (possible bad name, 2D cross product is undefined)
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one scalar; the determinant; the magnitude of the vector
	 * @linkcode Math ./src/algebra/vectors.js 249
	 */
	const cross2 = (v, u) => v[0] * u[1] - v[1] * u[0];
	/**
	 * @description the 3D cross product of two 3D vectors
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number[]} one 3D vector
	 * @linkcode Math ./src/algebra/vectors.js 257
	 */
	const cross3 = (v, u) => [
		v[1] * u[2] - v[2] * u[1],
		v[2] * u[0] - v[0] * u[2],
		v[0] * u[1] - v[1] * u[0],
	];
	/**
	 * @description compute the distance between two vectors
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 269
	 */
	const distance = (v, u) => Math.sqrt(v
		.map((_, i) => (v[i] - u[i]) ** 2)
		.reduce(safeAdd, 0));
	/**
	 * @description compute the distance between two 2D vectors
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 279
	 */
	const distance2 = (v, u) => {
		const p = v[0] - u[0];
		const q = v[1] - u[1];
		return Math.sqrt((p * p) + (q * q));
	};
	/**
	 * @description compute the distance between two 3D vectors
	 * @param {number[]} v one 3D vector
	 * @param {number[]} u one 3D vector
	 * @returns {number} one scalar
	 * @linkcode Math ./src/algebra/vectors.js 291
	 */
	const distance3 = (v, u) => {
		const a = v[0] - u[0];
		const b = v[1] - u[1];
		const c = v[2] - u[2];
		return Math.sqrt((a * a) + (b * b) + (c * c));
	};
	/**
	 * @description return a copy of the input vector where each element's sign flipped
	 * @param {number[]} v one vector, n-dimensions
	 * @returns {number[]} one vector, dimensions matching input parameter
	 * @linkcode Math ./src/algebra/vectors.js 303
	 */
	const flip = v => v.map(n => -n);
	/**
	 * @description return a copy of the input vector rotated 90 degrees counter-clockwise
	 * @param {number[]} v one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 310
	 */
	const rotate90 = v => [-v[1], v[0]];
	/**
	 * @description return a copy of the input vector rotated 270 degrees counter-clockwise
	 * @param {number[]} v one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/algebra/vectors.js 317
	 */
	const rotate270 = v => [v[1], -v[0]];
	/**
	 * @description check if a vector is degenerate, meaning its magnitude is below an epsilon limit.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} is the magnitude of the vector smaller than the epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 325
	 */
	const degenerate = (v, epsilon = EPSILON) => v
		.map(n => Math.abs(n))
		.reduce(safeAdd, 0) < epsilon;
	/**
	 * @description check if two already normalized vectors are parallel
	 * to each other, within an epsilon. Parallel includes the case where
	 * the vectors are exactly 180 degrees flipped from one another.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} are the two vectors parallel within an epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 338
	 */
	const parallelNormalized = (v, u, epsilon = EPSILON) => 1 - Math
		.abs(dot(v, u)) < epsilon;
	/**
	 * @description check if two vectors are parallel to each other,
	 * within an epsilon. Parallel includes the case where the
	 * vectors are exactly 180 degrees flipped from one another.
	 * @param {number[]} v one vector, n-dimensions
	 * @param {number[]} u one vector, n-dimensions
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} are the two vectors parallel within an epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 350
	 */
	const parallel = (v, u, epsilon = EPSILON) => parallelNormalized(
		normalize(v),
		normalize(u),
		epsilon,
	);
	/**
	 * @description check if two 2D vectors are parallel to each other within an epsilon
	 * @param {number[]} v one 2D vector
	 * @param {number[]} u one 2D vector
	 * @param {number} [epsilon=1e-6] an optional epsilon with a default value of 1e-6
	 * @returns {boolean} are the two vectors parallel within an epsilon?
	 * @linkcode Math ./src/algebra/vectors.js 363
	 */
	const parallel2 = (v, u, epsilon = EPSILON) => Math
		.abs(cross2(v, u)) < epsilon;
	/**
	 * @description Resize a vector to a particular length (duplicating it
	 * in memory in the process) by either lengthening or shortening it.
	 * In the case of lengthening, fill 0.
	 * @param {number} dimension the desired length
	 * @param {number[]} vector the vector to resize
	 * @returns {number[]} a copy of the vector resized to the desired length.
	 * @linkcode Math ./src/algebra/vectors.js 374
	 */
	const resize = (dimension, vector) => (vector.length === dimension
		? vector
		: Array(dimension).fill(0).map((z, i) => (vector[i] ? vector[i] : z)));
	/**
	 * @description Make the two vectors match in dimension by appending the
	 * smaller vector with 0s to match the dimension of the larger vector.
	 * @param {number[]} a a vector
	 * @param {number[]} b a vector
	 * @param {number[][]} an array containing two vectors, a copy of
	 * each of the input parameters.
	 * @linkcode Math ./src/algebra/vectors.js 386
	 */
	const resizeUp = (a, b) => [a, b]
		.map(v => resize(Math.max(a.length, b.length), v));

	var vector = /*#__PURE__*/Object.freeze({
		__proto__: null,
		add: add,
		add2: add2,
		add3: add3,
		average: average,
		cross2: cross2,
		cross3: cross3,
		degenerate: degenerate,
		distance: distance,
		distance2: distance2,
		distance3: distance3,
		dot: dot,
		dot2: dot2,
		dot3: dot3,
		flip: flip,
		lerp: lerp,
		magSquared: magSquared,
		magnitude: magnitude,
		magnitude2: magnitude2,
		magnitude3: magnitude3,
		midpoint: midpoint,
		midpoint2: midpoint2,
		midpoint3: midpoint3,
		normalize: normalize,
		normalize2: normalize2,
		normalize3: normalize3,
		parallel: parallel,
		parallel2: parallel2,
		parallelNormalized: parallelNormalized,
		resize: resize,
		resizeUp: resizeUp,
		rotate270: rotate270,
		rotate90: rotate90,
		scale: scale$1,
		scale2: scale2,
		scale3: scale3,
		subtract: subtract,
		subtract2: subtract2,
		subtract3: subtract3
	});

	/* Math (c) Kraft, MIT License */
	/**
	 * Math (c) Kraft
	 */
	/**
	 * 2x3 matrix methods for two dimensional transformations.
	 * the third column is a 2D translation vector
	 */
	/**
	 * @description the identity matrix for 2x2 matrices
	 * @constant {number[]}
	 * @default
	 * @linkcode Math ./src/algebra/matrix2.js 10
	 */
	const identity2x2 = [1, 0, 0, 1];
	/**
	 * @description the identity matrix for 2x3 matrices (zero translation)
	 * @constant {number[]}
	 * @default
	 * @linkcode Math ./src/algebra/matrix2.js 15
	 */
	const identity2x3 = identity2x2.concat(0, 0);
	/**
	 * @param {number[]} vector, in array form
	 * @param {number[]} matrix, in array form
	 * @returns {number[]} vector, the input vector transformed by the matrix
	 * @linkcode Math ./src/algebra/matrix2.js 22
	 */
	const multiplyMatrix2Vector2 = (matrix, vector) => [
		matrix[0] * vector[0] + matrix[2] * vector[1] + matrix[4],
		matrix[1] * vector[0] + matrix[3] * vector[1] + matrix[5],
	];
	/**
	 * @param {number[]} matrix, in array form
	 * @param {number[]} vector of the line
	 * @param {number[]} origin of the line
	 * @returns {VecLine} the transformed line in vector-origin form
	 * @linkcode Math ./src/algebra/matrix2.js 33
	 */
	const multiplyMatrix2Line2 = (matrix, vector, origin) => ({
		vector: [
			matrix[0] * vector[0] + matrix[2] * vector[1],
			matrix[1] * vector[0] + matrix[3] * vector[1],
		],
		origin: [
			matrix[0] * origin[0] + matrix[2] * origin[1] + matrix[4],
			matrix[1] * origin[0] + matrix[3] * origin[1] + matrix[5],
		],
	});
	/**
	 * @description Multiply two matrices where the left/right order
	 * matches what you would see on a page
	 * @param {number[]} m1 a matrix as an array of numbers
	 * @param {number[]} m2 a matrix as an array of numbers
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 49
	 */
	const multiplyMatrices2 = (m1, m2) => [
		m1[0] * m2[0] + m1[2] * m2[1],
		m1[1] * m2[0] + m1[3] * m2[1],
		m1[0] * m2[2] + m1[2] * m2[3],
		m1[1] * m2[2] + m1[3] * m2[3],
		m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
		m1[1] * m2[4] + m1[3] * m2[5] + m1[5],
	];
	/**
	 * @description calculate the determinant of a 2x3 or 2x2 matrix.
	 * in the case of 2x3, the translation component is ignored.
	 * @param {number[]} m a matrix as an array of numbers
	 * @returns {number} the determinant of the matrix
	 * @linkcode Math ./src/algebra/matrix2.js 64
	 */
	const determinant2 = m => m[0] * m[3] - m[1] * m[2];
	/**
	 * @description invert a 2x3 matrix
	 * @param {number[]} m a matrix as an array of numbers
	 * @returns {number[]|undefined} the inverted matrix, or undefined if not possible
	 * @linkcode Math ./src/algebra/matrix2.js 71
	 */
	const invertMatrix2 = (m) => {
		const det = determinant2(m);
		if (Math.abs(det) < 1e-6
			|| Number.isNaN(det)
			|| !Number.isFinite(m[4])
			|| !Number.isFinite(m[5])) {
			return undefined;
		}
		return [
			m[3] / det,
			-m[1] / det,
			-m[2] / det,
			m[0] / det,
			(m[2] * m[5] - m[3] * m[4]) / det,
			(m[1] * m[4] - m[0] * m[5]) / det,
		];
	};
	/**
	 * @param {number} x
	 * @param {number} y
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 94
	 */
	const makeMatrix2Translate = (x = 0, y = 0) => identity2x2.concat(x, y);
	/**
	 * @param {number[]} non-uniform scaling vector for each axis
	 * @param {number[]} origin homothetic center of the scale, default [0, 0]
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 100
	 */
	const makeMatrix2Scale = (scale = [1, 1], origin = [0, 0]) => [
		scale[0],
		0,
		0,
		scale[1],
		scale[0] * -origin[0] + origin[0],
		scale[1] * -origin[1] + origin[1],
	];
	/**
	 * @param {number} scale scale factor
	 * @param {number[]} origin homothetic center of the scale, default [0, 0]
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 100
	 */
	const makeMatrix2UniformScale = (scale = 1, origin = [0, 0]) => (
		makeMatrix2Scale([scale, scale], origin)
	);
	/**
	 * @param {number} angle the angle of rotation, origin of transformation
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 113
	 */
	const makeMatrix2Rotate = (angle, origin = [0, 0]) => {
		const cos = Math.cos(angle);
		const sin = Math.sin(angle);
		return [
			cos,
			sin,
			-sin,
			cos,
			origin[0],
			origin[1],
		];
	};
	/**
	 * remember vector comes before origin. origin comes last, so that it's easy
	 * to leave it empty and make a reflection through the origin.
	 * @param {number[]} vector one 2D vector specifying the reflection axis
	 * @param {number[]} [origin=[0,0]] 2D origin specifying a point of reflection
	 * @returns {number[]} matrix
	 * @linkcode Math ./src/algebra/matrix2.js 132
	 */
	const makeMatrix2Reflect = (vector, origin = [0, 0]) => {
		// the line of reflection passes through origin, runs along vector
		const angle = Math.atan2(vector[1], vector[0]);
		const cosAngle = Math.cos(angle);
		const sinAngle = Math.sin(angle);
		const cos_Angle = Math.cos(-angle);
		const sin_Angle = Math.sin(-angle);
		const a = cosAngle * cos_Angle + sinAngle * sin_Angle;
		const b = cosAngle * -sin_Angle + sinAngle * cos_Angle;
		const c = sinAngle * cos_Angle + -cosAngle * sin_Angle;
		const d = sinAngle * -sin_Angle + -cosAngle * cos_Angle;
		const tx = origin[0] + a * -origin[0] + -origin[1] * c;
		const ty = origin[1] + b * -origin[0] + -origin[1] * d;
		return [a, b, c, d, tx, ty];
	};

	var matrix2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		determinant2: determinant2,
		identity2x2: identity2x2,
		identity2x3: identity2x3,
		invertMatrix2: invertMatrix2,
		makeMatrix2Reflect: makeMatrix2Reflect,
		makeMatrix2Rotate: makeMatrix2Rotate,
		makeMatrix2Scale: makeMatrix2Scale,
		makeMatrix2Translate: makeMatrix2Translate,
		makeMatrix2UniformScale: makeMatrix2UniformScale,
		multiplyMatrices2: multiplyMatrices2,
		multiplyMatrix2Line2: multiplyMatrix2Line2,
		multiplyMatrix2Vector2: multiplyMatrix2Vector2
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description the identity matrix for 3x3 matrices
	 * @constant {number[]}
	 * @default
	 * @linkcode Math ./src/algebra/matrix3.js 13
	 */
	const identity3x3 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
	/**
	 * @description the identity matrix for 3x4 matrices (zero translation)
	 * @constant {number[]}
	 * @default
	 * @linkcode Math ./src/algebra/matrix3.js 18
	 */
	const identity3x4 = Object.freeze(identity3x3.concat(0, 0, 0));
	/**
	 * @description test if a 3x4 matrix is the identity matrix within an epsilon
	 * @param {number[]} m a 3x4 matrix
	 * @returns {boolean} true if the matrix is the identity matrix
	 * @linkcode Math ./src/algebra/matrix3.js 25
	 */
	const isIdentity3x4 = m => identity3x4
		.map((n, i) => Math.abs(n - m[i]) < EPSILON)
		.reduce((a, b) => a && b, true);
	/**
	 * @description multiply one 3D vector by a 3x4 matrix
	 * @param {number[]} m one matrix in array form
	 * @param {number[]} vector in array form
	 * @returns {number[]} the transformed vector
	 * @linkcode Math ./src/algebra/matrix3.js 35
	 */
	const multiplyMatrix3Vector3 = (m, vector) => [
		m[0] * vector[0] + m[3] * vector[1] + m[6] * vector[2] + m[9],
		m[1] * vector[0] + m[4] * vector[1] + m[7] * vector[2] + m[10],
		m[2] * vector[0] + m[5] * vector[1] + m[8] * vector[2] + m[11],
	];
	/**
	 * @description multiply one 3D line by a 3x4 matrix
	 * @param {number[]} m one matrix in array form
	 * @param {number[]} vector the vector of the line
	 * @param {number[]} origin the origin of the line
	 * @returns {VecLine} the transformed line in vector-origin form
	 * @linkcode Math ./src/algebra/matrix3.js 48
	 */
	const multiplyMatrix3Line3 = (m, vector, origin) => ({
		vector: [
			m[0] * vector[0] + m[3] * vector[1] + m[6] * vector[2],
			m[1] * vector[0] + m[4] * vector[1] + m[7] * vector[2],
			m[2] * vector[0] + m[5] * vector[1] + m[8] * vector[2],
		],
		origin: [
			m[0] * origin[0] + m[3] * origin[1] + m[6] * origin[2] + m[9],
			m[1] * origin[0] + m[4] * origin[1] + m[7] * origin[2] + m[10],
			m[2] * origin[0] + m[5] * origin[1] + m[8] * origin[2] + m[11],
		],
	});
	/**
	 * @description multiply two 3x4 matrices together
	 * @param {number[]} m1 the first matrix
	 * @param {number[]} m2 the second matrix
	 * @returns {number[]} one matrix, the product of the two
	 * @linkcode Math ./src/algebra/matrix3.js 67
	 */
	const multiplyMatrices3 = (m1, m2) => [
		m1[0] * m2[0] + m1[3] * m2[1] + m1[6] * m2[2],
		m1[1] * m2[0] + m1[4] * m2[1] + m1[7] * m2[2],
		m1[2] * m2[0] + m1[5] * m2[1] + m1[8] * m2[2],
		m1[0] * m2[3] + m1[3] * m2[4] + m1[6] * m2[5],
		m1[1] * m2[3] + m1[4] * m2[4] + m1[7] * m2[5],
		m1[2] * m2[3] + m1[5] * m2[4] + m1[8] * m2[5],
		m1[0] * m2[6] + m1[3] * m2[7] + m1[6] * m2[8],
		m1[1] * m2[6] + m1[4] * m2[7] + m1[7] * m2[8],
		m1[2] * m2[6] + m1[5] * m2[7] + m1[8] * m2[8],
		m1[0] * m2[9] + m1[3] * m2[10] + m1[6] * m2[11] + m1[9],
		m1[1] * m2[9] + m1[4] * m2[10] + m1[7] * m2[11] + m1[10],
		m1[2] * m2[9] + m1[5] * m2[10] + m1[8] * m2[11] + m1[11],
	];
	/**
	 * @description calculate the determinant of a 3x4 or 3x3 matrix.
	 * in the case of 3x4, the translation component is ignored.
	 * @param {number[]} m one matrix in array form
	 * @returns {number} the determinant of the matrix
	 * @linkcode Math ./src/algebra/matrix3.js 88
	 */
	const determinant3 = m => (
		m[0] * m[4] * m[8]
		- m[0] * m[7] * m[5]
		- m[3] * m[1] * m[8]
		+ m[3] * m[7] * m[2]
		+ m[6] * m[1] * m[5]
		- m[6] * m[4] * m[2]
	);
	/**
	 * @description invert a 3x4 matrix
	 * @param {number[]} m one matrix in array form
	 * @returns {number[]|undefined} the inverted matrix, or undefined if not possible
	 * @linkcode Math ./src/algebra/matrix3.js 102
	 */
	const invertMatrix3 = (m) => {
		const det = determinant3(m);
		if (Math.abs(det) < 1e-6 || Number.isNaN(det)
			|| !Number.isFinite(m[9]) || !Number.isFinite(m[10]) || !Number.isFinite(m[11])) {
			return undefined;
		}
		const inv = [
			m[4] * m[8] - m[7] * m[5],
			-m[1] * m[8] + m[7] * m[2],
			m[1] * m[5] - m[4] * m[2],
			-m[3] * m[8] + m[6] * m[5],
			m[0] * m[8] - m[6] * m[2],
			-m[0] * m[5] + m[3] * m[2],
			m[3] * m[7] - m[6] * m[4],
			-m[0] * m[7] + m[6] * m[1],
			m[0] * m[4] - m[3] * m[1],
			-m[3] * m[7] * m[11] + m[3] * m[8] * m[10] + m[6] * m[4] * m[11]
				- m[6] * m[5] * m[10] - m[9] * m[4] * m[8] + m[9] * m[5] * m[7],
			m[0] * m[7] * m[11] - m[0] * m[8] * m[10] - m[6] * m[1] * m[11]
				+ m[6] * m[2] * m[10] + m[9] * m[1] * m[8] - m[9] * m[2] * m[7],
			-m[0] * m[4] * m[11] + m[0] * m[5] * m[10] + m[3] * m[1] * m[11]
				- m[3] * m[2] * m[10] - m[9] * m[1] * m[5] + m[9] * m[2] * m[4],
		];
		const invDet = 1.0 / det;
		return inv.map(n => n * invDet);
	};
	/**
	 * @description make a 3x4 matrix representing a translation in 3D
	 * @param {number} [x=0] the x component of the translation
	 * @param {number} [y=0] the y component of the translation
	 * @param {number} [z=0] the z component of the translation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 136
	 */
	const makeMatrix3Translate = (x = 0, y = 0, z = 0) => identity3x3.concat(x, y, z);

	// i0 and i1 direct which columns and rows are filled
	// sgn manages right hand rule
	const singleAxisRotate = (angle, origin, i0, i1, sgn) => {
		const mat = identity3x3.concat([0, 1, 2].map(i => origin[i] || 0));
		const cos = Math.cos(angle);
		const sin = Math.sin(angle);
		mat[i0 * 3 + i0] = cos;
		mat[i0 * 3 + i1] = (sgn ? +1 : -1) * sin;
		mat[i1 * 3 + i0] = (sgn ? -1 : +1) * sin;
		mat[i1 * 3 + i1] = cos;
		return mat;
	};

	/**
	 * @description make a 3x4 matrix representing a rotation in 3D around the x-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 159
	 */
	const makeMatrix3RotateX = (angle, origin = [0, 0, 0]) => (
		singleAxisRotate(angle, origin, 1, 2, true));
	/**
	 * @description make a 3x4 matrix representing a rotation in 3D around the y-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 169
	 */
	const makeMatrix3RotateY = (angle, origin = [0, 0, 0]) => (
		singleAxisRotate(angle, origin, 0, 2, false));
	/**
	 * @description make a 3x4 matrix representing a rotation in 3D around the z-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 179
	 */
	const makeMatrix3RotateZ = (angle, origin = [0, 0, 0]) => (
		singleAxisRotate(angle, origin, 0, 1, true));
	/**
	 * @description make a 3x4 matrix representing a rotation in 3D
	 * around a given vector and around a given center of rotation.
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [vector=[0,0,1]] the axis of rotation
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 190
	 */
	const makeMatrix3Rotate = (angle, vector = [0, 0, 1], origin = [0, 0, 0]) => {
		const pos = [0, 1, 2].map(i => origin[i] || 0);
		const [x, y, z] = resize(3, normalize(vector));
		const c = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c;
		const trans = identity3x3.concat(-pos[0], -pos[1], -pos[2]);
		const trans_inv = identity3x3.concat(pos[0], pos[1], pos[2]);
		return multiplyMatrices3(trans_inv, multiplyMatrices3([
			t * x * x + c,     t * y * x + z * s, t * z * x - y * s,
			t * x * y - z * s, t * y * y + c,     t * z * y + x * s,
			t * x * z + y * s, t * y * z - x * s, t * z * z + c,
			0, 0, 0], trans));
	};
	// leave this in for legacy, testing. eventually this can be removed.
	// const makeMatrix3RotateOld = (angle, vector = [0, 0, 1], origin = [0, 0, 0]) => {
	// 	// normalize inputs
	// 	const vec = resize(3, normalize(vector));
	// 	const pos = [0, 1, 2].map(i => origin[i] || 0);
	// 	const [a, b, c] = vec;
	// 	const cos = Math.cos(angle);
	// 	const sin = Math.sin(angle);
	// 	const d = Math.sqrt((vec[1] * vec[1]) + (vec[2] * vec[2]));
	// 	const b_d = Math.abs(d) < 1e-6 ? 0 : b / d;
	// 	const c_d = Math.abs(d) < 1e-6 ? 1 : c / d;
	// 	const t     = identity3x3.concat(-pos[0], -pos[1], -pos[2]);
	// 	const t_inv = identity3x3.concat(pos[0], pos[1], pos[2]);
	// 	const rx     = [1, 0, 0, 0, c_d, b_d, 0, -b_d, c_d, 0, 0, 0];
	// 	const rx_inv = [1, 0, 0, 0, c_d, -b_d, 0, b_d, c_d, 0, 0, 0];
	// 	const ry     = [d, 0, a, 0, 1, 0, -a, 0, d, 0, 0, 0];
	// 	const ry_inv = [d, 0, -a, 0, 1, 0, a, 0, d, 0, 0, 0];
	// 	const rz     = [cos, sin, 0, -sin, cos, 0, 0, 0, 1, 0, 0, 0];
	// 	return multiplyMatrices3(t_inv,
	// 		multiplyMatrices3(rx_inv,
	// 			multiplyMatrices3(ry_inv,
	// 				multiplyMatrices3(rz,
	// 					multiplyMatrices3(ry,
	// 						multiplyMatrices3(rx, t))))));
	// };
	/**
	 * @description make a 3x4 matrix representing a non-uniform scale.
	 * @param {number[]} [scale=[1,1,1]] non-uniform scaling vector
	 * @param {number[]} [origin=[0,0,0]] the center of transformation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 236
	 */
	const makeMatrix3Scale = (scale = [1, 1, 1], origin = [0, 0, 0]) => [
		scale[0], 0, 0,
		0, scale[1], 0,
		0, 0, scale[2],
		scale[0] * -origin[0] + origin[0],
		scale[1] * -origin[1] + origin[1],
		scale[2] * -origin[2] + origin[2],
	];
	/**
	 * @description make a 3x4 matrix representing a uniform scale.
	 * @param {number} [scale=1] the uniform scale factor
	 * @param {number[]} [origin=[0,0,0]] the center of transformation
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 236
	 */
	const makeMatrix3UniformScale = (scale = 1, origin = [0, 0, 0]) => (
		makeMatrix3Scale([scale, scale, scale], origin)
	);
	/**
	 * @description make a 3x4 representing a reflection across a line in the XY plane
	 * This is a 2D operation, assumes everything is in the XY plane.
	 * @param {number[]} vector one 2D vector specifying the reflection axis
	 * @param {number[]} [origin=[0,0]] 2D origin specifying a point of reflection
	 * @returns {number[]} one 3x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 252
	 */
	const makeMatrix3ReflectZ = (vector, origin = [0, 0]) => {
		const m = makeMatrix2Reflect(vector, origin);
		return [m[0], m[1], 0, m[2], m[3], 0, 0, 0, 1, m[4], m[5], 0];
	};

	var matrix3 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		determinant3: determinant3,
		identity3x3: identity3x3,
		identity3x4: identity3x4,
		invertMatrix3: invertMatrix3,
		isIdentity3x4: isIdentity3x4,
		makeMatrix3ReflectZ: makeMatrix3ReflectZ,
		makeMatrix3Rotate: makeMatrix3Rotate,
		makeMatrix3RotateX: makeMatrix3RotateX,
		makeMatrix3RotateY: makeMatrix3RotateY,
		makeMatrix3RotateZ: makeMatrix3RotateZ,
		makeMatrix3Scale: makeMatrix3Scale,
		makeMatrix3Translate: makeMatrix3Translate,
		makeMatrix3UniformScale: makeMatrix3UniformScale,
		multiplyMatrices3: multiplyMatrices3,
		multiplyMatrix3Line3: multiplyMatrix3Line3,
		multiplyMatrix3Vector3: multiplyMatrix3Vector3
	});

	/* Math (c) Kraft, MIT License */
	/**
	 * Math (c) Kraft
	 */
	const isIterable = (obj) => obj != null
		&& typeof obj[Symbol.iterator] === "function";
	/**
	 * @description flatten only until the point of comma separated entities.
	 * This will preserve vectors (number[]) in an array of array of vectors.
	 * @param {any[][]} args any array, intended to contain arrays of arrays.
	 * @returns {array[]} a flattened copy, flattened up until the point before
	 * combining arrays of elements.
	 * @linkcode Math ./src/general/arrays.js 10
	 */
	const semiFlattenArrays = function () {
		switch (arguments.length) {
		case 0: return Array.from(arguments);
		// only if its an array (is iterable) and NOT a string
		case 1: return isIterable(arguments[0]) && typeof arguments[0] !== "string"
			? semiFlattenArrays(...arguments[0])
			: [arguments[0]];
		default:
			return Array.from(arguments).map(a => (isIterable(a)
				? [...semiFlattenArrays(a)]
				: a));
		}
	};
	/**
	 * @description Totally flatten, recursive
	 * @param {array[][]} args any array, intended to contain arrays of arrays.
	 * @returns {array[]} fully, recursively flattened array
	 * @linkcode Math ./src/general/arrays.js 30
	 */
	const flattenArrays = function () {
		switch (arguments.length) {
		case 0: return Array.from(arguments);
		// only if its an array (is iterable) and NOT a string
		case 1: return isIterable(arguments[0]) && typeof arguments[0] !== "string"
			? flattenArrays(...arguments[0])
			: [arguments[0]];
		default:
			return Array.from(arguments).map(a => (isIterable(a)
				? [...flattenArrays(a)]
				: a)).flat();
		}
	};

	var array = /*#__PURE__*/Object.freeze({
		__proto__: null,
		flattenArrays: flattenArrays,
		semiFlattenArrays: semiFlattenArrays
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Coerce the function arguments into a vector.
	 * This will object notation {x:, y:}, or array [number, number, ...]
	 * and work for n-dimensions.
	 * @param {any[]} ...args an argument list that contains at least one
	 * object with {x: y:} or a list of numbers to become the vector.
	 * @returns {number[]} vector in array form, or empty array for bad inputs
	*/
	const getVector = function () {
		let list = flattenArrays(arguments);
		// if the arguments's first element is an object with an "x" property
		const a = list[0];
		if (typeof a === "object" && a !== null && !Number.isNaN(a.x)) {
			list = ["x", "y", "z"].map(c => a[c]).filter(b => b !== undefined);
		}
		return list.filter(n => typeof n === "number");
	};
	/**
	 * @description Coerce the function arguments into an array of vectors.
	 * @param {any[][]} ...args an argument list that contains any number of
	 * objects with {x: y:} or a list of list of numbers to become vectors.
	 * @returns {number[][]} vectors in array form, or empty array.
	*/
	const getArrayOfVectors = function () {
		return semiFlattenArrays(arguments).map(el => getVector(el));
	};
	/**
	 * @description Coerce the function arguments into a segment (a pair of points)
	 * @param {any[]} ...args an argument list that contains a pair of
	 * objects with {x: y:} or a list of list of numbers to become endpoints.
	 * @returns {number[][]} segment in array form [[a1, a2], [b1, b2]]
	*/
	const getSegment = function () {
		const args = semiFlattenArrays(arguments);
		return args.length === 4
			? [[0, 1], [2, 3]].map(s => s.map(i => args[i]))
			: args.map(el => getVector(el));
	};
	// store two parameters in an object under the keys "vector" and "object"
	const vectorOriginForm = (vector, origin = []) => ({ vector, origin });
	// 	{ vector: vector || [], origin: origin || [] });
	/**
	 * @description Coerce the function arguments into a line.
	 * @param {any[]} ...args an argument list that contains an object with
	 * {vector: origin:} or a list of list of numbers.
	 * @returns {VecLine} a line in "vector" "origin" form.
	 */
	const getLine$1 = function () {
		const args = semiFlattenArrays(arguments);
		if (args.length === 0 || args[0] == null) { return vectorOriginForm([], []); }
		if (args[0].constructor === Object && args[0].vector !== undefined) {
			return vectorOriginForm(args[0].vector, args[0].origin || []);
		}
		return typeof args[0] === "number"
			? vectorOriginForm(getVector(args))
			: vectorOriginForm(...args.map(a => getVector(a)));
	};

	var get = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getArrayOfVectors: getArrayOfVectors,
		getLine: getLine$1,
		getSegment: getSegment,
		getVector: getVector
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * the radius parameter measures from the center to the midpoint of the edge
	 * vertex-axis aligned
	 * todo: also possible to parameterize the radius as the center to the points
	 * todo: can be edge-aligned
	 */
	const angleArray = count => Array
		.from(Array(Math.floor(count)))
		.map((_, i) => TWO_PI * (i / count));

	const anglesToVecs = (angles, radius) => angles
		.map(a => [radius * Math.cos(a), radius * Math.sin(a)]);
	// a = 2r tan(Ï€/n)
	/**
	 * @description Make a regular polygon from a circumradius,
	 * the first point is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [circumradius=1] the polygon's circumradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 31
	 */
	const makePolygonCircumradius = (sides = 3, circumradius = 1) => (
		anglesToVecs(angleArray(sides), circumradius)
	);
	/**
	 * @description Make a regular polygon from a circumradius,
	 * the middle of the first side is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [circumradius=1] the polygon's circumradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 42
	 */
	const makePolygonCircumradiusSide = (sides = 3, circumradius = 1) => {
		const halfwedge = Math.PI / sides;
		const angles = angleArray(sides).map(a => a + halfwedge);
		return anglesToVecs(angles, circumradius);
	};
	/**
	 * @description Make a regular polygon from a inradius,
	 * the first point is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [inradius=1] the polygon's inradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 55
	 */
	const makePolygonInradius = (sides = 3, inradius = 1) => (
		makePolygonCircumradius(sides, inradius / Math.cos(Math.PI / sides)));
	/**
	 * @description Make a regular polygon from a inradius,
	 * the middle of the first side is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [inradius=1] the polygon's inradius
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 65
	 */
	const makePolygonInradiusSide = (sides = 3, inradius = 1) => (
		makePolygonCircumradiusSide(sides, inradius / Math.cos(Math.PI / sides)));
	/**
	 * @description Make a regular polygon from a side length,
	 * the first point is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [length=1] the polygon's side length
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 75
	 */
	const makePolygonSideLength = (sides = 3, length = 1) => (
		makePolygonCircumradius(sides, (length / 2) / Math.sin(Math.PI / sides)));
	/**
	 * @description Make a regular polygon from a side length,
	 * the middle of the first side is +X aligned.
	 * @param {number} sides the number of sides in the polygon
	 * @param {number} [length=1] the polygon's side length
	 * @returns {number[][]} an array of points, each point as an arrays of numbers
	 * @linkcode Math ./src/geometry/polygons.js 85
	 */
	const makePolygonSideLengthSide = (sides = 3, length = 1) => (
		makePolygonCircumradiusSide(sides, (length / 2) / Math.sin(Math.PI / sides)));
	/**
	 * @description Remove any collinear vertices from a n-dimensional polygon.
	 * @param {number[][]} polygon a polygon as an array of ordered points in array form
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} a copy of the polygon with collinear points removed
	 * @linkcode Math ./src/geometry/polygons.js 94
	 */
	const makePolygonNonCollinear = (polygon, epsilon = EPSILON) => {
		// index map [i] to [i, i+1]
		const edges_vector = polygon
			.map((v, i, arr) => [v, arr[(i + 1) % arr.length]])
			.map(pair => subtract(pair[1], pair[0]));
		// the vertex to be removed. true=valid, false=collinear.
		// ask if an edge is parallel to its predecessor, this way,
		// the edge index will match to the collinear vertex.
		const vertex_collinear = edges_vector
			.map((vector, i, arr) => [vector, arr[(i + arr.length - 1) % arr.length]])
			.map(pair => !parallel(pair[1], pair[0], epsilon));
		return polygon
			.filter((vertex, v) => vertex_collinear[v]);
	};
	/**
	 * @description Calculates the circumcircle with a boundary that
	 * lies on three points provided by the user.
	 * @param {number[]} a one 2D point as an array of numbers
	 * @param {number[]} b one 2D point as an array of numbers
	 * @param {number[]} c one 2D point as an array of numbers
	 * @returns {Circle} a circle in "radius" (number) "origin" (number[]) form
	 * @linkcode Math ./src/geometry/polygons.js 117
	 */
	const circumcircle = (a, b, c) => {
		const A = b[0] - a[0];
		const B = b[1] - a[1];
		const C = c[0] - a[0];
		const D = c[1] - a[1];
		const E = A * (a[0] + b[0]) + B * (a[1] + b[1]);
		const F = C * (a[0] + c[0]) + D * (a[1] + c[1]);
		const G = 2 * (A * (c[1] - b[1]) - B * (c[0] - b[0]));
		if (Math.abs(G) < EPSILON) {
			const minx = Math.min(a[0], b[0], c[0]);
			const miny = Math.min(a[1], b[1], c[1]);
			const dx = (Math.max(a[0], b[0], c[0]) - minx) * 0.5;
			const dy = (Math.max(a[1], b[1], c[1]) - miny) * 0.5;
			return {
				origin: [minx + dx, miny + dy],
				radius: Math.sqrt(dx * dx + dy * dy),
			};
		}
		const origin = [(D * E - B * F) / G, (A * F - C * E) / G];
		const dx = origin[0] - a[0];
		const dy = origin[1] - a[1];
		return {
			origin,
			radius: Math.sqrt(dx * dx + dy * dy),
		};
	};
	/**
	 * @description Calculates the signed area of a polygon.
	 * This requires the polygon be non-self-intersecting.
	 * @param {number[][]} points an array of 2D points,
	 * which are arrays of numbers
	 * @returns {number} the area of the polygon
	 * @example
	 * var area = polygon.signedArea([ [1,2], [5,6], [7,0] ])
	 * @linkcode Math ./src/geometry/polygons.js 152
	 */
	const signedArea = points => 0.5 * points
		.map((el, i, arr) => [el, arr[(i + 1) % arr.length]])
		.map(pair => cross2(...pair))
		.reduce((a, b) => a + b, 0);
	/**
	 * @description Calculates the centroid or the center of mass of the polygon.
	 * @param {number[][]} points an array of 2D points, which are arrays of numbers
	 * @returns {number[]} one 2D point as an array of numbers
	 * @example
	 * var centroid = polygon.centroid([ [1,2], [8,9], [8,0] ])
	 * @linkcode Math ./src/geometry/polygons.js 164
	 */
	const centroid = (points) => {
		const sixthArea = 1 / (6 * signedArea(points));
		return points
			.map((el, i, arr) => [el, arr[(i + 1) % arr.length]])
			.map(pair => scale2(add2(...pair), cross2(...pair)))
			.reduce((a, b) => add2(a, b), [0, 0])
			.map(c => c * sixthArea);
	};
	/**
	 * @description Make an axis-aligned bounding box that encloses a set of points.
	 * the optional padding is used to make the bounding box inclusive / exclusive
	 * by adding padding on all sides, or inset in the case of negative number.
	 * (positive=inclusive boundary, negative=exclusive boundary)
	 * @param {number[][]} points an array of unsorted points, in any dimension
	 * @param {number} [padding=0] optionally add padding around the box
	 * @returns {Box?} an object where "min" and "max" are two points and
	 * "span" is the lengths. returns "undefined" if no points were provided.
	 * @linkcode Math ./src/geometry/polygons.js 183
	 */
	const boundingBox$1 = (points, padding = 0) => {
		if (!points || !points.length) { return undefined; }
		const min = Array(points[0].length).fill(Infinity);
		const max = Array(points[0].length).fill(-Infinity);
		points.forEach(point => point
			.forEach((c, i) => {
				if (c < min[i]) { min[i] = c - padding; }
				if (c > max[i]) { max[i] = c + padding; }
			}));
		const span = max.map((m, i) => m - min[i]);
		return { min, max, span };
	};

	var polygon$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		boundingBox: boundingBox$1,
		centroid: centroid,
		circumcircle: circumcircle,
		makePolygonCircumradius: makePolygonCircumradius,
		makePolygonCircumradiusSide: makePolygonCircumradiusSide,
		makePolygonInradius: makePolygonInradius,
		makePolygonInradiusSide: makePolygonInradiusSide,
		makePolygonNonCollinear: makePolygonNonCollinear,
		makePolygonSideLength: makePolygonSideLength,
		makePolygonSideLengthSide: makePolygonSideLengthSide,
		signedArea: signedArea
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * common functions that get reused, especially inside of map/reduce etc...
	 */
	/**
	 * @description Are two inputs equal within an epsilon of each other?
	 * @param {number} a any number input
	 * @param {number} b any number input
	 * @returns {boolean} true if the numbers are near each other
	 * @linkcode Math ./src/general/functions.js 13
	 */
	const epsilonEqual = (a, b, epsilon = EPSILON) => Math.abs(a - b) < epsilon;
	/**
	 * @description Compare two numbers within an epsilon of each other,
	 * so that "1": a < b, "-1": a > b, and "0": a ~= b (epsilon equal).
	 * @param {number} a any number
	 * @param {number} b any number
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number} -1, 0, +1
	 * @linkcode Math ./src/general/functions.js 23
	 */
	const epsilonCompare = (a, b, epsilon = EPSILON) => (
		epsilonEqual(a, b, epsilon) ? 0 : Math.sign(b - a)
	);
	/**
	 * @description are two vectors equal to each other within an epsilon.
	 * This method uses a axis-aligned bounding box to check equality
	 * for speed. If the two vectors are of differing lengths, assume
	 * the remaining values are zero, compare until the end of the
	 * longest vector.
	 * @param {number[]} a an array of numbers
	 * @param {number[]} b an array of numbers
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} true if the vectors are similar within an epsilon
	 * @linkcode Math ./src/general/functions.js 37
	 */
	const epsilonEqualVectors = (a, b, epsilon = EPSILON) => {
		for (let i = 0; i < Math.max(a.length, b.length); i += 1) {
			if (!epsilonEqual(a[i] || 0, b[i] || 0, epsilon)) { return false; }
		}
		return true;
	};
	/**
	 * @description the inclusive test used in intersection algorithms, returns
	 * true if the number is positive, including the epsilon between -epsilon and 0.
	 * @param {number} n the number to test against
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} -Infinity...{false}...-epsilon...{true}...+Infinity
	 * @linkcode Math ./src/general/functions.js 49
	 */
	const include = (n, epsilon = EPSILON) => n > -epsilon;
	/**
	 * @description the exclusive test used in intersection algorithms, returns
	 * true if the number is positive, excluding the epsilon between 0 and +epsilon.
	 * @param {number} n the number to test against
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} -Infinity...{false}...+epsilon...{true}...+Infinity
	 * @linkcode Math ./src/general/functions.js 56
	 */
	const exclude = (n, epsilon = EPSILON) => n > epsilon;
	/**
	 * @description the function parameter for an inclusive line
	 * @returns {boolean} true
	 * @linkcode Math ./src/general/functions.js 61
	 */
	const includeL = () => true;
	/**
	 * @description the function parameter for an exclusive line
	 * @returns {boolean} true
	 * @linkcode Math ./src/general/functions.js 66
	 */
	const excludeL = () => true;
	/**
	 * @description the function parameter for an inclusive ray
	 * @linkcode Math ./src/general/functions.js 71
	 */
	const includeR = include;
	/**
	 * @description the function parameter for an exclusive ray
	 * @linkcode Math ./src/general/functions.js 76
	 */
	const excludeR = exclude;
	/**
	 * @description the function parameter for an inclusive segment
	 * @param {number} n the number to test against
	 * @param {number} [e=1e-6] an optional epsilon
	 * @linkcode Math ./src/general/functions.js 81
	 */
	const includeS = (n, e = EPSILON) => n > -e && n < 1 + e;
	/**
	 * @description the function parameter for an exclusive segment
	 * @param {number} n the number to test against
	 * @param {number} [e=1e-6] an optional epsilon
	 * @linkcode Math ./src/general/functions.js 86
	 */
	const excludeS = (n, e = EPSILON) => n > e && n < 1 - e;
	/**
	 * @description These clamp functions process lines/rays/segments intersections.
	 * The line method allows all values.
	 * @param {number} dist the length along the vector
	 * @returns {number} the clamped input value (line does not clamp)
	 * @linkcode Math ./src/general/functions.js 94
	 */
	const clampLine = dist => dist;
	/**
	 * @description These clamp functions process lines/rays/segments intersections.
	 * The ray method clamps values below -epsilon to be 0.
	 * @param {number} dist the length along the vector
	 * @returns {number} the clamped input value
	 * @linkcode Math ./src/general/functions.js 102
	 */
	const clampRay = dist => (dist < -EPSILON ? 0 : dist);
	/**
	 * @description These clamp functions process lines/rays/segments intersections.
	 * The segment method clamps values below -epsilon to be 0 and above 1+epsilon to 1.
	 * @param {number} dist the length along the vector
	 * @returns {number} the clamped input value
	 * @linkcode Math ./src/general/functions.js 110
	 */
	const clampSegment = (dist) => {
		if (dist < -EPSILON) { return 0; }
		if (dist > 1 + EPSILON) { return 1; }
		return dist;
	};

	var _function = /*#__PURE__*/Object.freeze({
		__proto__: null,
		clampLine: clampLine,
		clampRay: clampRay,
		clampSegment: clampSegment,
		epsilonCompare: epsilonCompare,
		epsilonEqual: epsilonEqual,
		epsilonEqualVectors: epsilonEqualVectors,
		exclude: exclude,
		excludeL: excludeL,
		excludeR: excludeR,
		excludeS: excludeS,
		include: include,
		includeL: includeL,
		includeR: includeR,
		includeS: includeS
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * lists of keys and values involved in the FOLD file format spec
	 * https://github.com/edemaine/FOLD/
	 */

	/**
	 * @description All FOLD keys described in the spec,
	 * sorted into descriptive categories.
	 */
	const foldKeys = {
		file: [
			"file_spec",
			"file_creator",
			"file_author",
			"file_title",
			"file_description",
			"file_classes",
			"file_frames",
		],
		frame: [
			"frame_author",
			"frame_title",
			"frame_description",
			"frame_attributes",
			"frame_classes",
			"frame_unit",
			"frame_parent", // inside file_frames only
			"frame_inherit", // inside file_frames only
		],
		graph: [
			"vertices_coords",
			"vertices_vertices",
			"vertices_faces",
			"edges_vertices",
			"edges_faces",
			"edges_assignment",
			"edges_foldAngle",
			"edges_length",
			"faces_vertices",
			"faces_edges",
			// as of now, these are not described in the spec, but their behavior
			// can be inferred, except faces_faces which could be edge-adjacent or
			// face-adjacent. this library uses as EDGE-ADJACENT.
			"vertices_edges",
			"edges_edges",
			"faces_faces",
		],
		orders: [
			"edgeOrders",
			"faceOrders",
		],
	};
	/**
	 * values from the official spec, grouped by the key under which they appear.
	 */
	/**
	 * @description All "file_classes" values according to the FOLD spec
	 */
	const foldFileClasses = [
		"singleModel",
		"multiModel",
		"animation",
		"diagrams",
	];
	/**
	 * @description All "frame_classes" values according to the FOLD spec
	 */
	const foldFrameClasses = [
		"creasePattern",
		"foldedForm",
		"graph",
		"linkage",
	];
	/**
	 * @description All "frame_attributes" values according to the FOLD spec
	 */
	const foldFrameAttributes = [
		"2D",
		"3D",
		"abstract",
		"manifold",
		"nonManifold",
		"orientable",
		"nonOrientable",
		"selfTouching",
		"nonSelfTouching",
		"selfIntersecting",
		"nonSelfIntersecting",
	];

	var foldKeyMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		foldFileClasses: foldFileClasses,
		foldFrameAttributes: foldFrameAttributes,
		foldFrameClasses: foldFrameClasses,
		foldKeys: foldKeys
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * this contains two types of methods.
	 * 1. references to named string keys that are a part of the FOLD spec
	 *    (anytime FOLD is updated these will update too).
	 * 2. methods that take a FOLD object as a parameter, and perform some
	 *    searching and gathering of information contained inside.
	 */
	/**
	 * @description English conversion of the names of graph components
	 * from plural to singular.
	 * @linkcode Origami ./src/fold/spec.js 17
	 */
	const singularize = {
		vertices: "vertex",
		edges: "edge",
		faces: "face",
	};
	/**
	 * @description English conversion of the names of graph components
	 * from singular to plural.
	 * @linkcode Origami ./src/fold/spec.js 27
	 */
	const pluralize = {
		vertex: "vertices",
		edge: "edges",
		face: "faces",
	};
	/**
	 * array of single characers, the values of an edge assignment
	 */
	const edgesAssignmentValues = Array.from("BbMmVvFfJjCcUu");
	/**
	 * @description get the English word for every FOLD spec
	 * assignment character (like "M", or "b")
	 * @linkcode Origami ./src/fold/spec.js 41
	 */
	const edgesAssignmentNames = {
		b: "boundary",
		m: "mountain",
		v: "valley",
		f: "flat",
		j: "join",
		c: "cut",
		u: "unassigned",
	};
	Object.keys(edgesAssignmentNames).forEach(key => {
		edgesAssignmentNames[key.toUpperCase()] = edgesAssignmentNames[key];
	});
	/**
	 * @description get the foldAngle in degrees for every FOLD assignment spec
	 * character (like "M", or "b"). **this assumes the creases are flat folded.**
	 * @linkcode Origami ./src/fold/spec.js 57
	 */
	const assignmentFlatFoldAngle = {
		B: 0,
		b: 0,
		M: -180,
		m: -180,
		V: 180,
		v: 180,
		F: 0,
		f: 0,
		J: 0,
		j: 0,
		C: 0,
		c: 0,
		U: 0,
		u: 0,
	};
	/**
	 * @constant {object}
	 * @default
	 * @description for every edges_assignment type, can this edge be
	 * a folded edge?
	 */
	const assignmentCanBeFolded = {
		B: false,
		b: false,
		M: true,
		m: true,
		V: true,
		v: true,
		F: false,
		f: false,
		J: false,
		j: false,
		C: false,
		c: false,
		U: true,
		u: true,
	};
	/**
	 * @description Convert an assignment character to a foldAngle in degrees.
	 * This assumes that all assignments are flat folds.
	 * @param {string} assignment one edge assignment letter: M V B F U
	 * @returns {number} fold angle in degrees. M/V are assumed to be flat-folded.
	 * @linkcode Origami ./src/fold/spec.js 78
	 */
	const edgeAssignmentToFoldAngle = assignment => (
		assignmentFlatFoldAngle[assignment] || 0
	);
	/**
	 * @description Convert a foldAngle to an edge assignment character.
	 * No boundary detection is performed so an edge which is otherwise
	 * a boundary will come back as "U".
	 * @todo should "U" be "F" instead?
	 * @param {number} angle fold angle in degrees
	 * @returns {string} an edge assignment letter: M V or U.
	 * @linkcode Origami ./src/fold/spec.js 90
	 */
	const edgeFoldAngleToAssignment = (angle) => {
		if (angle > EPSILON) { return "V"; }
		if (angle < -EPSILON) { return "M"; }
		// return "F";
		return "U";
	};
	/**
	 * @description Test if a fold angle is a flat fold, which includes -180, 0, 180,
	 * and the +/- epsilon around each number.
	 * @param {number} angle fold angle in degrees
	 * @returns {boolean} true if the fold angle is flat
	 * @linkcode Origami ./src/fold/spec.js 103
	 */
	const edgeFoldAngleIsFlat = angle => epsilonEqual(0, angle)
	 || epsilonEqual(-180, angle)
	 || epsilonEqual(180, angle);
	/**
	 * @description Provide a FOLD graph and determine if all edges_foldAngle
	 * angles are flat, which includes -180, 0, 180, and the +/- epsilon
	 * around each number. If a graph contains no "edges_foldAngle",
	 * the angles are considered flat, and the method returns "true".
	 * @param {FOLD} graph a FOLD graph
	 * @returns {boolean} is the graph flat-foldable according to foldAngles.
	 * @linkcode Origami ./src/fold/spec.js 115
	 */
	const edgesFoldAngleAreAllFlat = ({ edges_foldAngle }) => {
		if (!edges_foldAngle) { return true; }
		for (let i = 0; i < edges_foldAngle.length; i += 1) {
			if (!edgeFoldAngleIsFlat(edges_foldAngle[i])) { return false; }
		}
		return true;
	};
	// subroutine for filterKeysWithPrefix and filterKeysWithSuffix
	const filterKeys = (obj, matchFunction) => Object
		.keys(obj)
		.filter(key => matchFunction(key));
	/**
	 * @description Get all keys in an object which begin with a string and are
	 * immediately followed by "_". For example, provide "vertices" and this will
	 * match "vertices_coords", "vertices_faces", but not "faces_vertices"
	 * @param {object} obj an object
	 * @param {string} prefix a prefix to match against the keys
	 * @returns {string[]} array of matching keys
	 * @linkcode Origami ./src/fold/spec.js 135
	 */
	const filterKeysWithPrefix = (obj, prefix) => filterKeys(
		obj,
		s => s.substring(0, prefix.length + 1) === `${prefix}_`,
	);
	/**
	 * @description Get all keys in an object which end with a string and are
	 * immediately preceded by "_". For example, provide "vertices" and this will
	 * match "edges_vertices", "faces_vertices", but not "vertices_edges"
	 * @param {object} obj an object
	 * @param {string} suffix a suffix to match against the keys
	 * @returns {string[]} array of matching keys
	 * @linkcode Origami ./src/fold/spec.js 148
	 */
	const filterKeysWithSuffix = (obj, suffix) => filterKeys(
		obj,
		s => s.substring(s.length - suffix.length - 1, s.length) === `_${suffix}`,
	);
	/**
	 * @description This takes in a geometry_key (vectors, edges, faces), and flattens
	 * across all related arrays, creating one object with the keys for every index.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} geometry_key a geometry item like "vertices"
	 * @returns {object[]} an array of objects with FOLD keys but the
	 * values are from this single element
	 * @linkcode Origami ./src/fold/spec.js 161
	 */
	const transposeGraphArrays = (graph, geometry_key) => {
		const matching_keys = filterKeysWithPrefix(graph, geometry_key);
		if (matching_keys.length === 0) { return []; }
		const len = Math.max(...matching_keys.map(arr => graph[arr].length));
		const geometry = Array.from(Array(len))
			.map(() => ({}));
		matching_keys
			.forEach(key => geometry
				.forEach((o, i) => { geometry[i][key] = graph[key][i]; }));
		return geometry;
	};
	/**
	 * @description This takes in a geometry_key (vectors, edges, faces), and flattens
	 * across all related arrays, creating one object with the keys.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} geometry_key a geometry item like "vertices"
	 * @param {number} index the index of an element
	 * @returns {object} an object with FOLD keys but the values are from this single element
	 * @linkcode Origami ./src/fold/spec.js 181
	 */
	const transposeGraphArrayAtIndex = (
		graph,
		geometry_key,
		index,
	) => {
		const matching_keys = filterKeysWithPrefix(graph, geometry_key);
		if (matching_keys.length === 0) { return undefined; }
		const geometry = {};
		// matching_keys
		//   .map(k => ({ long: k, short: k.substring(geometry_key.length + 1) }))
		//   .forEach((key) => { geometry[key.short] = graph[key.long][index]; });
		matching_keys.forEach((key) => { geometry[key] = graph[key][index]; });
		return geometry;
	};
	/**
	 * top-level keys from a FOLD object in one flat array
	 */
	const flatFoldKeys = Object.freeze([]
		.concat(foldKeys.file)
		.concat(foldKeys.frame)
		.concat(foldKeys.graph)
		.concat(foldKeys.orders));
	/**
	 * @description Using heuristics, try to determine if an object is a FOLD object.
	 * @param {FOLD} object a Javascript object, find out if it is a FOLD object
	 * @returns {number} value between 0 and 1, zero meaning no chance, one meaning 100% chance
	 * @linkcode Origami ./src/fold/spec.js 209
	 */
	const isFoldObject = (object = {}) => (
		Object.keys(object).length === 0
			? 0
			: flatFoldKeys
				.filter(key => object[key]).length / Object.keys(object).length);
	/**
	 * @description Check a FOLD object's frame_classes for the presence of "foldedForm".
	 * @param {FOLD} graph a FOLD object
	 * @returns {boolean} true if the graph is folded.
	 * @linkcode Origami ./src/graph/query.js 8
	 */
	const isFoldedForm = ({ frame_classes, file_classes }) => (
		(frame_classes && frame_classes.includes("foldedForm"))
			|| (file_classes && file_classes.includes("foldedForm"))
	);
	/**
	 * @description For every edge, give us a boolean:
	 * - "true" if the edge is folded, valley or mountain, or unassigned.
	 * - "false" if the edge is not folded, flat or boundary.
	 * "unassigned" is considered folded so that an unsolved crease pattern
	 * can be fed into here and we still compute the folded state.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {boolean[]} for every edge, is it folded? or has the potential to be folded?
	 * "unassigned"=yes
	 * @linkcode Origami ./src/graph/facesMatrix.js 124
	 */
	const makeEdgesIsFolded = ({ edges_vertices, edges_foldAngle, edges_assignment }) => {
		if (edges_assignment === undefined) {
			return edges_foldAngle === undefined
				? edges_vertices.map(() => true)
				: edges_foldAngle.map(angle => angle < -EPSILON || angle > EPSILON);
		}
		return edges_assignment.map(a => assignmentCanBeFolded[a]);
	};
	/**
	 * @description Given a fold graph, make all mountains into valleys
	 * and visa versa. This includes reversing the fold_angles.
	 */
	const invertAssignments = (graph) => {
		const flipAssignment = { M: "V", m: "v", V: "M", v: "m" };
		if (graph.edges_assignment) {
			graph.edges_assignment = graph.edges_assignment
				.map(a => (flipAssignment[a] ? flipAssignment[a] : a));
		}
		if (graph.edges_foldAngle) {
			graph.edges_foldAngle = graph.edges_foldAngle.map(n => -n);
		}
		return graph;
	};

	// export const getMetadata = (FOLD = {}) => {
	// 	// build a list of all metadata keys (do not include file_frames)
	// 	const metadataKeys = {}
	// 	[...foldKeys.file, ...foldKeys.frame]
	// 		.forEach(k => { metadataKeys[k] = true; });
	// 	delete metadataKeys.file_frames;
	// 	const copy = {};
	// 	Object.keys(FOLD)
	// 		.filter()
	// };

	var foldSpecMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		assignmentCanBeFolded: assignmentCanBeFolded,
		assignmentFlatFoldAngle: assignmentFlatFoldAngle,
		edgeAssignmentToFoldAngle: edgeAssignmentToFoldAngle,
		edgeFoldAngleIsFlat: edgeFoldAngleIsFlat,
		edgeFoldAngleToAssignment: edgeFoldAngleToAssignment,
		edgesAssignmentNames: edgesAssignmentNames,
		edgesAssignmentValues: edgesAssignmentValues,
		edgesFoldAngleAreAllFlat: edgesFoldAngleAreAllFlat,
		filterKeysWithPrefix: filterKeysWithPrefix,
		filterKeysWithSuffix: filterKeysWithSuffix,
		invertAssignments: invertAssignments,
		isFoldObject: isFoldObject,
		isFoldedForm: isFoldedForm,
		makeEdgesIsFolded: makeEdgesIsFolded,
		pluralize: pluralize,
		singularize: singularize,
		transposeGraphArrayAtIndex: transposeGraphArrayAtIndex,
		transposeGraphArrays: transposeGraphArrays
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @name transform
	 * @memberof graph
	 * @description apply an affine transform to a graph; this includes
	 * modifying the position of any key ending with "_coords" and multiplying
	 * any matrix in keys that end with "_matrix".
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @param {number[]} matrix a 3x4 matrix as a 12 number array
	 * @returns {FOLD} the same input graph, modified
	 * @linkcode Origami ./src/graph/affine.js 23
	 */
	const transform = function (graph, matrix) {
		// apply to anything with a coordinate value
		filterKeysWithSuffix(graph, "coords").forEach((key) => {
			graph[key] = graph[key]
				.map(v => resize(3, v))
				.map(v => multiplyMatrix3Vector3(matrix, v));
		});
		// update all matrix types
		// todo, are these being multiplied in the right order?
		filterKeysWithSuffix(graph, "matrix").forEach((key) => {
			graph[key] = graph[key]
				.map(m => multiplyMatrices3(m, matrix));
		});
		return graph;
	};
	/**
	 * @name scale
	 * @memberof graph
	 * @description apply a uniform affine scale to a graph.
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @param {number} scale the scale amount
	 * @param {number[]} optional. an array or series of numbers, the center of scale.
	 * @returns {FOLD} the same input graph, modified.
	 * @linkcode Origami ./src/graph/affine.js 48
	 */
	const scale = (graph, ...args) => {
		const sc = args.length === 1
			? [args[0], args[0], args[0]]
			: [1, 1, 1].map((n, i) => (args[i] === undefined ? n : args[i]));
		const matrix = makeMatrix3Scale(sc);
		return transform(graph, matrix);
	};
	/**
	 * @name translate
	 * @memberof graph
	 * @description apply a translation to a graph.
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @param {number[]} optional. an array or series of numbers, the translation vector
	 * @returns {FOLD} the same input graph, modified
	 * @linkcode Origami ./src/graph/affine.js 64
	 */
	const translate = (graph, ...args) => {
		const vector = getVector(...args);
		const vector3 = resize(3, vector);
		const matrix = makeMatrix3Translate(...vector3);
		return transform(graph, matrix);
	};
	/**
	 * @name rotateZ
	 * @memberof graph
	 * @description apply a rotation to a graph around the +Z axis.
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @param {number} the rotation amount in radians
	 * @param {number[]} optional. an array or series of numbers, the center of rotation
	 * @returns {FOLD} the same input graph, modified
	 * @linkcode Origami ./src/graph/affine.js 80
	 */
	const rotate = (graph, angle, vector, origin) => transform(
		graph,
		makeMatrix3Rotate(angle, vector, origin),
	);
	/**
	 * @name rotateZ
	 * @memberof graph
	 * @description apply a rotation to a graph around the +Z axis.
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @param {number} the rotation amount in radians
	 * @param {number[]} optional. an array or series of numbers, the center of rotation
	 * @returns {FOLD} the same input graph, modified
	 * @linkcode Origami ./src/graph/affine.js 80
	 */
	const rotateZ = (graph, angle, ...args) => {
		const vector = getVector(...args);
		const vector3 = resize(3, vector);
		const matrix = makeMatrix3RotateZ(angle, ...vector3);
		return transform(graph, matrix);
	};
	/**
	 * @description alter the vertices by moving the corner of the graph
	 * to the origin and shrink or expand the vertices until they
	 * aspect fit inside the unit square.
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @returns {FOLD} the same input graph, modified
	 */
	const unitize = function (graph) {
		if (!graph.vertices_coords) { return graph; }
		const box = boundingBox$1(graph.vertices_coords);
		const longest = Math.max(...box.span);
		const sc = longest === 0 ? 1 : (1 / longest);
		const origin = box.min;
		graph.vertices_coords = graph.vertices_coords
			.map(coord => subtract(coord, origin))
			.map(coord => coord.map(n => n * sc));
		return graph;
	};

	// makeMatrix3Rotate
	// makeMatrix3RotateX
	// makeMatrix3RotateY
	// makeMatrix3ReflectZ

	var transform$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		rotate: rotate,
		rotateZ: rotateZ,
		scale: scale,
		transform: transform,
		translate: translate,
		unitize: unitize
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Find all clusters of vertices which lie within an epsilon of each other.
	 * Each cluster is an array of vertex indices. If no clusters exist, the method returns
	 * N-number of arrays, each with a single vertex entry. This is an implementation of a
	 * density-based spatial clustering of applications with noise (DBSCAN).
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} array of arrays of vertex indices.
	 * @example
	 * no clusters: [ [0], [1], [2], [3], [4], ... ]
	 * clusters: [ [0, 5], [1], [3], [2, 4]]
	 * @linkcode Origami ./src/graph/verticesClusters.js 16
	 */
	const getVerticesClusters = ({ vertices_coords }, epsilon = EPSILON) => {
		if (!vertices_coords) { return []; }
		// the return value, the clusters
		const clusters = [];
		// add to this as we go. once length === vertices_coords.length, we are done.
		const finished = [];
		// as we add points to clusters, they will be removed from here.
		// sort vertices (any dimension) along the X-axis. store their indices
		const vertices = vertices_coords
			.map((point, i) => ({ i, d: point[0] }))
			.sort((a, b) => a.d - b.d)
			.map(a => a.i);
		let rangeStart = 0;
		let yRange = [0, 0];
		let xRange = [0, 0];
		/**
		 * @description Test if a vertex is inside the current cluster's bounding box
		 * @param {number} index an index in vertices_coords
		 */
		const isInsideCluster = (index) => (
			vertices_coords[index][0] > xRange[0]
			&& vertices_coords[index][0] < xRange[1]
			&& vertices_coords[index][1] > yRange[0]
			&& vertices_coords[index][1] < yRange[1]
		);
		/**
		 * @description Each time we add a point to the current cluster,
		 * form a bounding box NOT by all points in the cluster, but all
		 * points that are within epsilon range along the X-axis of the most
		 * recently added point, as points are sorted left to right.
		 * "rangeStart" is the index of the cluster which is still within epsilon
		 * range of the most recently added point, every update to cluster will
		 * refresh the bounding box as rect range of indices (rangeStart...length).
		 */
		const updateRange = (cluster) => {
			const newVertex = cluster[cluster.length - 1];
			// update rangeStart
			// while (!isInsideCluster(cluster[rangeStart]) && rangeStart < cluster.length - 1) {
			// 	rangeStart += 1;
			// }
			while (vertices_coords[newVertex] - vertices_coords[cluster[rangeStart]] > epsilon) {
				rangeStart += 1;
			}
			// update bounding box
			const points = cluster.slice(rangeStart, cluster.length)
				.map(v => vertices_coords[v]);
			const ys = points.map(p => p[1]);
			yRange = [Math.min(...ys) - epsilon, Math.max(...ys) + epsilon];
			xRange = [points[0][0] - epsilon, points[points.length - 1][0] + epsilon];
		};
		// loop until all points have been added to "finished"
		while (finished.length !== vertices_coords.length) {
			// start a new cluster, add the first vertex furthest to the left
			const cluster = [];
			const startVertex = vertices.shift();
			cluster.push(startVertex);
			finished.push(startVertex);
			// rangeStart is an index in the array "cluster"
			rangeStart = 0;
			// update new bounding box, walk x-start pointer forward
			updateRange(cluster);
			// walk is an index in the array "vertices"
			let walk = 0;
			// this boolean check tests whether or not the vertex is still inside
			// the bounding box ONLY according to the X axis. it's possible a
			// vertex is too far away in the Y (and rejected from the cluster), but
			// the next few vertices to its right are still within the cluster.
			// however, if we move too far away in the X direction from the cluster,
			// we know this cluster is finished and we can start a new one.
			while (walk < vertices.length && vertices_coords[vertices[walk]][0] < xRange[1]) {
				// if the point is inside the bounding box of the cluster, add it.
				if (isInsideCluster(vertices[walk])) {
					const newVertex = vertices.splice(walk, 1).shift();
					cluster.push(newVertex);
					finished.push(newVertex);
					// update new bounding box, walk x-start pointer forward
					updateRange(cluster);
					// don't increment walk. the vertices array got smaller instead
				} else {
					// skip over this vertex. even though our vertices are sorted
					// left to right, it's possible that this one is too far away in the
					// Y axis, but the next few points will still be inside the cluster
					walk += 1;
				}
			}
			// cluster is done, no more possible points can be added.
			// start a new cluster next round, unless all vertices are finished.
			clusters.push(cluster);
		}
		return clusters;
		// .map(arr => arr.sort((a, b) => a - b))
		// .sort((a, b) => a[0] - b[0]);
	};

	var verticesClusters = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getVerticesClusters: getVerticesClusters
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @param {any[]} arrays any number of arrays
	 * @returns {number} the length of the longest array
	 */
	const max_arrays_length = (...arrays) => Math.max(0, ...(arrays
		.filter(el => el !== undefined)
		.map(el => el.length)));
	/**
	 * @description Get the number of vertices, edges, or faces in the graph by
	 * simply checking the length of arrays starting with the key; in the case
	 * of differing array lengths (which shouldn't happen) return the largest number.
	 *
	 * This works even with custom component names in place of "vertices", "edges"...
	 *
	 * This will fail in the case of abstract graphs, for example where no vertices
	 * are defined in a vertex_ array, but still exist as mentions in faces_vertices.
	 * In that case, use the implied count method. "count_implied.js"
	 * @param {FOLD} graph a FOLD graph
	 * @param {string} key the prefix for a key, eg: "vertices"
	 * @returns {number} the number of the requested element type in the graph
	 * @linkcode Origami ./src/graph/count.js 25
	 */
	const count = (graph, key) => (
		max_arrays_length(...filterKeysWithPrefix(graph, key).map(k => graph[k])));

	// standard graph components names
	/**
	 * @description Get the number of vertices in a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number} the number of vertices in the graph
	 */
	count.vertices = ({ vertices_coords, vertices_faces, vertices_vertices }) => (
		max_arrays_length(vertices_coords, vertices_faces, vertices_vertices));
	/**
	 * @description Get the number of edges in a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number} the number of edges in the graph
	 */
	count.edges = ({ edges_vertices, edges_edges, edges_faces }) => (
		max_arrays_length(edges_vertices, edges_edges, edges_faces));
	/**
	 * @description Get the number of faces in a graph.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number} the number of faces in the graph
	 */
	count.faces = ({ faces_vertices, faces_edges, faces_faces }) => (
		max_arrays_length(faces_vertices, faces_edges, faces_faces));

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given a list of any type, remove all duplicates.
	 * @param {number[]} array an array of integers
	 * @returns {number[]} set of unique integers
	 * @example [1,2,3,2,1] will result in [1,2,3]
	 * @linkcode Origami ./src/general/arrays.js 10
	 */
	const uniqueElements = (array) => Array.from(new Set(array));
	/**
	 * @description Given an array of any type, return the same array but filter
	 * out any items which only appear once. The comparison uses conversion-to-string,
	 * then matching to compare, so this works for primitives
	 * (bool, number, string), not objects or arrays.
	 * @param {any[]} array an array of any type.
	 * @returns {any[]} the same input array but filtered to
	 * remove elements which appear only once.
	 * @example [1,2,3,2,1] will result in [1,2,2,1]
	 * @linkcode Origami ./src/general/arrays.js 22
	 */
	const nonUniqueElements = (array) => {
		const count = {};
		array.forEach(n => {
			if (count[n] === undefined) { count[n] = 0; }
			count[n] += 1;
		});
		return array.filter(n => count[n] > 1);
	};
	/**
	 * @description Given a list of integers (can contain duplicates),
	 * this will return a sorted set of unique integers (removing duplicates).
	 * @param {number[]} array an array of integers
	 * @returns {number[]} set of sorted, unique integers
	 * @example [3,2,1,2,3] will result in [1,2,3]
	 * @linkcode Origami ./src/general/arrays.js 38
	 */
	const uniqueSortedNumbers = (array) => uniqueElements(array)
		.sort((a, b) => a - b);
	/**
	 * @description A circular array (data wraps around) requires 2 indices
	 * if you intend to split it into two arrays. The pair of indices can be
	 * provided in any order, they will be sorted, smaller index first.
	 * @param {any[]} array an array that is meant to be thought of as circular
	 * @param {number[]} indices two numbers, indices that divide the array into 2 parts
	 * @returns {any[][]} the same array split into two arrays
	 * @linkcode Origami ./src/general/arrays.js 49
	 */
	const splitCircularArray = (array, indices) => {
		indices.sort((a, b) => a - b);
		return [
			array.slice(indices[1]).concat(array.slice(0, indices[0] + 1)),
			array.slice(indices[0], indices[1] + 1),
		];
	};
	/**
	 * @description This will iterate over the array of arrays and returning
	 * the first array in the list with the longest length.
	 * @param {any[][]} arrays an array of arrays of any type
	 * @return {any[]} one of the arrays from the set
	 * @linkcode Origami ./src/general/arrays.js 63
	 */
	// this was used by some faces_layer method not included anymore
	// export const getLongestArray = (arrays) => {
	// 	if (arrays.length === 1) { return arrays[0]; }
	// 	const lengths = arrays.map(arr => arr.length);
	// 	let max = 0;
	// 	for (let i = 0; i < arrays.length; i += 1) {
	// 		if (lengths[i] > lengths[max]) {
	// 			max = i;
	// 		}
	// 	}
	// 	return arrays[max];
	// };
	/**
	 * @description Convert a sparse or dense matrix containing true/false/undefined
	 * into arrays containing the indices `[i,j]` of all true values.
	 * @param {Array<Array<boolean|undefined>>} matrix a 2D matrix containing boolean or undefined
	 * @returns {number[][]} array of arrays of numbers
	 * @linkcode Origami ./src/general/arrays.js 82
	 */
	const booleanMatrixToIndexedArray = matrix => matrix
		.map(row => row
			.map((value, i) => (value === true ? i : undefined))
			.filter(a => a !== undefined));
	/**
	 * @description consult the upper right half triangle of the matrix,
	 * find all truthy values, gather the row/column index pairs,
	 * return them as pairs of indices in a single array.
	 * Triangle number, only visit half the indices. make unique pairs
	 * @param {any[][]} matrix a matrix containing any type
	 * @returns {number[][]} array of pairs of numbers, the pairs of indices
	 * which are truthy in the matrix.
	 * @linkcode Origami ./src/general/arrays.js 96
	 */
	// todo: i wrote this to replace the bit below. this works with
	// sparse arrays too. needs testing before it gets replaced.
	// export const booleanMatrixToUniqueIndexPairs = matrix => {
	// 	const pairs = [];
	// 	matrix.forEach((row, i) => row.forEach((value, j) => {
	// 		if (i >= j) { return; }
	// 		if (value) { pairs.push([i, j]); }
	// 	}));
	// 	return pairs;
	// };
	const booleanMatrixToUniqueIndexPairs = matrix => {
		const pairs = [];
		for (let i = 0; i < matrix.length - 1; i += 1) {
			for (let j = i + 1; j < matrix.length; j += 1) {
				if (matrix[i][j]) {
					pairs.push([i, j]);
				}
			}
		}
		return pairs;
	};
	/**
	 * @description Given a self-relational array of arrays, for example,
	 * vertices_vertices, edges_edges, faces_faces, where the values in the
	 * inner arrays relate to the indices of the outer array, create a list of
	 * all pairwise combinations of related indices. This allows circular
	 * references (i === j) ensuring they only appear once, generally ensuring
	 * that no duplicate pairs appear by maintaining for [i, j] that i <= j.
	 * @param {number[][]} array_array an array of arrays of integers
	 * @returns {number[][]} array of two-dimensional array pairs of indices.
	 * @linkcode Origami ./src/general/arrays.js 128
	 */
	const selfRelationalUniqueIndexPairs = (array_array) => {
		const circular = [];
		const pairs = [];
		array_array.forEach((arr, i) => arr.forEach(j => {
			if (i < j) { pairs.push([i, j]); }
			if (i === j && !circular[i]) {
				circular[i] = true;
				pairs.push([i, j]);
			}
		}));
		return pairs;
	};
	/**
	 * @description Given an array of floats, make a sorted copy of the array,
	 * then walk through the array and group similar values into clusters.
	 * Cluster epsilon is relative to the nearest neighbor, not the start
	 * of the group or some other metric, so for example, the values
	 * [1, 2, 3, 4, 5] will all be in one cluster if the epsilon is 1.5.
	 * @param {number[]} floats an array of numbers
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} array of array of indices to the input array.
	 */
	const clusterScalars = (floats, epsilon = EPSILON) => {
		const indices = floats
			.map((v, i) => ({ v, i }))
			.sort((a, b) => a.v - b.v)
			.map(el => el.i);
		const groups = [[indices[0]]];
		for (let i = 1; i < indices.length; i += 1) {
			const index = indices[i];
			const g = groups.length - 1;
			const prev = groups[g][groups[g].length - 1];
			if (Math.abs(floats[prev] - floats[index]) < epsilon) {
				groups[g].push(index);
			} else {
				groups.push([index]);
			}
		}
		return groups;
	};
	/**
	 * @description Given an array of vectors, group the vectors into clusters
	 * that all contain vectors which are parallel to one another.
	 * This works for any N-dimensional vectors (including 3D or 2D).
	 * Note, this is an n^2 algorithm. Currently it's used by the method
	 * getEdgesLine to find all unique lines in a graph, which initially clusters
	 * lines by distance-to-origin, then INSIDE each cluster this method is called.
	 * Similar optimization should be performed when using this, if possible.
	 */
	const clusterParallelVectors = (vectors, epsilon = EPSILON) => {
		const groups = [[0]];
		for (let i = 1; i < vectors.length; i += 1) {
			let found = false;
			for (let g = 0; g < groups.length; g += 1) {
				const groupFirstIndex = groups[g][0];
				if (parallel(vectors[i], vectors[groupFirstIndex], epsilon)) {
					groups[g].push(i);
					found = true;
					break;
				}
			}
			// make a new group, with this vector inside
			if (!found) {
				groups.push([i]);
			}
		}
		return groups;
	};
	/**
	 * @description convert a list of items {any} into a list of pairs
	 * where each item is uniqely matched with another item (non-ordered)
	 * the number of pairs is (length * (length-1)) / 2
	 * @param {any[]} array an array containing any values
	 * @returns {any[][]} an array of arrays, the inner arrays are all length 2
	 */
	const chooseTwoPairs = (array) => {
		const pairs = Array((array.length * (array.length - 1)) / 2);
		let index = 0;
		for (let i = 0; i < array.length - 1; i += 1) {
			for (let j = i + 1; j < array.length; j += 1, index += 1) {
				pairs[index] = [array[i], array[j]];
			}
		}
		return pairs;
	};
	/**
	 * @description given an array containing undefineds, gather all contiguous
	 * series of valid entries, and return the list of their indices in the form
	 * of [start_index, final_index].
	 * @param {any[]} array the array which is allowed to contain holes
	 * @returns {number[][]} array containing pairs of numbers
	 * @example
	 * circularArrayValidRanges([0, 1, undefined, 2, 3, 4, undefined, undefined, 5])
	 * // will return
	 * [ [8, 1], [3, 5] ]
	 * @linkcode Origami ./src/general/arrays.js 197
	 */
	// export const circularArrayValidRanges = (array) => {
	// 	// if the array contains no undefineds, return the default state.
	// 	const not_undefineds = array.map(el => el !== undefined);
	// 	if (not_undefineds.reduce((a, b) => a && b, true)) {
	// 		return [[0, array.length - 1]];
	// 	}
	// 	// mark the location of the first-in-a-list of valid entries.
	// 	const first_not_undefined = not_undefineds
	// 		.map((el, i, arr) => el && !arr[(i - 1 + arr.length) % arr.length]);
	// 	// this is the number of sets we have. will be >= 1
	// 	const total = first_not_undefined.reduce((a, b) => a + (b ? 1 : 0), 0);
	// 	// the location of the starting index of each contiguous set
	// 	const starts = Array(total);
	// 	// the length of contiguous each set.
	// 	const counts = Array(total).fill(0);
	// 	// we want the set that includes index 0 to be listed first,
	// 	// if that doesn't exist, the next lowest index should be first.
	// 	let index = not_undefineds[0] && not_undefineds[array.length - 1]
	// 		? 0
	// 		: (total - 1);
	// 	not_undefineds.forEach((el, i) => {
	// 		index = (index + (first_not_undefined[i] ? 1 : 0)) % counts.length;
	// 		counts[index] += not_undefineds[i] ? 1 : 0;
	// 		if (first_not_undefined[i]) { starts[index] = i; }
	// 	});
	// 	return starts.map((s, i) => [s, (s + counts[i] - 1) % array.length]);
	// };
	/**
	 * @description given an array containing undefineds, starting at index 0,
	 * walk backwards (circularly around) to find the first index that isn't
	 * undefined. similarly, from 0 increment to the final index that isn't
	 * undefined. no undefineds results in [0, length].
	 * @param {any[]} the array, which possibly contains holes
	 * @param {number} the length of the array. this is required because
	 * it's possible that the holes exist at the end of the array,
	 * causing it to misreport the (intended) length.
	 */
	// const circularArrayValidRange = (array, array_length) => {
	//   let start, end;
	//   for (start = array_length - 1;
	//     start >= 0 && array[start] !== undefined;
	//     start--);
	//   start = (start + 1) % array_length;
	//   for (end = 0;
	//     end < array_length && array[end] !== undefined;
	//     end++);
	//   return [start, end];
	// };

	// this is now "invertSimpleMap" in maps.js
	// export const invert_array = (a) => {
	// 	const b = [];
	// 	a.forEach((n, i) => { b[n] = i; });
	// 	return b;
	// };

	// export const invert_array = (a) => {
	//  const b = [];
	//  a.forEach((x, i) => {
	//		if (typeof x === "number") { b[x] = i; }
	//	});
	//  return b;
	// };

	var arrays = /*#__PURE__*/Object.freeze({
		__proto__: null,
		booleanMatrixToIndexedArray: booleanMatrixToIndexedArray,
		booleanMatrixToUniqueIndexPairs: booleanMatrixToUniqueIndexPairs,
		chooseTwoPairs: chooseTwoPairs,
		clusterParallelVectors: clusterParallelVectors,
		clusterScalars: clusterScalars,
		nonUniqueElements: nonUniqueElements,
		selfRelationalUniqueIndexPairs: selfRelationalUniqueIndexPairs,
		splitCircularArray: splitCircularArray,
		uniqueElements: uniqueElements,
		uniqueSortedNumbers: uniqueSortedNumbers
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @name replace
	 * @memberof graph
	 * @description Replaces vertices, edges, or faces (or anything really)
	 * replace elements from inside arrays, shift up remaining components,
	 * and updates all relevant references across other arrays due to shifting.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} key like "vertices", the prefix of the arrays
	 * @param {number[]} replaceIndices an array of vertex indices, like [1,9,25]
	 * @returns {number[]} a map of changes to the graph
	 * @example replace(foldObject, "vertices", [2,6,11,15]);
	 * @example
	 * for example: removing index 5 from a 10-long vertices list will shift all
	 * indices > 5 up by one, and then will look through all other arrays like
	 * edges_vertices, faces_vertices and update any reference to indices 6-9
	 * to match their new positions 5-8.
	 *
	 * this can handle removing multiple indices at once; and is faster than
	 * otherwise calling this multiple times with only one or a few removals.
	 * @linkcode Origami ./src/graph/replace.js 30
	 */
	// replaceIndices: [4:3, 7:5, 8:3, 12:3, 14:9] where keys are indices to remove
	const replaceGeometryIndices = (graph, key, replaceIndices) => {
		const geometry_array_size = count(graph, key);
		// make sure replace indices are well-formed. values cannot be larger than keys.
		// if this is the case, flip the index/value, assuming the two geometry items
		// are interchangeable and it doesn't matter which one we remove, but warn
		// the user that this took place.
		let didModify = false;
		Object.entries(replaceIndices)
			.filter(([index, value]) => index < value)
			.forEach(([index, value]) => {
				didModify = true;
				delete replaceIndices[index];
				replaceIndices[value] = index;
			});
		if (didModify) {
			console.warn(Messages$1.replaceModifyParam);
		}
		const removes = Object.keys(replaceIndices).map(n => parseInt(n, 10));
		const replaces = uniqueSortedNumbers(removes);
		const index_map = [];
		for (let i = 0, j = 0, walk = 0; i < geometry_array_size; i += 1, j += 1) {
			while (i === replaces[walk]) {
				// this prevents arrays with holes
				index_map[i] = index_map[replaceIndices[replaces[walk]]];
				if (index_map[i] === undefined) {
					throw new Error(Messages$1.replaceUndefined);
				}
				i += 1;
				walk += 1;
			}
			if (i < geometry_array_size) { index_map[i] = j; }
		}
		// update every component that points to vertices_coords
		// these arrays do not change their size, only their contents
		filterKeysWithSuffix(graph, key)
			.forEach(sKey => graph[sKey]
				.forEach((_, ii) => graph[sKey][ii]
					.forEach((v, jj) => { graph[sKey][ii][jj] = index_map[v]; })));
		// update every array with a 1:1 relationship to vertices_ arrays
		// these arrays do change their size, their contents are untouched
		replaces.reverse();
		filterKeysWithPrefix(graph, key)
			.forEach((prefix_key) => replaces
				.forEach(index => graph[prefix_key]
					.splice(index, 1)));
		return index_map;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Get the indices of all vertices which lie close to other vertices.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} arrays of clusters of similar vertices. todo check this
	 * @linkcode Origami ./src/graph/verticesViolations.js 15
	 */
	const duplicateVertices = (graph, epsilon) => (
		getVerticesClusters(graph, epsilon)
			.filter(arr => arr.length > 1)
	);
	/**
	 * @description This will shrink the number of vertices in the graph,
	 * if vertices are close within an epsilon, it will keep the first one,
	 * find the average of close points, and assign it to the remaining vertex.
	 * **this has the potential to create circular and duplicate edges**.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} summary of changes
	 * @linkcode Origami ./src/graph/verticesViolations.js 129
	 */
	const removeDuplicateVertices = (graph, epsilon = EPSILON) => {
		// replaces array will be [index:value] index is the element to delete,
		// value is the index this element will be replaced by.
		const replace_indices = [];
		// "remove" is only needed for the return value summary.
		const remove_indices = [];
		// clusters is array of indices, for example: [ [4, 13, 7], [0, 9] ]
		const clusters = getVerticesClusters(graph, epsilon)
			.filter(arr => arr.length > 1);
		// for each cluster of n, all indices from [1...n] will be replaced with [0]
		clusters.forEach(cluster => {
			// replace() must maintain index > value, ensure index[0] is the
			// smallest of the set (most of the time it is)
			if (Math.min(...cluster) !== cluster[0]) {
				cluster.sort((a, b) => a - b);
			}
			for (let i = 1; i < cluster.length; i += 1) {
				replace_indices[cluster[i]] = cluster[0];
				remove_indices.push(cluster[i]);
			}
		});
		// for each cluster, average all vertices-to-merge to get their new point.
		// set the vertex at the index[0] (the index to keep) to the new point.
		clusters
			.map(arr => arr.map(i => graph.vertices_coords[i]))
			.map(arr => average(...arr))
			.forEach((point, i) => { graph.vertices_coords[clusters[i][0]] = point; });
		return {
			map: replaceGeometryIndices(graph, _vertices, replace_indices),
			remove: remove_indices,
		};
	};

	var verticesDuplicate = /*#__PURE__*/Object.freeze({
		__proto__: null,
		duplicateVertices: duplicateVertices,
		removeDuplicateVertices: removeDuplicateVertices
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @name remove
	 * @memberof graph
	 * @description Removes vertices, edges, or faces (or anything really)
	 * remove elements from inside arrays, shift up remaining components,
	 * and updates all relevant references across other arrays due to shifting.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} key like "vertices", the prefix of the arrays
	 * @param {number[]} removeIndices an array of vertex indices, like [1,9,25]
	 * @returns {number[]} a map of changes to the graph
	 * @example remove(foldObject, "vertices", [2,6,11,15]);
	 * @example
	 * removing index 5 from a 10-long vertices list will shift all
	 * indices > 5 up by one, and then will look through all other arrays like
	 * edges_vertices, faces_vertices and update any reference to indices 6-9
	 * to match their new positions 5-8.
	 *
	 * this can handle removing multiple indices at once; and is faster than
	 * otherwise calling this multiple times with only one or a few removals.
	 * @example
	 * given removeIndices: [4, 6, 7];
	 * given a geometry array: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
	 * map becomes (_=undefined): [0, 1, 2, 3, _, 4, _, _, 5, 6];
	 * @linkcode Origami ./src/graph/remove.js 33
	 */
	const removeGeometryIndices = (graph, key, removeIndices) => {
		const geometry_array_size = count(graph, key);
		const removes = uniqueSortedNumbers(removeIndices);
		const index_map = [];
		for (let i = 0, j = 0, walk = 0; i < geometry_array_size; i += 1, j += 1) {
			while (i === removes[walk]) {
				// this prevents arrays with holes
				index_map[i] = undefined;
				i += 1;
				walk += 1;
			}
			if (i < geometry_array_size) { index_map[i] = j; }
		}
		// update every component that points to vertices_coords
		// these arrays do not change their size, only their contents
		filterKeysWithSuffix(graph, key)
			.forEach(sKey => graph[sKey]
				.forEach((_, ii) => graph[sKey][ii]
					.forEach((v, jj) => { graph[sKey][ii][jj] = index_map[v]; })));
		// update every array with a 1:1 relationship to vertices_ arrays
		// these arrays do change their size, their contents are untouched
		removes.reverse();
		filterKeysWithPrefix(graph, key)
			.forEach((prefix_key) => removes
				.forEach(index => graph[prefix_key]
					.splice(index, 1)));
		return index_map;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Get the indices of all vertices which make no appearance in any edge.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} the indices of the isolated vertices
	 * @linkcode Origami ./src/graph/verticesViolations.js 25
	 */
	const edgeIsolatedVertices = ({ vertices_coords, edges_vertices }) => {
		if (!vertices_coords || !edges_vertices) { return []; }
		let count = vertices_coords.length;
		const seen = Array(count).fill(false);
		edges_vertices.forEach((ev) => {
			ev.filter(v => !seen[v]).forEach((v) => {
				seen[v] = true;
				count -= 1;
			});
		});
		return seen
			.map((s, i) => (s ? undefined : i))
			.filter(a => a !== undefined);
	};
	/**
	 * @description Get the indices of all vertices which make no appearance in any face.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} the indices of the isolated vertices
	 * @linkcode Origami ./src/graph/verticesViolations.js 45
	 */
	const faceIsolatedVertices = ({ vertices_coords, faces_vertices }) => {
		if (!vertices_coords || !faces_vertices) { return []; }
		let count = vertices_coords.length;
		const seen = Array(count).fill(false);
		faces_vertices.forEach((fv) => {
			fv.filter(v => !seen[v]).forEach((v) => {
				seen[v] = true;
				count -= 1;
			});
		});
		return seen
			.map((s, i) => (s ? undefined : i))
			.filter(a => a !== undefined);
	};

	// todo this could be improved. for loop instead of forEach + filter.
	// break the loop early.
	/**
	 * @description Get the indices of all vertices which make no appearance in any edge or face.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} the indices of the isolated vertices
	 * @linkcode Origami ./src/graph/verticesViolations.js 68
	 */
	const isolatedVertices = ({ vertices_coords, edges_vertices, faces_vertices }) => {
		if (!vertices_coords) { return []; }
		let count = vertices_coords.length;
		const seen = Array(count).fill(false);
		if (edges_vertices) {
			edges_vertices.forEach((ev) => {
				ev.filter(v => !seen[v]).forEach((v) => {
					seen[v] = true;
					count -= 1;
				});
			});
		}
		if (faces_vertices) {
			faces_vertices.forEach((fv) => {
				fv.filter(v => !seen[v]).forEach((v) => {
					seen[v] = true;
					count -= 1;
				});
			});
		}
		return seen
			.map((s, i) => (s ? undefined : i))
			.filter(a => a !== undefined);
	};
	/**
	 * @description Remove any vertices which are not a part of any edge or
	 * face. This will shift up the remaining vertices indices so that the
	 * vertices arrays will not have any holes, and, additionally it searches
	 * through all _vertices reference arrays and updates the index
	 * references for the shifted vertices.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} [remove_indices] Leave this empty. Otherwise, if
	 * isolatedVertices() has already been called, provide the result here to speed
	 * up the algorithm.
	 * @returns {object} summary of changes
	 * @linkcode Origami ./src/graph/verticesViolations.js 105
	 */
	const removeIsolatedVertices = (graph, remove_indices) => {
		if (!remove_indices) {
			remove_indices = isolatedVertices(graph);
		}
		return {
			map: removeGeometryIndices(graph, _vertices, remove_indices),
			remove: remove_indices,
		};
	};

	// todo
	// export const remove_collinear_vertices = (graph, epsilon = EPSILON) => {
	// };

	var verticesIsolated = /*#__PURE__*/Object.freeze({
		__proto__: null,
		edgeIsolatedVertices: edgeIsolatedVertices,
		faceIsolatedVertices: faceIsolatedVertices,
		isolatedVertices: isolatedVertices,
		removeIsolatedVertices: removeIsolatedVertices
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Convert a 2D vector to an angle in radians.
	 * @param {number[]} v an input vector
	 * @returns {number} the angle in radians
	 * @linkcode Math ./src/general/convert.js 17
	 */
	const vectorToAngle = v => Math.atan2(v[1], v[0]);
	/**
	 * @description Convert an angle in radians to a 2D vector.
	 * @param {number} a the angle in radians
	 * @returns {number[]} a 2D vector
	 * @linkcode Math ./src/general/convert.js 24
	 */
	const angleToVector = a => [Math.cos(a), Math.sin(a)];
	/**
	 * @description Given two points, create a vector-origin line representation
	 * of a line that passes through both points. This will work in n-dimensions.
	 * If there are more than two points, the rest will be ignored.
	 * @param {number[][]} points two points, each point being an array of numbers.
	 * @returns {VecLine} an object with "vector" and "origin".
	 */
	const pointsToLine = (...args) => {
		const points = getArrayOfVectors(...args);
		return {
			vector: subtract(points[1], points[0]),
			origin: points[0],
		};
	};
	/**
	 * @description Convert a line from one parameterization into another.
	 * Convert vector-origin where origin is a point on the line into
	 * normal-distance form where distance the shortest length from the
	 * origin to a point on the line.
	 * @param {VecLine} line a line in vector origin form
	 * @param {UniqueLine} line a line in normal distance form
	 * @linkcode Math ./src/general/convert.js 46
	 */
	const vecLineToUniqueLine = ({ vector, origin }) => {
		const mag = magnitude(vector);
		const normal = rotate90(vector);
		const distance = dot(origin, normal) / mag;
		return { normal: scale$1(normal, 1 / mag), distance };
	};
	/**
	 * @description Convert a line from one parameterization into another.
	 * Convert from normal-distance form where distance the shortest length
	 * from the origin to a point on the line, to vector-origin where origin
	 * is a point on the line.
	 * @param {UniqueLine} line a line in normal distance form
	 * @param {VecLine} line a line in vector origin form
	 * @linkcode Math ./src/general/convert.js 59
	 */
	const uniqueLineToVecLine = ({ normal, distance }) => ({
		vector: rotate270(normal),
		origin: scale$1(normal, distance),
	});

	var convert$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		angleToVector: angleToVector,
		pointsToLine: pointsToLine,
		uniqueLineToVecLine: uniqueLineToVecLine,
		vecLineToUniqueLine: vecLineToUniqueLine,
		vectorToAngle: vectorToAngle
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * measurements involving vectors and radians
	 */
	/**
	 * @description check if the first parameter is counter-clockwise between A and B.
	 * floor and ceiling can be unbounded, this method takes care of 0-2pi wrap around.
	 * @param {number} angle angle in radians
	 * @param {number} floor angle in radians, lower bound
	 * @param {number} ceiling angle in radians, upper bound
	 * @returns {boolean} is the angle between floor and ceiling
	 * @linkcode Math ./src/geometry/radial.js 32
	 */
	const isCounterClockwiseBetween = (angle, floor, ceiling) => {
		while (ceiling < floor) { ceiling += TWO_PI; }
		while (angle > floor) { angle -= TWO_PI; }
		while (angle < floor) { angle += TWO_PI; }
		return angle < ceiling;
	};
	/**
	 * @description There are 2 interior angles between 2 vectors (as an angle in radians),
	 * A-to-B clockwise, and A-to-B counter-clockwise. Get the clockwise one from A to B.
	 * @param {number} a vector as an angle in radians
	 * @param {number} b vector as an angle in radians
	 * @returns {number} interior angle in radians
	 * @linkcode Math ./src/geometry/radial.js 46
	 */
	const clockwiseAngleRadians = (a, b) => {
		// this is on average 50 to 100 times faster than clockwiseAngle2
		while (a < 0) { a += TWO_PI; }
		while (b < 0) { b += TWO_PI; }
		while (a > TWO_PI) { a -= TWO_PI; }
		while (b > TWO_PI) { b -= TWO_PI; }
		const a_b = a - b;
		return (a_b >= 0)
			? a_b
			: TWO_PI - (b - a);
	};
	/**
	 * @description There are 2 interior angles between 2 vectors (as an angle in radians),
	 * A-to-B clockwise, and A-to-B counter-clockwise. Get the counter-clockwise one from A to B.
	 * @param {number} a vector as an angle in radians
	 * @param {number} b vector as an angle in radians
	 * @returns {number} interior angle in radians, counter-clockwise from a to b
	 * @linkcode Math ./src/geometry/radial.js 65
	 */
	const counterClockwiseAngleRadians = (a, b) => {
		// this is on average 50 to 100 times faster than counterClockwiseAngle2
		while (a < 0) { a += TWO_PI; }
		while (b < 0) { b += TWO_PI; }
		while (a > TWO_PI) { a -= TWO_PI; }
		while (b > TWO_PI) { b -= TWO_PI; }
		const b_a = b - a;
		return (b_a >= 0)
			? b_a
			: TWO_PI - (a - b);
	};
	/**
	 * @description There are 2 interior angles between 2 vectors, A-to-B clockwise,
	 * and A-to-B counter-clockwise. Get the clockwise one from A to B.
	 * @param {number[]} a vector as an array of two numbers
	 * @param {number[]} b vector as an array of two numbers
	 * @returns {number} interior angle in radians, clockwise from a to b
	 * @linkcode Math ./src/geometry/radial.js 84
	 */
	const clockwiseAngle2 = (a, b) => {
		const dotProduct = b[0] * a[0] + b[1] * a[1];
		const determinant = b[0] * a[1] - b[1] * a[0];
		let angle = Math.atan2(determinant, dotProduct);
		if (angle < 0) { angle += TWO_PI; }
		return angle;
	};
	/**
	 * @description There are 2 interior angles between 2 vectors, A-to-B clockwise,
	 * and A-to-B counter-clockwise. Get the counter-clockwise one from A to B.
	 * @param {number[]} a vector as an array of two numbers
	 * @param {number[]} b vector as an array of two numbers
	 * @returns {number} interior angle in radians, counter-clockwise from a to b
	 * @linkcode Math ./src/geometry/radial.js 99
	 */
	const counterClockwiseAngle2 = (a, b) => {
		const dotProduct = a[0] * b[0] + a[1] * b[1];
		const determinant = a[0] * b[1] - a[1] * b[0];
		let angle = Math.atan2(determinant, dotProduct);
		if (angle < 0) { angle += TWO_PI; }
		return angle;
	};
	/**
	 * this calculates an angle bisection between the pair of vectors
	 * clockwise from the first vector to the second
	 *
	 *     a  x
	 *       /     . bisection
	 *      /   .
	 *     / .
	 *     --------x  b
	 */
	/**
	 * @description calculate the angle bisection clockwise from the first vector to the second.
	 * @param {number[]} a one 2D vector
	 * @param {number[]} b one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/geometry/radial.js 123
	 */
	const clockwiseBisect2 = (a, b) => (
		angleToVector(vectorToAngle(a) - clockwiseAngle2(a, b) / 2)
	);
	/**
	 * @description calculate the angle bisection counter-clockwise from the first vector to the second.
	 * @param {number[]} a one 2D vector
	 * @param {number[]} b one 2D vector
	 * @returns {number[]} one 2D vector
	 * @linkcode Math ./src/geometry/radial.js 131
	 */
	const counterClockwiseBisect2 = (a, b) => (
		angleToVector(vectorToAngle(a) + counterClockwiseAngle2(a, b) / 2)
	);
	/**
	 * @description subsect into n-divisions the angle clockwise from one angle to the next
	 * @param {number} divisions number of angles minus 1
	 * @param {number} angleA one angle in radians
	 * @param {number} angleB one angle in radians
	 * @returns {number[]} array of angles in radians
	 * @linkcode Math ./src/geometry/radial.js 142
	 */
	const clockwiseSubsectRadians = (angleA, angleB, divisions) => {
		const angle = clockwiseAngleRadians(angleA, angleB) / divisions;
		return Array.from(Array(divisions - 1))
			.map((_, i) => angleA + angle * (i + 1));
	};
	/**
	 * @description subsect into n-divisions the angle counter-clockwise from one angle to the next
	 * @param {number} divisions number of angles minus 1
	 * @param {number} angleA one angle in radians
	 * @param {number} angleB one angle in radians
	 * @returns {number[]} array of angles in radians
	 * @linkcode Math ./src/geometry/radial.js 155
	 */
	const counterClockwiseSubsectRadians = (angleA, angleB, divisions) => {
		const angle = counterClockwiseAngleRadians(angleA, angleB) / divisions;
		return Array.from(Array(divisions - 1))
			.map((_, i) => angleA + angle * (i + 1));
	};
	/**
	 * @description subsect into n-divisions the angle clockwise from one vector to the next
	 * @param {number} divisions number of angles minus 1
	 * @param {number[]} vectorA one vector in array form
	 * @param {number[]} vectorB one vector in array form
	 * @returns {number[][]} array of vectors (which are arrays of numbers)
	 * @linkcode Math ./src/geometry/radial.js 168
	 */
	const clockwiseSubsect2 = (vectorA, vectorB, divisions) => {
		const angleA = Math.atan2(vectorA[1], vectorA[0]);
		const angleB = Math.atan2(vectorB[1], vectorB[0]);
		return clockwiseSubsectRadians(angleA, angleB, divisions)
			.map(angleToVector);
	};
	/**
	 * @description subsect into n-divisions the angle counter-clockwise from one vector to the next
	 * @param {number} divisions number of angles minus 1
	 * @param {number[]} vectorA one vector in array form
	 * @param {number[]} vectorB one vector in array form
	 * @returns {number[][]} array of vectors (which are arrays of numbers)
	 * @linkcode Math ./src/geometry/radial.js 182
	 */
	const counterClockwiseSubsect2 = (vectorA, vectorB, divisions) => {
		const angleA = Math.atan2(vectorA[1], vectorA[0]);
		const angleB = Math.atan2(vectorB[1], vectorB[0]);
		return counterClockwiseSubsectRadians(angleA, angleB, divisions)
			.map(angleToVector);
	};
	/**
	 * @description sort an array of angles in radians by getting an array of
	 * reference indices to the input array, instead of an array of angles.
	 * @todo maybe there is such thing as an absolute radial origin (x axis?)
	 * but this chooses the first element as the first element
	 * and sort everything else counter-clockwise around it.
	 * @param {number[]} ...args array or sequence of angles in radians
	 * @returns {number[]} array of indices of the input array, indicating
	 * the counter-clockwise sorted arrangement.
	 * @linkcode Math ./src/geometry/radial.js 201
	 */
	const counterClockwiseOrderRadians = (...args) => {
		const radians = args.flat();
		const counter_clockwise = radians
			.map((_, i) => i)
			.sort((a, b) => radians[a] - radians[b]);
		return counter_clockwise
			.slice(counter_clockwise.indexOf(0), counter_clockwise.length)
			.concat(counter_clockwise.slice(0, counter_clockwise.indexOf(0)));
	};
	/**
	 * @description sort an array of vectors by getting an array of
	 * reference indices to the input array, instead of a sorted array of vectors.
	 * @param {number[][]} ...args array of vectors (which are arrays of numbers)
	 * @returns {number[]} array of indices of the input array, indicating
	 * the counter-clockwise sorted arrangement.
	 * @linkcode Math ./src/geometry/radial.js 218
	 */
	const counterClockwiseOrder2 = function () {
		return counterClockwiseOrderRadians(
			semiFlattenArrays(arguments).map(vectorToAngle),
		);
	};
	/**
	 * @description given an array of angles, return the sector angles between
	 * consecutive parameters. if radially unsorted, this will sort them.
	 * @param {number[]} ...args array or sequence of angles in radians
	 * @returns {number[]} array of sector angles in radians
	 * @linkcode Math ./src/geometry/radial.js 230
	 */
	const counterClockwiseSectorsRadians = function () {
		const radians = Array.from(arguments).flat();
		const ordered = counterClockwiseOrderRadians(radians)
			.map(i => radians[i]);
		return ordered.map((rad, i, arr) => [rad, arr[(i + 1) % arr.length]])
			.map(pair => counterClockwiseAngleRadians(pair[0], pair[1]));
	};
	/**
	 * @description given an array of vectors, return the sector angles between
	 * consecutive parameters. if radially unsorted, this will sort them.
	 * @param {number[][]} args array of 2D vectors (higher dimensions will be ignored)
	 * @returns {number[]} array of sector angles in radians
	 * @linkcode Math ./src/geometry/radial.js 244
	 */
	const counterClockwiseSectors2 = function () {
		return counterClockwiseSectorsRadians(
			semiFlattenArrays(arguments).map(vectorToAngle),
		);
	};
	/**
	 * subsect the angle between two lines, can handle parallel lines
	 */
	// export const subsect = function (divisions, pointA, vectorA, pointB, vectorB) {
	//   const denominator = vectorA[0] * vectorB[1] - vectorB[0] * vectorA[1];
	//   if (Math.abs(denominator) < EPSILON) { /* parallel */
	//     const solution = [midpoint(pointA, pointB), [vectorA[0], vectorA[1]]];
	//     const array = [solution, solution];
	//     const dot = vectorA[0] * vectorB[0] + vectorA[1] * vectorB[1];
	//     delete array[(dot > 0 ? 1 : 0)];
	//     return array;
	//   }
	//   const numerator = (pointB[0] - pointA[0]) * vectorB[1] - vectorB[0] * (pointB[1] - pointA[1]);
	//   const t = numerator / denominator;
	//   const x = pointA[0] + vectorA[0] * t;
	//   const y = pointA[1] + vectorA[1] * t;
	//   const bisects = bisect_vectors(vectorA, vectorB);
	//   bisects[1] = [-bisects[0][1], bisects[0][0]];
	//   return bisects.map(el => [[x, y], el]);
	// };
	/**
	 * @description which turn direction do 3 points make? clockwise or couter-clockwise
	 * @param {number[]} p0 the start point
	 * @param {number[]} p1 the middle point
	 * @param {number[]} p2 the end point
	 * @param {number} [epsilon=1e-6] optional epsilon
	 * @returns {number|undefined} with 4 possible results:
	 * - "0": collinear, no turn, forward
	 * - "1": counter-clockwise turn, 0+epsilon < x < 180-epsilon
	 * - "-1": clockwise turn, 0-epsilon > x > -180+epsilon
	 * - "undefined": collinear but with a 180 degree turn.
	 * @linkcode Math ./src/geometry/radial.js 282
	 */
	const threePointTurnDirection = (p0, p1, p2, epsilon = EPSILON) => {
		const v = normalize2(subtract2(p1, p0));
		const u = normalize2(subtract2(p2, p0));
		// not collinear
		const cross = cross2(v, u);
		if (!epsilonEqual(cross, 0, epsilon)) {
			return Math.sign(cross);
		}
		// collinear. now we have to ensure the order is 0, 1, 2, and point
		// 1 lies between 0 and 2. otherwise we made a 180 degree turn (return undefined)
		return epsilonEqual(distance2(p0, p1) + distance2(p1, p2), distance2(p0, p2))
			? 0
			: undefined;
	};

	var radial = /*#__PURE__*/Object.freeze({
		__proto__: null,
		clockwiseAngle2: clockwiseAngle2,
		clockwiseAngleRadians: clockwiseAngleRadians,
		clockwiseBisect2: clockwiseBisect2,
		clockwiseSubsect2: clockwiseSubsect2,
		clockwiseSubsectRadians: clockwiseSubsectRadians,
		counterClockwiseAngle2: counterClockwiseAngle2,
		counterClockwiseAngleRadians: counterClockwiseAngleRadians,
		counterClockwiseBisect2: counterClockwiseBisect2,
		counterClockwiseOrder2: counterClockwiseOrder2,
		counterClockwiseOrderRadians: counterClockwiseOrderRadians,
		counterClockwiseSectors2: counterClockwiseSectors2,
		counterClockwiseSectorsRadians: counterClockwiseSectorsRadians,
		counterClockwiseSubsect2: counterClockwiseSubsect2,
		counterClockwiseSubsectRadians: counterClockwiseSubsectRadians,
		isCounterClockwiseBetween: isCounterClockwiseBetween,
		threePointTurnDirection: threePointTurnDirection
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Search inside arrays inside arrays and return
	 * the largest number.
	 * @returns {number} largest number in array in arrays.
	 */
	const array_in_array_max_number = (arrays) => {
		let max = -1; // will become 0 if nothing is found
		arrays
			.filter(a => a !== undefined)
			.forEach(arr => arr
				.forEach(el => el
					.forEach((e) => {
						if (e > max) { max = e; }
					})));
		return max;
	};
	/**
	 * @description Search inside arrays inside arrays and return
	 * the largest number by only checking indices 0 and 1 in the
	 * inner arrays.
	 * @returns {number} largest number in indices 0 or 1 of array in arrays.
	 */
	const max_num_in_orders = (array) => {
		let max = -1; // will become 0 if nothing is found
		array.forEach(el => {
			// exception. index 2 is orientation, not index. check only 0, 1
			if (el[0] > max) { max = el[0]; }
			if (el[1] > max) { max = el[1]; }
		});
		return max;
	};
	const ordersArrayNames = {
		edges: "edgeOrders",
		faces: "faceOrders",
	};
	/**
	 * @description Get the number of vertices, edges, or faces in the graph, as
	 * evidenced by their appearance in other arrays; ie: searching faces_vertices
	 * for the largest vertex index, and inferring number of vertices is that long.
	 * @param {FOLD} graph a FOLD graph
	 * @param {string} key the prefix for a key, eg: "vertices"
	 * @returns {number} the number of vertices, edges, or faces in the graph.
	 * @linkcode Origami ./src/graph/countImplied.js 48
	 */
	const countImplied = (graph, key) => Math.max(
		// return the maximum value between (1/2):
		// 1. a found geometry in another geometry's array ("vertex" in "faces_vertices")
		array_in_array_max_number(
			filterKeysWithSuffix(graph, key).map(str => graph[str]),
		),
		// 2. a found geometry in a faceOrders or edgeOrders type of array (special case)
		graph[ordersArrayNames[key]]
			? max_num_in_orders(graph[ordersArrayNames[key]])
			: -1,
	) + 1;

	// standard graph components names
	countImplied.vertices = graph => countImplied(graph, _vertices);
	countImplied.edges = graph => countImplied(graph, _edges);
	countImplied.faces = graph => countImplied(graph, _faces);

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description discover a face by walking neighboring vertices until returning to the start.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} v0 starting vertex
	 * @param {number} v1 second vertex, this sets the direction of the walk
	 * @param {object} [walked_edges={}] memo object, to prevent walking down
	 * duplicate paths, or finding duplicate faces, this dictionary will
	 * store and check against vertex pairs "i j".
	 * @returns {object} the walked face, an object arrays of numbers
	 * under "vertices", "edges", and "angles"
	 * @linkcode Origami ./src/graph/walk.js 14
	 */
	const counterClockwiseWalk = ({
		vertices_vertices, vertices_sectors,
	}, v0, v1, walked_edges = {}) => {
		// each time we visit an edge (vertex pair as string, "4 9") add it here.
		// this gives us a quick lookup to see if we've visited this edge before.
		const this_walked_edges = {};
		// return the face: { vertices, edges, angles }
		const face = { vertices: [v0], edges: [], angles: [] };
		// walking the graph, we look at 3 vertices at a time. in sequence:
		// prev_vertex, this_vertex, next_vertex
		let prev_vertex = v0;
		let this_vertex = v1;
		while (true) {
			// even though vertices_vertices are sorted counter-clockwise,
			// to make a counter-clockwise wound face, when we visit a vertex's
			// vertices_vertices array we have to select the [n-1] vertex, not [n+1],
			// it's a little counter-intuitive.
			const v_v = vertices_vertices[this_vertex];
			const from_neighbor_i = v_v.indexOf(prev_vertex);
			const next_neighbor_i = (from_neighbor_i + v_v.length - 1) % v_v.length;
			const next_vertex = v_v[next_neighbor_i];
			const next_edge_vertices = `${this_vertex} ${next_vertex}`;
			// check if this edge was already walked 2 ways:
			// 1. if we visited this edge while making this face, we are done.
			if (this_walked_edges[next_edge_vertices]) {
				Object.assign(walked_edges, this_walked_edges);
				face.vertices.pop();
				return face;
			}
			this_walked_edges[next_edge_vertices] = true;
			// 2. if we visited this edge (with vertices in the same sequence),
			// because of the counterclockwise winding, we are looking at a face
			// that has already been built.
			if (walked_edges[next_edge_vertices]) {
				return undefined;
			}
			face.vertices.push(this_vertex);
			face.edges.push(next_edge_vertices);
			if (vertices_sectors) {
				face.angles.push(vertices_sectors[this_vertex][next_neighbor_i]);
			}
			prev_vertex = this_vertex;
			this_vertex = next_vertex;
		}
	};
	/**
	 * @description Given a planar graph, discover all faces by counter-clockwise walking
	 * by starting at every edge.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {object[]} an array of face objects, where each face has number arrays,
	 * "vertices", "edges", and "angles". vertices and edges are indices, angles are radians.
	 * @linkcode Origami ./src/graph/walk.js 67
	 */
	const planarVertexWalk = ({ vertices_vertices, vertices_sectors }) => {
		const graph = { vertices_vertices, vertices_sectors };
		const walked_edges = {};
		return vertices_vertices
			.map((adj_verts, v) => adj_verts
				.map(adj_vert => counterClockwiseWalk(graph, v, adj_vert, walked_edges))
				.filter(a => a !== undefined))
			.flat();
	};
	/**
	 * @description This should be used in conjuction with planarVertexWalk() and
	 * counterClockwiseWalk(). There will be one face in the which winds around the
	 * outside of the boundary and encloses the space outside around. This method will
	 * find that face and remove it from the set.
	 * @algorithm 180 - sector angle = the turn angle. counter clockwise
	 * turns are +, clockwise will be -, this removes the one face that
	 * outlines the piece with opposite winding enclosing Infinity.
	 * @param {object[]} walked_faces the result from calling "planarVertexWalk()"
	 * @returns {object[]} the same input array with one fewer element
	 * @linkcode Origami ./src/graph/walk.js 88
	 */
	const filterWalkedBoundaryFace = walked_faces => walked_faces
		.filter(face => face.angles
			.map(a => Math.PI - a)
			.reduce((a, b) => a + b, 0) > 0);

	var walk = /*#__PURE__*/Object.freeze({
		__proto__: null,
		counterClockwiseWalk: counterClockwiseWalk,
		filterWalkedBoundaryFace: filterWalkedBoundaryFace,
		planarVertexWalk: planarVertexWalk
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Given a single object against which to compare,
	 * iterate through an array of the same type and run a custom
	 * comparison function which abides by this format:
	 * (a:any, b:any) => number. The element in the array which returns
	 * the smallest value, its index will be returned.
	 * @param {any} obj the single item to test against the set
	 * @param {any[]} array the set of items to test against
	 * @param {function} compare_func a function which takes two items (which match
	 * the type of the first parameter), execution of this function should return a scalar.
	 * @returns {number[]} the index from the set which minimizes the compare function
	 * @linkcode Math ./src/general/search.js 17
	 */
	const smallestComparisonSearch = (array, obj, compare_func) => {
		const objs = array.map((o, i) => ({ i, d: compare_func(obj, o) }));
		let index;
		let smallest_value = Infinity;
		for (let i = 0; i < objs.length; i += 1) {
			if (objs[i].d < smallest_value) {
				index = i;
				smallest_value = objs[i].d;
			}
		}
		return index;
	};
	/**
	 * @description Find the indices from an array of vectors which all have
	 * the smallest value within an epsilon.
	 * @param {number[][]} vectors array of vectors
	 * @returns {number[]} array of indices which all have the lowest X value.
	 * @linkcode Math ./src/general/search.js 36
	 */
	// const smallestVectorSearch = (vectors, axis = 0, compFn = epsilonCompare, epsilon = EPSILON) => {
	const smallestVectorSearch = (vectors, axis, compFn, epsilon) => {
		// find the set of all vectors that share the smallest X value within an epsilon
		let smallSet = [0];
		for (let i = 1; i < vectors.length; i += 1) {
			switch (compFn(vectors[i][axis], vectors[smallSet[0]][axis], epsilon)) {
			case 0: smallSet.push(i); break;
			case 1: smallSet = [i]; break;
			}
		}
		return smallSet;
	};
	/**
	 * @description Get the index of the point in an array
	 * considered the absolute minimum. First check the X values,
	 * and in the case of multiple minimums, check the Y values.
	 * If there are more than two points that share both X and Y,
	 * return the first one found.
	 * @param {number[][]} points array of points
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number|undefined} the index of the point in the array with
	 * the smallest component values, or undefined if points is empty.
	 * @linkcode Math ./src/general/search.js 60
	 */
	const minimum2DPointIndex = (points, epsilon = EPSILON) => {
	// export const minimumPointIndex = (points, epsilon = EPSILON) => {
		if (!points || !points.length) { return undefined; }
		// find the set of all points that share the smallest X value
		// const smallSet = smallestVectorSearch(points, 0, epsilonCompare, epsilon);
		const smallSet = smallestVectorSearch(points, 0, epsilonCompare, epsilon);
		// from this set, find the point with the smallest Y value
		let sm = 0;
		for (let i = 1; i < smallSet.length; i += 1) {
			if (points[smallSet[i]][1] < points[smallSet[sm]][1]) { sm = i; }
		}
		return smallSet[sm];
		// idea to make this N-dimensional. requires back-mapping indices
		// through all the subsets returned by smallestVectorSearch
		// const dimensions = points[0].length;
		// let set = points.map((_, i) => i);
		// const levelMap = [];
		// for (let d = 0; d < dimensions; d += 1) {
		// 	const indices = levelMap[0].map((_, i) => i);
		// 	levelMap.forEach(map => indices.forEach((s, i) => { indices[i] = map[s]; }));
		// 	set = smallestVectorSearch(indices.map(i => points[i]), d, epsilonCompare, epsilon);
		// 	levelMap.push(set);
		// }
		// console.log("levelMap", levelMap);
		// oh no. the indices don't carry over each round
		// we have to back map the indices from levelMap.
	};

	var search = /*#__PURE__*/Object.freeze({
		__proto__: null,
		minimum2DPointIndex: minimum2DPointIndex,
		smallestComparisonSearch: smallestComparisonSearch
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Provide a comparison function and use it to sort an array
	 * of any type of object against a single item. The returned array will be
	 * the indices of the original array in sorted order.
	 * @param {any[]} array an array of elements to be sorted
	 * @param {any} item the item which to compare against all array elements
	 * @param {function} compareFn the comparison function to be run against
	 * every element in the array with the input item parameter, placing
	 * the array element first, the input item second: fn(arrayElem, paramItem)
	 * @returns {number[]} the indices of the original array, in sorted order
	 * @linkcode Math ./src/general/sort.js 24
	 */
	const sortAgainstItem = (array, item, compareFn) => array
		.map((el, i) => ({ i, n: compareFn(el, item) }))
		.sort((a, b) => a.n - b.n)
		.map(a => a.i);
	/**
	 * @description Sort an array of n-dimensional points along an
	 * n-dimensional vector, get the indices in sorted order.
	 * @param {number[][]} points array of points (which are arrays of numbers)
	 * @param {number[]} vector one vector
	 * @returns {number[]} a list of sorted indices to the points array.
	 * @linkcode Math ./src/general/sort.js 36
	 */
	const sortPointsAlongVector = (points, vector) => (
		sortAgainstItem(points, vector, dot)
	);
	/**
	 * @description given an array of already-sorted values (so that
	 * comparisons only need to happen between neighboring items),
	 * cluster the numbers which are similar within an epsilon.
	 * Isolated values still get put in length-1 arrays. (all values returned)
	 * and the clusters contain the indices from the param array, not the values.
	 * @param {number[]} numbers an array of sorted numbers
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} an array of arrays, each inner array containin indices.
	 * each inner array represents clusters of values which lie within an epsilon.
	 * @linkcode Math ./src/general/sort.js 51
	 */
	const clusterIndicesOfSortedNumbers = (numbers, epsilon = EPSILON) => {
		const clusters = [[0]];
		let clusterIndex = 0;
		for (let i = 1; i < numbers.length; i += 1) {
			// if this scalar fits inside the current cluster
			if (epsilonEqual(numbers[i], numbers[i - 1], epsilon)) {
				clusters[clusterIndex].push(i);
			} else {
				clusterIndex = clusters.length;
				clusters.push([i]);
			}
		}
		return clusters;
	};
	/**
	 * @description radially sort 2D point indices around the lowest-
	 * value point, clustering similarly-angled points within an epsilon.
	 * Within these clusters, the points are sorted by distance so the
	 * nearest point is listed first.
	 * @param {number[][]} points an array of points
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} this returns indices in clusters.
	 * @todo there is a wrap-around point where the cycle will not cluster
	 * values which otherwise should be clustered.
	 * @linkcode Math ./src/general/sort.js 75
	 */
	const radialSortPointIndices2 = (points, epsilon = EPSILON) => {
		const first = minimum2DPointIndex(points, epsilon);
		if (first === undefined) { return []; }
		const angles = points
			.map(p => subtract2(p, points[first]))
			.map(v => normalize2(v))
			.map(vec => dot2([0, 1], vec));
			// .map((p, i) => Math.atan2(unitVecs[i][1], unitVecs[i][0]));
		const rawOrder = angles
			.map((a, i) => ({ a, i }))
			.sort((a, b) => a.a - b.a)
			.map(el => el.i)
			.filter(i => i !== first);
		return [[first]]
			.concat(clusterIndicesOfSortedNumbers(rawOrder.map(i => angles[i]), epsilon)
				.map(arr => arr.map(i => rawOrder[i]))
				.map(cluster => (cluster.length === 1 ? cluster : cluster
					.map(i => ({ i, len: distance2(points[i], points[first]) }))
					.sort((a, b) => a.len - b.len)
					.map(el => el.i))));
	};

	var sort = /*#__PURE__*/Object.freeze({
		__proto__: null,
		clusterIndicesOfSortedNumbers: clusterIndicesOfSortedNumbers,
		radialSortPointIndices2: radialSortPointIndices2,
		sortAgainstItem: sortAgainstItem,
		sortPointsAlongVector: sortPointsAlongVector
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description This is a subroutine for building vertices_vertices. This will
	 * take a set of vertices indices and a vertex index to be the center point, and
	 * sort the indices radially counter-clockwise.
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} vertices an array of vertex indices to be sorted
	 * @param {number} vertex the origin vertex, around which the vertices will be sorted
	 * @returns {number[]} indices of vertices, in sorted order
	 * @linkcode Origami ./src/graph/sort.js 15
	 */
	const sortVerticesCounterClockwise = ({ vertices_coords }, vertices, vertex) => (
		vertices
			.map(v => vertices_coords[v])
			.map(coord => subtract(coord, vertices_coords[vertex]))
			.map(vec => Math.atan2(vec[1], vec[0]))
			// optional line, this makes the cycle loop start/end along the +X axis
			.map(angle => (angle > -EPSILON ? angle : angle + Math.PI * 2))
			.map((a, i) => ({ a, i }))
			.sort((a, b) => a.a - b.a)
			.map(el => el.i)
			.map(i => vertices[i])
	);
	/**
	 * @description sort a subset of vertices from a graph along a vector.
	 * eg: given the vector [1,0], points according to their X value.
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} vertices the indices of vertices to be sorted
	 * @param {number[]} vector a vector along which to sort vertices
	 * @returns {number[]} indices of vertices, in sorted order
	 * @linkcode Origami ./src/graph/sort.js 36
	 */
	// export const sortVerticesAlongVector = ({ vertices_coords }, vertices, vector) => (
	// 	vertices
	// 		.map(i => ({ i, d: dot(vertices_coords[i], vector) }))
	// 		.sort((a, b) => a.d - b.d)
	// 		.map(a => a.i)
	// );
	const sortVerticesAlongVector = ({ vertices_coords }, vertices, vector) => (
		sortPointsAlongVector(
			vertices.map(v => vertices_coords[v]),
			vector,
		).map(i => vertices[i])
	);

	var verticesSort = /*#__PURE__*/Object.freeze({
		__proto__: null,
		sortVerticesAlongVector: sortVerticesAlongVector,
		sortVerticesCounterClockwise: sortVerticesCounterClockwise
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const makeFacesNormal = ({ vertices_coords, faces_vertices }) => faces_vertices
		.map(vertices => vertices
			.map(vertex => vertices_coords[vertex]))
		.map(polygon => {
			// cross product unit vectors from point 0 to point 1 and 2.
			// as long as the face winding data is consistent, this gives consistent face normals
			const a = resize(3, subtract(polygon[1], polygon[0]));
			const b = resize(3, subtract(polygon[2], polygon[0]));
			return normalize3(cross3(a, b));
		});
	/**
	 *
	 */
	const makeVerticesNormal = ({ vertices_coords, faces_vertices, faces_normal }) => {
		// add two 3D vectors, store result in first parameter
		const add3 = (a, b) => { a[0] += b[0]; a[1] += b[1]; a[2] += b[2]; };
		if (!faces_normal) {
			faces_normal = makeFacesNormal({ vertices_coords, faces_vertices });
		}
		const vertices_normals = vertices_coords.map(() => [0, 0, 0]);
		faces_vertices
			.forEach((vertices, f) => vertices
				.forEach(v => add3(vertices_normals[v], faces_normal[f])));
		return vertices_normals.map(v => normalize3(v));
	};

	var normals = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeFacesNormal: makeFacesNormal,
		makeVerticesNormal: makeVerticesNormal
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * This is one big file (sorry) which contains methods to create all the
	 * geometry arrays in the FOLD spec, like "vertices_vertices", "faces_edges"..
	 *
	 * They are all named in camelCase (not snake), following the format:
	 * "make" + the FOLD array name + any clarifying comments such as
	 * "2D" or "from___" describing where the data is pulled from.
	 *
	 * all of the parameters required for each method follow a similar format:
	 * the first argument is a FOLD graph. and the graph remains unmodified.
	 * the method returns the data array.
	 *
	 * if you want to modify the input graph, assign the property after making it
	 *  var graph = {...};
	 *  graph.faces_faces = makeFacesFaces(graph);
	 */
	/**
	 *
	 *    VERTICES
	 *
	 */
	/**
	 * @description Make `vertices_edges` from `edges_vertices`, unsorted, which should
	 * be used sparingly. Prefer makeVerticesEdges().
	 * @param {FOLD} graph a FOLD object, containing edges_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are edge indices.
	 * @linkcode Origami ./src/graph/make.js 56
	 */
	const makeVerticesEdgesUnsorted = ({ edges_vertices }) => {
		const vertices_edges = [];
		// iterate over edges_vertices and swap the index for each of the contents
		// each edge (index 0: [3, 4]) will be converted into (index 3: [0], index 4: [0])
		// repeat. append to each array.
		edges_vertices.forEach((ev, i) => ev
			.forEach((v) => {
				if (vertices_edges[v] === undefined) {
					vertices_edges[v] = [];
				}
				vertices_edges[v].push(i);
			}));
		return vertices_edges;
	};
	/**
	 * @description Make `vertices_edges` sorted, so that the edges are sorted
	 * radially around the vertex, corresponding with the order in `vertices_vertices`.
	 * @param {FOLD} graph a FOLD object, containing edges_vertices, vertices_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are edge indices.
	 * @linkcode Origami ./src/graph/make.js 78
	 */
	const makeVerticesEdges = ({ edges_vertices, vertices_vertices }) => {
		const edge_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		return vertices_vertices
			.map((verts, i) => verts
				.map(v => edge_map[`${i} ${v}`]));
	};
	/**
	 * @description Make `vertices_vertices` sorted radially counter-clockwise.
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, vertices_edges, edges_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are vertex indices.
	 * @linkcode Origami ./src/graph/make.js 91
	 */
	const makeVerticesVertices2D = ({ vertices_coords, vertices_edges, edges_vertices }) => {
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		// use adjacent edges to find adjacent vertices
		const vertices_vertices = vertices_edges
			.map((edges, v) => edges
				// the adjacent edge's edges_vertices also contains this vertex,
				// filter it out and we're left with the adjacent vertices
				.map(edge => edges_vertices[edge]
					.filter(i => i !== v))
				.reduce((a, b) => a.concat(b), []));
		return vertices_coords === undefined
			? vertices_vertices
			: vertices_vertices
				.map((verts, i) => sortVerticesCounterClockwise({ vertices_coords }, verts, i));
	};
	/**
	 * @description Make `vertices_vertices` sorted radially counter-clockwise.
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, vertices_edges, edges_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are vertex indices.
	 * @linkcode Origami ./src/graph/make.js 115
	 */
	const makeVerticesVerticesFromFaces = ({
		vertices_coords, vertices_faces, faces_vertices,
	}) => {
		if (!vertices_faces) {
			vertices_faces = makeVerticesFacesUnsorted({ vertices_coords, faces_vertices });
		}
		// every iterate through every vertices_faces's faces_vertices
		const vertices_faces_vertices = vertices_faces
			.map(faces => faces.map(f => faces_vertices[f]));
		// for every vertex, find its index in its faces_vertices array.
		const vertices_faces_indexOf = vertices_faces_vertices
			.map((faces, vertex) => faces.map(verts => verts.indexOf(vertex)));
		// get the three vertices (before, this vertex, after) in this vertex's
		// faces_vertices array maintaining the counter clockwise order.
		const vertices_faces_threeIndices = vertices_faces_vertices
			.map((faces, vertex) => faces.map((verts, j) => [
				(vertices_faces_indexOf[vertex][j] + verts.length - 1) % verts.length,
				vertices_faces_indexOf[vertex][j],
				(vertices_faces_indexOf[vertex][j] + 1) % verts.length,
			]));
		// conver these three indices in face_vertices arrays into absolute
		// indices to vertices, so that we have three consecutive vertex indices.
		// for example, vertex #7's entry might be an array containing:
		// [141, 7, 34]
		// [34, 7, 120]
		// [120, 7, 141]
		const vertices_faces_threeVerts = vertices_faces_threeIndices
			.map((faces, vertex) => faces
				.map((indices, j) => indices
					.map(index => vertices_faces_vertices[vertex][j][index])));
		// convert the three neighbor vertices into two pairs, maintaining order,
		// which include the vertex in the middle, these represent the pairs of
		// vertices which make up the edge of the face, for all faces, in counter-
		// clockwise order around this vertex.
		const vertices_verticesLookup = vertices_faces_threeVerts.map(faces => {
			// facesVerts matches the order in this vertex's faces_vertices array.
			// it contains vertex pair keys ([141, 7, 34] becomes ["141 7", "7 34"])
			// which represent this face's adjacent vertices to our vertex
			// coming to and from this vertex.
			const facesVerts = faces
				.map(verts => [[0, 1], [1, 2]]
					.map(p => p.map(x => verts[x]).join(" ")));
			const from = {};
			const to = {};
			facesVerts.forEach((keys, i) => {
				from[keys[0]] = i;
				to[keys[1]] = i;
			});
			return { facesVerts, to, from };
		});
		// using the data from above, walk around the vertex by starting with an
		// edge, an edge represented as a pair of vertices, and alternate:
		// 1. using the vertex-pair's adjacent face to get the other pair in
		//    the same face, and,
		// 2. swapping the vertices in the string ("141 7" becomes "7 141") to
		//    find jump to another face, this being the adjacent face in the walk.
		// care needs to be taken because this vertex may be adjacent to holes.
		// a solution is possible if there are up to two holes, but a vertex
		// with more than two holes is technically unsolvable.
		return vertices_verticesLookup.map(lookup => {
			// locate any holes if they exist, holes are when the inverse of
			// a "to" key does not exist in the "from" lookup, or visa versa.
			const toKeys = Object.keys(lookup.to);
			const toKeysInverse = toKeys
				.map(key => key.split(" ").reverse().join(" "));
			// hole keys are made from "from" indices, so each one can be
			// the start of a counter clockwise walk path
			const holeKeys = toKeys
				.filter((_, i) => !(toKeysInverse[i] in lookup.from));
			// console.log("holeKeys", holeKeys);
			if (holeKeys.length > 2) {
				console.warn("vertices_vertices found an unsolvable vertex");
				return [];
			}
			// the start keys will be either each hole key, or just pick a key
			// if no holes exist
			const startKeys = holeKeys.length
				? holeKeys
				: [toKeys[0]];
			// vertex_vertices is each vertex's vertices_vertices
			const vertex_vertices = [];
			// in the case of no holes, "visited" will indicate we finished.
			const visited = {};
			for (let s = 0; s < startKeys.length; s += 1) {
				const startKey = startKeys[s];
				const walk = [startKey];
				visited[startKey] = true;
				let isDone = false;
				do {
					const prev = walk[walk.length - 1];
					const faceIndex = lookup.to[prev];
					// this indicates the end of a walk which ended at a hole
					if (!(faceIndex in lookup.facesVerts)) { break; }
					let nextKey;
					if (lookup.facesVerts[faceIndex][0] === prev) {
						nextKey = lookup.facesVerts[faceIndex][1];
					}
					if (lookup.facesVerts[faceIndex][1] === prev) {
						nextKey = lookup.facesVerts[faceIndex][0];
					}
					if (nextKey === undefined) { return "not found"; }
					const nextKeyFlipped = nextKey.split(" ").reverse().join(" ");
					walk.push(nextKey);
					// this indicates the end of a walk which completed a cycle
					isDone = (nextKeyFlipped in visited);
					if (!isDone) { walk.push(nextKeyFlipped); }
					// update the visited dictionary
					visited[nextKey] = true;
					visited[nextKeyFlipped] = true;
				} while (!isDone);
				// walk now contains keys like "4 0", "1 4", "4 1", "2 4", "4 2",
				// mod 2 so that every edge is represented only once, which
				// still works with odd numbers since we start at a hole, and get the
				// one vertex which isn't our vertex. now we have our vertices_vertices
				const vertexKeys = walk
					.filter((_, i) => i % 2 === 0)
					.map(key => key.split(" ")[1])
					.map(str => parseInt(str, 10));
				vertex_vertices.push(...vertexKeys);
			}
			return vertex_vertices;
		});
	};
	/**
	 * @description Make `vertices_vertices` sorted radially counter-clockwise.
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, vertices_edges, edges_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are vertex indices.
	 * @linkcode Origami ./src/graph/make.js 245
	 */
	const makeVerticesVertices = (graph) => {
		if (!graph.vertices_coords || !graph.vertices_coords.length) { return []; }
		switch (graph.vertices_coords[0].length) {
		case 3:
			return makeVerticesVerticesFromFaces(graph);
		default:
			return makeVerticesVertices2D(graph);
		}
	};
	/**
	 *
	 */
	const makeVerticesVerticesUnsorted = ({ vertices_edges, edges_vertices }) => {
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		// use adjacent edges to find adjacent vertices
		return vertices_edges
			.map((edges, v) => edges
				// the adjacent edge's edges_vertices also contains this vertex,
				// filter it out and we're left with the adjacent vertices
				.flatMap(edge => edges_vertices[edge].filter(i => i !== v)));
	};
	/**
	 * @description Make `vertices_faces` **not sorted** counter-clockwise,
	 * which should be used sparingly. Prefer makeVerticesFaces().
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, faces_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are face indices.
	 * @linkcode Origami ./src/graph/make.js 276
	 */
	const makeVerticesFacesUnsorted = ({ vertices_coords, faces_vertices }) => {
		if (!faces_vertices) { return vertices_coords.map(() => []); }
		// instead of initializing the array ahead of time (we would need to know
		// the length of something like vertices_coords)
		const vertices_faces = vertices_coords !== undefined
			? vertices_coords.map(() => [])
			: Array.from(Array(countImplied.vertices({ faces_vertices }))).map(() => []);
		// iterate over every face, then iterate over each of the face's vertices
		faces_vertices.forEach((face, f) => {
			// in the case that one face visits the same vertex multiple times,
			// this hash acts as an intermediary, basically functioning like a set,
			// and only allow one occurence of each vertex index.
			const hash = [];
			face.forEach((vertex) => { hash[vertex] = f; });
			hash.forEach((fa, v) => vertices_faces[v].push(fa));
		});
		return vertices_faces;
	};
	/**
	 * @description Make `vertices_faces` sorted counter-clockwise.
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, vertices_vertices, faces_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds to a
	 * vertex index and the values in the inner array are face indices.
	 * @linkcode Origami ./src/graph/make.js 301
	 */
	const makeVerticesFaces = ({ vertices_coords, vertices_vertices, faces_vertices }) => {
		if (!faces_vertices) { return vertices_coords.map(() => []); }
		if (!vertices_vertices) {
			return makeVerticesFacesUnsorted({ vertices_coords, faces_vertices });
		}
		const face_map = makeVerticesToFace({ faces_vertices });
		return vertices_vertices
			.map((verts, v) => verts
				.map((vert, i, arr) => [arr[(i + 1) % arr.length], v, vert]
					.join(" ")))
			.map(keys => keys
				.map(key => face_map[key]));
		// .filter(a => a !== undefined) // removed. read below.
	};
	// the old version of this method contained a filter to remove "undefined".
	// because in the case of a boundary vertex of a closed polygon shape, there
	// is no face that winds backwards around the piece and encloses infinity.
	// unfortunately, this disconnects the index match with vertices_vertices.
	/**
	 * *not a geometry array*
	 *
	 * for fast backwards lookup of a edge by its vertices. this dictionary:
	 * keys are each edge's vertices as a string separated by a space: "9 3"
	 * value is the index of the edge.
	 * example: "9 3" and "3 9" are both entries with a value of the edge's index.
	 */
	/**
	 * @description Make an object which answers the question: "which edge connects
	 * these two vertices?". This is accomplished by building an object with keys
	 * containing vertex pairs (space separated string), and the value is the edge index.
	 * This is bidirectional, so "7 15" and "15 7" are both keys that point to the same edge.
	 * @param {FOLD} graph a FOLD object, containing edges_vertices
	 * @returns {object} space-separated vertex pair keys, edge indices values
	 * @linkcode Origami ./src/graph/make.js 336
	 */
	const makeVerticesToEdgeBidirectional = ({ edges_vertices }) => {
		const map = {};
		edges_vertices
			.map(ev => ev.join(" "))
			.forEach((key, i) => { map[key] = i; });
		edges_vertices
			.map(ev => `${ev[1]} ${ev[0]}`)
			.forEach((key, i) => { map[key] = i; });
		return map;
	};
	/**
	 * @description Make an object which answers the question: "which edge connects
	 * these two vertices?". This is accomplished by building an object with keys
	 * containing vertex pairs (space separated string), and the value is the edge index.
	 * This is not bidirectional, so "7 15" can exist while "15 7" does not. This is useful
	 * for example for looking up the edge's vector, which is direction specific.
	 * @param {FOLD} graph a FOLD object, containing edges_vertices
	 * @returns {object} space-separated vertex pair keys, edge indices values
	 * @linkcode Origami ./src/graph/make.js 356
	 */
	const makeVerticesToEdge = ({ edges_vertices }) => {
		const map = {};
		edges_vertices
			.map(ev => ev.join(" "))
			.forEach((key, i) => { map[key] = i; });
		return map;
	};
	/**
	 * @description Make an object which answers the question: "which face contains these
	 * 3 consecutive vertices? (3 vertices in sequential order, from two adjacent edges)"
	 * The keys are space-separated trios of vertex indices, 3 vertices which
	 * are found when walking a face. These 3 vertices uniquely point to one and only one
	 * face, and the counter-clockwise walk direction is respected, this is not
	 * bidirectional, and does not contain the opposite order of the same 3 vertices.
	 * @param {FOLD} graph a FOLD object, containing faces_vertices
	 * @returns {object} space-separated vertex trio keys, face indices values
	 * @linkcode Origami ./src/graph/make.js 374
	 */
	const makeVerticesToFace = ({ faces_vertices }) => {
		const map = {};
		faces_vertices
			.forEach((face, f) => face
				.map((_, i) => [0, 1, 2]
					.map(j => (i + j) % face.length)
					.map(n => face[n])
					.join(" "))
				.forEach(key => { map[key] = f; }));
		return map;
	};
	/**
	 * @description For every vertex, make an array of vectors that point towards each
	 * of the incident vertices. This is accomplised by taking the vertices_vertices
	 * array and converting it into vectors, indices will be aligned with vertices_vertices.
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, vertices_vertices, edges_vertices
	 * @returns {number[][][]} array of array of array of numbers, where each row corresponds
	 * to a vertex index, inner arrays correspond to vertices_vertices, and inside is a 2D vector
	 * @todo this can someday be rewritten without edges_vertices
	 * @linkcode Origami ./src/graph/make.js 395
	 */
	const makeVerticesVerticesVector = ({
		vertices_coords, vertices_vertices, edges_vertices, edges_vector,
	}) => {
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		const edge_map = makeVerticesToEdge({ edges_vertices });
		return vertices_vertices
			.map((_, a) => vertices_vertices[a]
				.map((b) => {
					const edge_a = edge_map[`${a} ${b}`];
					const edge_b = edge_map[`${b} ${a}`];
					if (edge_a !== undefined) { return edges_vector[edge_a]; }
					if (edge_b !== undefined) { return flip(edges_vector[edge_b]); }
				}));
	};
	/**
	 * @description Between pairs of counter-clockwise adjacent edges around a vertex
	 * is the sector measured in radians. This builds an array of of sector angles,
	 * index matched to vertices_vertices.
	 * @param {FOLD} graph a FOLD object, containing vertices_coords, vertices_vertices, edges_vertices
	 * @returns {number[][]} array of array of numbers, where each row corresponds
	 * to a vertex index, inner arrays contains angles in radians
	 * @linkcode Origami ./src/graph/make.js 420
	 */
	const makeVerticesSectors = ({
		vertices_coords, vertices_vertices, edges_vertices, edges_vector,
	}) => makeVerticesVerticesVector({
		vertices_coords, vertices_vertices, edges_vertices, edges_vector,
	})
		.map(vectors => (vectors.length === 1 // leaf node
			? [TWO_PI] // interior_angles gives 0 for leaf nodes. we want 2pi
			: counterClockwiseSectors2(vectors)));
	/**
	 *
	 *    EDGES
	 *
	 */
	/**
	 * @description Make `edges_edges` containing all vertex-adjacent edges.
	 * This will be radially sorted if you call makeVerticesEdges before calling this.
	 * @param {FOLD} graph a FOLD object, with entries edges_vertices, vertices_edges
	 * @returns {number[][]} each entry relates to an edge, each array contains indices
	 * of other edges.
	 * @linkcode Origami ./src/graph/make.js 441
	 */
	const makeEdgesEdges = ({ edges_vertices, vertices_edges }) =>
		edges_vertices.map((verts, i) => {
			const side0 = vertices_edges[verts[0]].filter(e => e !== i);
			const side1 = vertices_edges[verts[1]].filter(e => e !== i);
			return side0.concat(side1);
		});
	/**
	 * @description Make `edges_faces` where each edge is paired with its incident faces.
	 * This is unsorted, prefer makeEdgesFaces()
	 * @param {FOLD} graph a FOLD object, with entries edges_vertices, faces_edges
	 * @returns {number[][]} each entry relates to an edge, each array contains indices
	 * of adjacent faces.
	 * @linkcode Origami ./src/graph/make.js 455
	 */
	const makeEdgesFacesUnsorted = ({ edges_vertices, faces_edges }) => {
		// instead of initializing the array ahead of time (we would need to know
		// the length of something like edges_vertices)
		const edges_faces = edges_vertices !== undefined
			? edges_vertices.map(() => [])
			: Array.from(Array(countImplied.edges({ faces_edges }))).map(() => []);
		// todo: does not arrange counter-clockwise
		faces_edges.forEach((face, f) => {
			const hash = [];
			// in the case that one face visits the same edge multiple times,
			// this hash acts as a set allowing one occurence of each edge index.
			face.forEach((edge) => { hash[edge] = f; });
			hash.forEach((fa, e) => edges_faces[e].push(fa));
		});
		return edges_faces;
	};
	/**
	 * @description Make `edges_faces` where each edge is paired with its incident faces.
	 * This is sorted according to the FOLD spec, sorting faces on either side of an edge.
	 * @param {FOLD} graph a FOLD object, with entries vertices_coords,
	 * edges_vertices, faces_vertices, faces_edges
	 * @returns {number[][]} each entry relates to an edge, each array contains indices
	 * of adjacent faces.
	 * @linkcode Origami ./src/graph/make.js 480
	 */
	const makeEdgesFaces = ({
		vertices_coords, edges_vertices, edges_vector, faces_vertices, faces_edges, faces_center,
	}) => {
		if (!edges_vertices || (!faces_vertices && !faces_edges)) {
			// alert, we just made UNSORTED edges faces
			return makeEdgesFacesUnsorted({ faces_edges });
		}
		if (!faces_vertices) {
			faces_vertices = makeFacesVerticesFromEdges({ edges_vertices, faces_edges });
		}
		if (!faces_edges) {
			faces_edges = makeFacesEdgesFromVertices({ edges_vertices, faces_vertices });
		}
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		const edges_origin = edges_vertices.map(pair => vertices_coords[pair[0]]);
		if (!faces_center) {
			faces_center = makeFacesConvexCenter({ vertices_coords, faces_vertices });
		}
		const edges_faces = edges_vertices.map(() => []);
		faces_edges.forEach((face, f) => {
			const hash = [];
			// in the case that one face visits the same edge multiple times,
			// this hash acts as a set allowing one occurence of each edge index.
			face.forEach((edge) => { hash[edge] = f; });
			hash.forEach((fa, e) => edges_faces[e].push(fa));
		});
		// sort edges_faces in 2D based on which side of the edge's vector
		// each face lies, sorting the face on the left first. see FOLD spec.
		edges_faces.forEach((faces, e) => {
			const faces_cross = faces
				.map(f => faces_center[f])
				.map(center => subtract2(center, edges_origin[e]))
				.map(vector => cross2(vector, edges_vector[e]));
			faces.sort((a, b) => faces_cross[a] - faces_cross[b]);
		});
		return edges_faces;
	};

	const assignment_angles = {
		M: -180, m: -180, V: 180, v: 180,
	};
	/**
	 * @description Convert edges fold angle into assignment for every edge. This simple
	 * method will only result in "M" "V" and "F", depending on crease angle.
	 * "makeEdgesAssignment()" will also assign "B"
	 * @param {FOLD} graph a FOLD object, with edges_foldAngle
	 * @returns {string[]} array of fold assignments
	 * @linkcode Origami ./src/graph/make.js 531
	 */
	const makeEdgesAssignmentSimple = ({ edges_foldAngle }) => edges_foldAngle
		.map(a => {
			if (a === 0) { return "F"; }
			return a < 0 ? "M" : "V";
		});
	/**
	 * @description Convert edges fold angle into assignment for every edge. This method
	 * will assign "M" "V" "F" and "B" for edges with only one incident face.
	 * @param {FOLD} graph a FOLD object, with edges_foldAngle
	 * @returns {string[]} array of fold assignments
	 * @linkcode Origami ./src/graph/make.js 543
	 */
	const makeEdgesAssignment = ({
		edges_vertices, edges_foldAngle, edges_faces, faces_vertices, faces_edges,
	}) => {
		if (!edges_faces) {
			if (!faces_edges) {
				faces_edges = makeFacesEdgesFromVertices({ edges_vertices, faces_vertices });
			}
			edges_faces = makeEdgesFacesUnsorted({ edges_vertices, faces_edges });
		}
		return edges_foldAngle.map((a, i) => {
			if (edges_faces[i].length < 2) { return "B"; }
			if (a === 0) { return "F"; }
			return a < 0 ? "M" : "V";
		});
	};
	/**
	 * @description Convert edges assignment into fold angle in degrees for every edge.
	 * @param {FOLD} graph a FOLD object, with edges_assignment
	 * @returns {number[]} array of fold angles in degrees
	 * @linkcode Origami ./src/graph/make.js 564
	 */
	const makeEdgesFoldAngle = ({ edges_assignment }) => edges_assignment
		.map(a => assignment_angles[a] || 0);

	// angle between two 3D vectors
	// Î± = arccos[(xa * xb + ya * yb + za * zb) / (âˆš(xa2 + ya2 + za2) * âˆš(xb2 + yb2 + zb2))]
	// angle between two 2D vectors
	// Î± = arccos[(xa * xb + ya * yb) / (âˆš(xa2 + ya2) * âˆš(xb2 + yb2))]
	/**
	 * @description Inspecting adjacent faces, and referencing their normals, infer
	 * the foldAngle for every edge. This will result in a negative number for
	 * mountain creases, and positive for valley. This works well for 3D models,
	 * but will fail for flat-folded models, in which case, edges_assignment
	 * will be consulted to differentiate between 180 degree M or V folds.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} for every edge, an angle in degrees.
	 * @linkcode Origami ./src/graph/make.js 581
	 */
	const makeEdgesFoldAngleFromFaces = ({
		vertices_coords,
		edges_vertices,
		edges_faces,
		edges_assignment,
		faces_vertices,
		faces_edges,
		faces_normal,
		faces_center,
	}) => {
		if (!edges_faces) {
			if (!faces_edges) {
				faces_edges = makeFacesEdgesFromVertices({ edges_vertices, faces_vertices });
			}
			edges_faces = makeEdgesFacesUnsorted({ edges_vertices, faces_edges });
		}
		if (!faces_normal) {
			faces_normal = makeFacesNormal({ vertices_coords, faces_vertices });
		}
		if (!faces_center) {
			faces_center = makeFacesConvexCenter({ vertices_coords, faces_vertices });
		}
		// get the angle between two adjacent face normals, where parallel normals have 0 angle.
		// additionally, create a vector from one face's center to the other and check the sign of
		// the dot product with one of the normals, this clarifies if the fold is mountain or valley.
		return edges_faces.map((faces, e) => {
			if (faces.length > 2) { throw new Error(Messages$1.manifold); }
			if (faces.length < 2) { return 0; }
			const a = faces_normal[faces[0]];
			const b = faces_normal[faces[1]];
			const a2b = normalize(subtract(
				faces_center[faces[1]],
				faces_center[faces[0]],
			));
			// for mountain creases (faces facing away from each other), set the sign to negative.
			let sign = Math.sign(dot(a, a2b));
			// if the sign is zero, the faces are coplanar, it's impossible to tell if
			// this was because of a mountain or a valley fold.
			if (sign === 0) {
				if (edges_assignment && edges_assignment[e]) {
					if (edges_assignment[e] === "F" || edges_assignment[e] === "F") { sign = 0; }
					if (edges_assignment[e] === "M" || edges_assignment[e] === "m") { sign = -1; }
					if (edges_assignment[e] === "V" || edges_assignment[e] === "v") { sign = 1; }
				} else {
					throw new Error(Messages$1.flatFoldAngles);
				}
			}
			return (Math.acos(dot(a, b)) * (180 / Math.PI)) * sign;
		});
	};
	/**
	 * @description map vertices_coords onto edges_vertices so that the result
	 * is an edge array where each edge contains its two points. Each point being
	 * the 2D or 3D coordinate as an array of numbers.
	 * @param {FOLD} graph a FOLD graph with vertices and edges
	 * @returns {number[][][]} an array of array of points (which are arrays of numbers)
	 * @linkcode Origami ./src/graph/make.js 639
	 */
	const makeEdgesCoords = ({ vertices_coords, edges_vertices }) => edges_vertices
		.map(ev => ev.map(v => vertices_coords[v]));
	/**
	 * @description Turn every edge into a vector, basing the direction on the order of
	 * the pair of vertices in each edges_vertices entry.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, edges_vertices
	 * @returns {number[][]} each entry relates to an edge, each array contains a 2D vector
	 * @linkcode Origami ./src/graph/make.js 648
	 */
	const makeEdgesVector = ({ vertices_coords, edges_vertices }) => makeEdgesCoords({
		vertices_coords, edges_vertices,
	}).map(verts => subtract(verts[1], verts[0]));
	/**
	 * @description For every edge, find the length between the edges pair of vertices.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, edges_vertices
	 * @returns {number[]} the distance between each edge's pair of vertices
	 * @linkcode Origami ./src/graph/make.js 657
	 */
	const makeEdgesLength = ({ vertices_coords, edges_vertices }) => makeEdgesVector({
		vertices_coords, edges_vertices,
	}).map(vec => magnitude(vec));
	/**
	 * @description Make an array of axis-aligned bounding boxes, one for each edge,
	 * that encloses the edge, and will work in n-dimensions. Intended for
	 * fast line-sweep algorithms.
	 * @param {FOLD} graph a FOLD graph with vertices and edges.
	 * @returns {object[]} an array of boxes, length matching the number of edges
	 * @linkcode Origami ./src/graph/make.js 668
	 */
	const makeEdgesBoundingBox = ({
		vertices_coords, edges_vertices, edges_coords,
	}, epsilon = 0) => {
		if (!edges_coords) {
			edges_coords = makeEdgesCoords({ vertices_coords, edges_vertices });
		}
		return edges_coords.map(coords => boundingBox$1(coords, epsilon));
	};
	/**
	 *
	 *    FACES
	 *
	 */
	/**
	 * @description Rebuild all faces in a 2D planar graph by walking counter-clockwise
	 * down every edge (both ways). This does not include the outside face which winds
	 * around the boundary backwards enclosing the outside space.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {object[]} array of faces as objects containing "vertices" "edges" and "angles"
	 * @example
	 * // to convert the return object into faces_vertices and faces_edges
	 * var faces = makePlanarFaces(graph);
	 * faces_vertices = faces.map(el => el.vertices);
	 * faces_edges = faces.map(el => el.edges);
	 * @linkcode Origami ./src/graph/make.js 694
	 */
	const makePlanarFaces = ({
		vertices_coords, vertices_vertices, vertices_edges,
		vertices_sectors, edges_vertices, edges_vector,
	}) => {
		if (!vertices_vertices) {
			vertices_vertices = makeVerticesVertices({ vertices_coords, edges_vertices, vertices_edges });
		}
		if (!vertices_sectors) {
			vertices_sectors = makeVerticesSectors({
				vertices_coords, vertices_vertices, edges_vertices, edges_vector,
			});
		}
		const vertices_edges_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		// removes the one face that outlines the piece with opposite winding.
		// planarVertexWalk stores edges as vertex pair strings, "4 9",
		// convert these into edge indices
		const res = filterWalkedBoundaryFace(planarVertexWalk({
			vertices_vertices, vertices_sectors,
		})).map(f => ({ ...f, edges: f.edges.map(e => vertices_edges_map[e]) }));
		return {
			faces_vertices: res.map(el => el.vertices),
			faces_edges: res.map(el => el.edges),
			faces_sectors: res.map(el => el.angles),
		};
	};
	// export const makePlanarFacesVertices = graph => makePlanarFaces(graph)
	// 	.faces_vertices;

	// export const makePlanarFacesEdges = graph => makePlanarFaces(graph)
	// 	.faces_edges;

	// const make_vertex_pair_to_edge_map = function ({ edges_vertices }) {
	// 	if (!edges_vertices) { return {}; }
	// 	const map = {};
	// 	edges_vertices
	// 		.map(ev => ev.sort((a, b) => a - b).join(" "))
	// 		.forEach((key, i) => { map[key] = i; });
	// 	return map;
	// };
	// todo: this needs to be tested
	/**
	 * @description Make `faces_vertices` from `faces_edges`.
	 * @param {FOLD} graph a FOLD graph, with faces_edges, edges_vertices
	 * @returns {number[][]} a `faces_vertices` array
	 * @linkcode Origami ./src/graph/make.js 735
	 */
	const makeFacesVerticesFromEdges = ({ edges_vertices, faces_edges }) => faces_edges
		.map(edges => edges
			.map(edge => edges_vertices[edge])
			.map((pairs, i, arr) => {
				const next = arr[(i + 1) % arr.length];
				return (pairs[0] === next[0] || pairs[0] === next[1])
					? pairs[1]
					: pairs[0];
			}));
	/**
	 * @description Make `faces_edges` from `faces_vertices`.
	 * @param {FOLD} graph a FOLD graph, with
	 * edges_vertices and faces_vertices
	 * @returns {number[][]} a `faces_edges` array
	 * @linkcode Origami ./src/graph/make.js 751
	 */
	const makeFacesEdgesFromVertices = ({ edges_vertices, faces_vertices }) => {
		const map = makeVerticesToEdgeBidirectional({ edges_vertices });
		return faces_vertices
			.map(face => face
				.map((v, i, arr) => [v, arr[(i + 1) % arr.length]].join(" ")))
			.map(face => face.map(pair => map[pair]));
	};
	/**
	 * @description faces_faces is an array of edge-adjacent face indices for each face.
	 * @param {FOLD} graph a FOLD graph, with faces_vertices
	 * @returns {number[][]} each index relates to a face, each entry is an array
	 * of numbers, each number is an index of an edge-adjacent face to this face.
	 * @linkcode Origami ./src/graph/make.js 765
	 */
	const makeFacesFaces = ({ faces_vertices }) => {
		const faces_faces = faces_vertices.map(() => []);
		const edgeMap = {};
		faces_vertices
			.forEach((face, f) => face
				.forEach((v0, i, arr) => {
					let v1 = arr[(i + 1) % face.length];
					if (v1 < v0) { [v0, v1] = [v1, v0]; }
					const key = `${v0} ${v1}`;
					if (edgeMap[key] === undefined) { edgeMap[key] = {}; }
					edgeMap[key][f] = true;
				}));
		Object.values(edgeMap)
			.map(obj => Object.keys(obj))
			.filter(arr => arr.length > 1)
			.forEach(pair => {
				faces_faces[pair[0]].push(parseInt(pair[1], 10));
				faces_faces[pair[1]].push(parseInt(pair[0], 10));
			});
		return faces_faces;
	};
	// export const makeFacesFaces = ({ faces_vertices }) => {
	//   // if (!faces_vertices) { return undefined; }
	//   const faces_faces = faces_vertices.map(() => []);
	//   // create a map where each key is a string of the vertices of an edge,
	//   // like "3 4"
	//   // and each value is an array of faces adjacent to this edge.
	//   const edgeMap = {};
	//   faces_vertices.forEach((vertices_index, idx1) => {
	//     vertices_index.forEach((v1, i, vs) => {
	//       let v2 = vs[(i + 1) % vertices_index.length];
	//       if (v2 < v1) { [v1, v2] = [v2, v1]; }
	//       const key = `${v1} ${v2}`;
	//       if (key in edgeMap) {
	//         const idx2 = edgeMap[key];
	//         faces_faces[idx1].push(idx2);
	//         faces_faces[idx2].push(idx1);
	//       } else {
	//         edgeMap[key] = idx1;
	//       }
	//     });
	//   });
	//   return faces_faces;
	// };
	/**
	 * @description map vertices_coords onto each face's set of vertices,
	 * turning each face into an array of points, with an additional step:
	 * ensure that each polygon has 0 collinear vertices.
	 * this can result in a polygon with fewer vertices than is contained
	 * in that polygon's faces_vertices array.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][][]} array of array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 820
	 */
	const makeFacesPolygon = ({ vertices_coords, faces_vertices }, epsilon) => faces_vertices
		.map(verts => verts.map(v => vertices_coords[v]))
		.map(polygon => makePolygonNonCollinear(polygon, epsilon));
	/**
	 * @description map vertices_coords onto each face's set of vertices,
	 * turning each face into an array of points. "Quick" meaning collinear vertices are
	 * not removed, which in some cases, this will be the preferred method.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @returns {number[][][]} array of array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 831
	 */
	const makeFacesPolygonQuick = ({ vertices_coords, faces_vertices }) => faces_vertices
		.map(verts => verts.map(v => vertices_coords[v]));
	/**
	 * @description For every face, get the face's centroid.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @returns {number[][]} array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 839
	 */
	const makeFacesCenter2D = ({ vertices_coords, faces_vertices }) => faces_vertices
		.map(fv => fv.map(v => vertices_coords[v]))
		.map(coords => centroid(coords));
	/**
	 * @description This uses point average, not centroid, faces must
	 * be convex, and again it's not precise, but in many use cases
	 * this is often more than sufficient.
	 * @param {FOLD} graph a FOLD graph, with vertices_coords, faces_vertices
	 * @returns {number[][]} array of points, where each point is an array of numbers
	 * @linkcode Origami ./src/graph/make.js 850
	 */
	const makeFacesConvexCenter = ({ vertices_coords, faces_vertices }) => faces_vertices
		.map(vertices => vertices
			.map(v => vertices_coords[v])
			.reduce((a, b) => add(a, b), Array(vertices_coords[0].length).fill(0))
			.map(el => el / vertices.length));

	var make = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeEdgesAssignment: makeEdgesAssignment,
		makeEdgesAssignmentSimple: makeEdgesAssignmentSimple,
		makeEdgesBoundingBox: makeEdgesBoundingBox,
		makeEdgesCoords: makeEdgesCoords,
		makeEdgesEdges: makeEdgesEdges,
		makeEdgesFaces: makeEdgesFaces,
		makeEdgesFacesUnsorted: makeEdgesFacesUnsorted,
		makeEdgesFoldAngle: makeEdgesFoldAngle,
		makeEdgesFoldAngleFromFaces: makeEdgesFoldAngleFromFaces,
		makeEdgesLength: makeEdgesLength,
		makeEdgesVector: makeEdgesVector,
		makeFacesCenter2D: makeFacesCenter2D,
		makeFacesConvexCenter: makeFacesConvexCenter,
		makeFacesEdgesFromVertices: makeFacesEdgesFromVertices,
		makeFacesFaces: makeFacesFaces,
		makeFacesPolygon: makeFacesPolygon,
		makeFacesPolygonQuick: makeFacesPolygonQuick,
		makeFacesVerticesFromEdges: makeFacesVerticesFromEdges,
		makePlanarFaces: makePlanarFaces,
		makeVerticesEdges: makeVerticesEdges,
		makeVerticesEdgesUnsorted: makeVerticesEdgesUnsorted,
		makeVerticesFaces: makeVerticesFaces,
		makeVerticesFacesUnsorted: makeVerticesFacesUnsorted,
		makeVerticesSectors: makeVerticesSectors,
		makeVerticesToEdge: makeVerticesToEdge,
		makeVerticesToEdgeBidirectional: makeVerticesToEdgeBidirectional,
		makeVerticesToFace: makeVerticesToFace,
		makeVerticesVertices: makeVerticesVertices,
		makeVerticesVertices2D: makeVerticesVertices2D,
		makeVerticesVerticesFromFaces: makeVerticesVerticesFromFaces,
		makeVerticesVerticesUnsorted: makeVerticesVerticesUnsorted,
		makeVerticesVerticesVector: makeVerticesVerticesVector
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Get the indices of all duplicate edges by marking the
	 * second/third/... as duplicate (not the first of the duplicates).
	 * The result is given as an array with holes, where:
	 * - the indices are the indices of the duplicate edges.
	 * - the values are the indices of the first occurence of the duplicate.
	 * Under this system, many edges can be duplicates of the same edge.
	 * Order is not important. [5,9] and [9,5] are still duplicate.
	 * @param {FOLD} graph a FOLD object
	 * @returns {number[]} an array where the redundant edges are the indices,
	 * and the values are the indices of the first occurence of the duplicate.
	 * @example
	 * {number[]} array, [4:3, 7:5, 8:3, 12:3, 14:9] where indices
	 * (3, 4, 8, 12) are all duplicates. (5,7), (9,14) are also duplicates.
	 * @linkcode Origami ./src/graph/edgesViolations.js 47
	 */
	const duplicateEdges = ({ edges_vertices }) => {
		if (!edges_vertices) { return []; }
		const duplicates = [];
		const map = {};
		for (let i = 0; i < edges_vertices.length; i += 1) {
			// we need to store both, but only need to test one
			const a = `${edges_vertices[i][0]} ${edges_vertices[i][1]}`;
			const b = `${edges_vertices[i][1]} ${edges_vertices[i][0]}`;
			if (map[a] !== undefined) { // instead of (map[a] || map[b])
				duplicates[i] = map[a];
			} else {
				// only update the map. if an edge exists as two vertices, it will only
				// be set once, this prevents chains of duplicate relationships where
				// A points to B points to C points to D...
				map[a] = i;
				map[b] = i;
			}
		}
		return duplicates;
	};
	/**
	 * @description Find and remove all duplicate edges from a graph.
	 * If an edge is removed, it will mess up the vertices data (vertices_vertices,
	 * vertices_edges, vertices_faces) so if this method successfully found and
	 * removed a duplicate edge, the vertices arrays will be rebuilt as well.
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} [replace_indices=undefined] Leave this empty. Otherwise, if
	 * duplicateEdges() has already been called, provide the result here to speed
	 * up the algorithm.
	 * @returns {object} a summary of changes
	 * @linkcode Origami ./src/graph/edgesViolations.js 129
	 */
	const removeDuplicateEdges = (graph, replace_indices) => {
		// index: edge to remove, value: the edge which should replace it.
		if (!replace_indices) {
			replace_indices = duplicateEdges(graph);
		}
		const removeObject = Object.keys(replace_indices).map(n => parseInt(n, 10));
		const map = replaceGeometryIndices(graph, _edges, replace_indices);
		// if edges were removed, we need to rebuild vertices_edges and then
		// vertices_vertices since that was built from vertices_edges, and then
		// vertices_faces since that was built from vertices_vertices.
		if (removeObject.length) {
			// currently we are rebuilding the entire arrays, if possible,
			// update these specific vertices directly:
			// const vertices = removeObject
			//   .map(edge => graph.edges_vertices[edge])
			//   .reduce((a, b) => a.concat(b), []);
			if (graph.vertices_edges || graph.vertices_vertices || graph.vertices_faces) {
				graph.vertices_edges = makeVerticesEdgesUnsorted(graph);
				graph.vertices_vertices = makeVerticesVertices(graph);
				graph.vertices_edges = makeVerticesEdges(graph);
				graph.vertices_faces = makeVerticesFaces(graph);
			}
		}
		return { map, remove: removeObject };
	};

	var edgesDuplicate = /*#__PURE__*/Object.freeze({
		__proto__: null,
		duplicateEdges: duplicateEdges,
		removeDuplicateEdges: removeDuplicateEdges
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Get the indices of all circular edges. Circular edges are
	 * edges where both of its edges_vertices is the same vertex.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} array of indices of circular edges. empty if none.
	 * @linkcode Origami ./src/graph/edgesViolations.js 21
	 */
	const circularEdges = ({ edges_vertices }) => {
		if (!edges_vertices) { return []; }
		const circular = [];
		for (let i = 0; i < edges_vertices.length; i += 1) {
			if (edges_vertices[i][0] === edges_vertices[i][1]) {
				circular.push(i);
			}
		}
		return circular;
	};
	/**
	 * @description Given a set of graph geometry (vertices/edges/faces) indices,
	 * get all the arrays which reference these geometries, (eg: end in _edges),
	 * and remove (splice) that entry from the array if it contains a remove value.
	 * @param {FOLD} graph a FOLD object
	 * @param {string} suffix a component intended as a suffix, like "vertices" for "edges_vertices"
	 * @example
	 * removing indices [4, 7] from "edges", then a faces_edges entry
	 * which was [15, 13, 4, 9, 2] will become [15, 13, 9, 2].
	 */
	const spliceRemoveValuesFromSuffixes = (graph, suffix, remove_indices) => {
		const remove_map = {};
		remove_indices.forEach(n => { remove_map[n] = true; });
		filterKeysWithSuffix(graph, suffix)
			.forEach(sKey => graph[sKey] // faces_edges or vertices_edges...
				.forEach((elem, i) => { // faces_edges[0], faces_edges[1], ...
					// reverse iterate through array, remove elements with splice
					for (let j = elem.length - 1; j >= 0; j -= 1) {
						if (remove_map[elem[j]] === true) {
							graph[sKey][i].splice(j, 1);
						}
					}
				}));
	};
	/**
	 * @description Find and remove all circular edges from a graph.
	 * @param {FOLD} graph a FOLD object
	 * @param {number[]} [remove_indices=undefined] Leave this empty. Otherwise, if
	 * circularEdges() has already been called, provide the result here to speed
	 * up the algorithm.
	 * @returns {object} a summary of changes
	 * @linkcode Origami ./src/graph/edgesViolations.js 100
	 */
	const removeCircularEdges = (graph, remove_indices) => {
		if (!remove_indices) {
			remove_indices = circularEdges(graph);
		}
		if (remove_indices.length) {
			// remove every instance of a circular edge in every _edge array.
			// assumption is we can simply remove them because a face that includes
			// a circular edge is still the same face when you just remove the edge
			spliceRemoveValuesFromSuffixes(graph, _edges, remove_indices);
			// console.warn("circular edge found. please rebuild");
			// todo: figure out which arrays need to be rebuilt, if it exists.
		}
		return {
			map: removeGeometryIndices(graph, _edges, remove_indices),
			remove: remove_indices,
		};
	};

	var edgesCircular = /*#__PURE__*/Object.freeze({
		__proto__: null,
		circularEdges: circularEdges,
		removeCircularEdges: removeCircularEdges
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Provide two or more simple nextmaps in the order they were made
	 * and this will merge them into one nextmap which reflects all changes to the graph.
	 * @param {...number[]} ...maps a sequence of simple nextmaps
	 * @returns {number[]} one nextmap reflecting the sum of changes
	 * @linkcode Origami ./src/graph/maps.js 10
	 */
	const mergeSimpleNextmaps = (...maps) => {
		if (maps.length === 0) { return []; }
		const solution = maps[0].map((_, i) => i);
		maps.forEach(map => solution.forEach((s, i) => { solution[i] = map[s]; }));
		return solution;
	};
	/**
	 * @description Provide two or more nextmaps in the order they were made
	 * and this will merge them into one nextmap which reflects all changes to the graph.
	 * @param {...number[][]} ...maps a sequence of nextmaps
	 * @returns {number[][]} one nextmap reflecting the sum of changes
	 * @linkcode Origami ./src/graph/maps.js 23
	 */
	const mergeNextmaps = (...maps) => {
		if (maps.length === 0) { return []; }
		const solution = maps[0].map((_, i) => [i]);
		maps.forEach(map => {
			solution.forEach((s, i) => s.forEach((indx, j) => { solution[i][j] = map[indx]; }));
			solution.forEach((arr, i) => {
				solution[i] = arr
					.reduce((a, b) => a.concat(b), [])
					.filter(a => a !== undefined);
			});
		});
		return solution;
	};
	/**
	 * @description Provide two or more simple backmaps in the order they were made
	 * and this will merge them into one backmap which reflects all changes to the graph.
	 * @param {...number[]} ...maps a sequence of simplebackmaps
	 * @returns {number[]} one backmap reflecting the sum of changes
	 * @linkcode Origami ./src/graph/maps.js 43
	 */
	const mergeSimpleBackmaps = (...maps) => {
		if (maps.length === 0) { return []; }
		let solution = maps[0].map((_, i) => i);
		maps.forEach(map => {
			const next = map.map(n => solution[n]);
			solution = next;
		});
		return solution;
	};
	/**
	 * @description Provide two or more  backmaps in the order they were made
	 * and this will merge them into one backmap which reflects all changes to the graph.
	 * @param {...number[][]} ...maps a sequence of backmaps
	 * @returns {number[][]} one backmap reflecting the sum of changes
	 * @linkcode Origami ./src/graph/maps.js 59
	 */
	const mergeBackmaps = (...maps) => {
		if (maps.length === 0) { return []; }
		let solution = maps[0].reduce((a, b) => a.concat(b), []).map((_, i) => [i]);
		maps.forEach(map => {
			const next = [];
			map.forEach((el, j) => {
				if (typeof el === _number) {
					next[j] = solution[el];
				} else {
					next[j] = el.map(n => solution[n]).reduce((a, b) => a.concat(b), []);
				}
			});
			solution = next;
		});
		return solution;
	};
	/**
	 * @description invert an array of integers so that indices become values and
	 * values become indices. in the case of multiple values trying to insert
	 * into the same index, a child array is made to house both (or more) numbers.
	 * @param {number[]|number[][]} map an array of integers
	 * @returns {number[]|number[][]} the inverted map
	 * @linkcode Origami ./src/graph/maps.js 83
	 */
	const invertMap = (map) => {
		const inv = [];
		// set inv[index] = value, but before we do, make sure that an array
		// will be formed if there are multiple values at that index
		const setIndexValue = (index, value) => {
			// before we set the inverted map [i] spot, check if something is already there
			if (inv[index] !== undefined) {
				// if that thing is a number, turn it into an array
				if (typeof inv[index] === _number) {
					inv[index] = [inv[index], value];
				} else {
					// already an array, add to it
					inv[index].push(value);
				}
			} else {
				inv[index] = value;
			}
		};
		// iterate through the argument array and flip the index/value
		// in the new array so that the index is the value and visa versa.
		map.forEach((n, i) => {
			if (n == null) { return; }
			if (typeof n === _number) { setIndexValue(n, i); }
			if (n.constructor === Array) {
				n.forEach(m => setIndexValue(m, i));
			}
		});
		return inv;
	};
	/**
	 * @description invert an array of integers so that indices become values
	 * and values become indices. duplicate entries will be overwritten.
	 * @param {number[]} map an array of integers
	 * @returns {number[]} the inverted map
	 * @linkcode Origami ./src/graph/maps.js 119
	 */
	const invertSimpleMap = (map) => {
		const inv = [];
		map.forEach((n, i) => { inv[n] = i; });
		return inv;
	};

	var maps = /*#__PURE__*/Object.freeze({
		__proto__: null,
		invertMap: invertMap,
		invertSimpleMap: invertSimpleMap,
		mergeBackmaps: mergeBackmaps,
		mergeNextmaps: mergeNextmaps,
		mergeSimpleBackmaps: mergeSimpleBackmaps,
		mergeSimpleNextmaps: mergeSimpleNextmaps
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description clean will remove bad graph data. this includes:
	 * - duplicate (Euclidean distance) and isolated vertices
	 * - circular and duplicate edges.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} summary of changes, a nextmap and the indices removed.
	 * @linkcode Origami ./src/graph/clean.js 24
	 */
	const clean = (graph, epsilon) => {
		// duplicate vertices has to be done first as it's possible that
		// this will create circular/duplicate edges.
		const change_v1 = removeDuplicateVertices(graph, epsilon);
		const change_e1 = removeCircularEdges(graph);
		const change_e2 = removeDuplicateEdges(graph);
		// isolated vertices is last. removing edges can create isolated vertices
		const change_v2 = removeIsolatedVertices(graph);
		// todo: it's possible that an edges_vertices now contains undefineds,
		// like [4, undefined]. but this should not be happening

		// return a summary of changes.
		// use the maps to update the removed indices from the second step
		// to their previous index before change 1 occurred.
		const change_v1_backmap = invertSimpleMap(change_v1.map);
		const change_v2_remove = change_v2.remove.map(e => change_v1_backmap[e]);
		const change_e1_backmap = invertSimpleMap(change_e1.map);
		const change_e2_remove = change_e2.remove.map(e => change_e1_backmap[e]);
		return {
			vertices: {
				map: mergeSimpleNextmaps(change_v1.map, change_v2.map),
				remove: change_v1.remove.concat(change_v2_remove),
			},
			edges: {
				map: mergeSimpleNextmaps(change_e1.map, change_e2.map),
				remove: change_e1.remove.concat(change_e2_remove),
			},
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description deep copy an object, like JSON.parse(JSON.stringify())
	 *
	 * this clone function is decent, except for:
	 *  - it doesn't detect recursive cycles
	 *  - weird behavior around Proxys
	 * @author https://jsperf.com/deep-copy-vs-json-stringify-json-parse/5
	 * @param {object} o
	 * @returns {object} a deep copy of the input
	 * @linkcode Origami ./src/general/clone.js 14
	 */
	const clone = function (o) {
		let newO;
		let i;
		if (typeof o !== _object) {
			return o;
		}
		if (!o) {
			return o;
		}
		if (Object.prototype.toString.apply(o) === "[object Array]") {
			newO = [];
			for (i = 0; i < o.length; i += 1) {
				newO[i] = clone(o[i]);
			}
			return newO;
		}
		newO = {};
		for (i in o) {
			if (o.hasOwnProperty(i)) {
				// this is where a self-similar reference causes an infinite loop
				newO[i] = clone(o[i]);
			}
		}
		return newO;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Create a modified graph which separates all faces from each other.
	 * This will add new vertices and new edges. Most adjacency arrays will be
	 * deleted as a lot of it becomes trivial. However, edges_assignment and foldAngle
	 * will remain and be correctly updated to match the new edge indices.
	 * @param {FOLD} graph a FOLD graph, will be modified in place
	 * @returns {object} a summary of changes to the vertices and edges
	 * @linkcode Origami ./src/graph/explodeFaces.js 29
	 */
	const explode = (graph) => {
		// make sure we have faces_vertices (required) and faces_edges (can be built)
		if (!graph.faces_vertices) { return {}; }
		const faces_edges = graph.faces_edges
			? graph.faces_edges
			: makeFacesEdgesFromVertices(graph);
		// every new element's location in the old elements_ arrays.
		const verticesMap = graph.faces_vertices.flatMap(vertices => vertices);
		const edgesMap = faces_edges.flatMap(edges => edges);
		// build new data
		let fv = 0;
		let fe = 0;
		let ev = 0;
		graph.faces_vertices = graph.faces_vertices.map(face => face.map(() => fv++));
		graph.faces_edges = graph.faces_edges.map(face => face.map(() => fe++));
		// use faces_edges (or vertices) to build a loop, where new edges are made to
		// connect new vertices, but when a face is done connect back to its first vertex.
		graph.edges_vertices = graph.faces_edges
			.flatMap(face => face.map((_, i, arr) => {
				const edge_vertices = i === arr.length - 1
					? [ev, (ev + 1 - arr.length)]
					: [ev, (ev + 1)];
				ev += 1;
				return edge_vertices;
			}));
		if (graph.vertices_coords) {
			graph.vertices_coords = clone(verticesMap.map(i => graph.vertices_coords[i]));
		}
		if (graph.edges_assignment) {
			graph.edges_assignment = clone(edgesMap.map(i => graph.edges_assignment[i]));
		}
		if (graph.edges_foldAngle) {
			graph.edges_foldAngle = clone(edgesMap.map(i => graph.edges_foldAngle[i]));
		}
		if (graph.vertices_vertices) { delete graph.vertices_vertices; }
		if (graph.vertices_edges) { delete graph.vertices_edges; }
		if (graph.vertices_faces) { delete graph.vertices_faces; }
		if (graph.edges_edges) { delete graph.edges_edges; }
		if (graph.edges_faces) { delete graph.edges_faces; }
		if (graph.faces_faces) { delete graph.faces_faces; }
		return {
			vertices: { map: verticesMap },
			edges: { map: edgesMap },
		};
	};
	/**
	 * @description Create a modified graph which contains vertices_coords and faces_vertices
	 * but that for every face, vertices_coords has been duplicated so that faces
	 * do not share vertices.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {FOLD} a new FOLD graph with exploded faces
	 * @linkcode Origami ./src/graph/explodeFaces.js 82
	 */
	const explodeFaces = (graph) => {
		const vertices_coords = graph.faces_vertices
			.flatMap(face => face
				.map(v => graph.vertices_coords[v]));
		let i = 0;
		const faces_vertices = graph.faces_vertices
			.map(face => face.map(() => i++));
		// duplicate vertices are simply duplicate references, changing
		// one will still change the others. we need to deep copy the array
		return {
			vertices_coords: JSON.parse(JSON.stringify(vertices_coords)),
			faces_vertices,
		};
	};
	/**
	 * @description Create a modified graph which contains vertices_coords and edges_vertices
	 * but that for every edge, vertices_coords has been duplicated so that edges
	 * do not share vertices.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {FOLD} a new FOLD graph with exploded edges
	 * @linkcode Origami ./src/graph/explodeFaces.js 82
	 */
	const explodeEdges = (graph) => {
		const vertices_coords = graph.edges_vertices
			.flatMap(edge => edge
				.map(v => graph.vertices_coords[v]));
		let i = 0;
		const edges_vertices = graph.edges_vertices
			.map(edge => edge.map(() => i++));
		// duplicate vertices are simply duplicate references, changing
		// one will still change the others. we need to deep copy the array
		return {
			vertices_coords: JSON.parse(JSON.stringify(vertices_coords)),
			edges_vertices,
		};
	};

	var explodeMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		explode: explode,
		explodeEdges: explodeEdges,
		explodeFaces: explodeFaces
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description find the one point in an array of 2D points closest to a 2D point.
	 * @param {number[][]} array_of_points an array of 2D points to test against
	 * @param {number[]} point the 2D point to test nearness to
	 * @returns {number[]} one point from the array of points
	 * @linkcode Math ./src/geometry/nearest.js 26
	 */
	const nearestPoint2 = (array_of_points, point) => {
		// todo speed up with partitioning
		const index = smallestComparisonSearch(array_of_points, point, distance2);
		return index === undefined ? undefined : array_of_points[index];
	};
	/**
	 * @description find the one point in an array of points closest to a point.
	 * @param {number[][]} array_of_points an array of points to test against
	 * @param {number[]} point the point to test nearness to
	 * @returns {number[]} one point from the array of points
	 * @linkcode Math ./src/geometry/nearest.js 38
	 */
	const nearestPoint = (array_of_points, point) => {
		// todo speed up with partitioning
		const index = smallestComparisonSearch(array_of_points, point, distance);
		return index === undefined ? undefined : array_of_points[index];
	};
	/**
	 * @description find the nearest point on a line, ray, or segment.
	 * @param {number[]} vector the vector of the line
	 * @param {number[]} origin a point that the line passes through
	 * @param {number[]} point the point to test nearness to
	 * @param {function} limiterFunc a clamp function to bound a calculation between 0 and 1
	 * for segments, greater than 0 for rays, or unbounded for lines.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[]} a point
	 * @linkcode Math ./src/geometry/nearest.js 54
	 */
	const nearestPointOnLine = (
		{ vector, origin },
		point,
		clampFunc = clampLine,
		epsilon = EPSILON,
	) => {
		origin = resize(vector.length, origin);
		point = resize(vector.length, point);
		const magSq = magSquared(vector);
		const vectorToPoint = subtract(point, origin);
		const dotProd = dot(vector, vectorToPoint);
		const dist = dotProd / magSq;
		// clamp depending on line, ray, segment
		const d = clampFunc(dist, epsilon);
		return add(origin, scale$1(vector, d));
	};
	/**
	 * @description given a polygon and a point, in 2D, find a point on the boundary of the polygon
	 * that is closest to the provided point.
	 * @param {number[][]} polygon an array of points (which are arrays of numbers)
	 * @param {number[]} point the point to test nearness to
	 * @returns {number[]} a point
	 * edge index matches vertices such that edge(N) = [vert(N), vert(N + 1)]
	 * @linkcode Math ./src/geometry/nearest.js 79
	 */
	const nearestPointOnPolygon = (polygon, point) => polygon
		.map((p, i, arr) => subtract(arr[(i + 1) % arr.length], p))
		.map((vector, i) => ({ vector, origin: polygon[i] }))
		.map(line => nearestPointOnLine(line, point, clampSegment))
		.map((p, edge) => ({ point: p, edge, distance: distance(p, point) }))
		.sort((a, b) => a.distance - b.distance)
		.shift();
	/**
	 * @description find the nearest point on the boundary of a circle to another point
	 * that is closest to the provided point.
	 * @param {Circle} circle object with "radius" (number) and "origin" (number[])
	 * @param {number[]} origin the origin of the circle as an array of numbers.
	 * @param {number[]} point the point to test nearness to
	 * @returns {number[]} a point
	 * @linkcode Math ./src/geometry/nearest.js 95
	 */
	const nearestPointOnCircle = ({ radius, origin }, point) => (
		add(origin, scale$1(normalize(subtract(point, origin)), radius))
	);

	var nearest$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		nearestPoint: nearestPoint,
		nearestPoint2: nearestPoint2,
		nearestPointOnCircle: nearestPointOnCircle,
		nearestPointOnLine: nearestPointOnLine,
		nearestPointOnPolygon: nearestPointOnPolygon
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description check if a point lies collinear along a line,
	 * and specify if the line is a line/ray/segment and test whether
	 * the point lies within endpoint(s).
	 * @param {VecLine} line a line in "vector" "origin" form
	 * @param {number[]} point one 2D point
	 * @parma {function} [lineDomain=includeL] the domain of the line
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} is the point collinear to the line,
	 * and in the case of ray/segment,
	 * does the point lie within the bounds of the ray/segment?
	 * @linkcode Math ./src/intersect/overlap.js 30
	 */
	const overlapLinePoint = (
		{ vector, origin },
		point,
		lineDomain = includeL,
		epsilon = EPSILON,
	) => {
		const p2p = subtract2(point, origin);
		const lineMagSq = magSquared(vector);
		const lineMag = Math.sqrt(lineMagSq);
		// the line is degenerate
		if (lineMag < epsilon) { return false; }
		const cross = cross2(p2p, vector.map(n => n / lineMag));
		const proj = dot2(p2p, vector) / lineMagSq;
		return Math.abs(cross) < epsilon && lineDomain(proj, epsilon / lineMag);
	};
	/**
	 * @description Test if two lines overlap each other, generalized
	 * and works for lines, rays, and segments.
	 * @param {VecLine} a a line in "vector" "origin" form
	 * @param {VecLine} b a line in "vector" "origin" form
	 * @param {function} aFn the domain of the first line parameter
	 * @param {function} bFn the domain of the second line parameter
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersect/overlap.js 55
	*/
	const overlapLineLine = (
		a,
		b,
		aDomain = includeL,
		bDomain = includeL,
		epsilon = EPSILON,
	) => {
		const denominator0 = cross2(a.vector, b.vector);
		const denominator1 = -denominator0;
		const a2b = subtract2(b.origin, a.origin);
		const b2a = [-a2b[0], -a2b[1]];
		if (Math.abs(denominator0) < epsilon) { // parallel
			if (Math.abs(cross2(a2b, a.vector)) > epsilon) { return false; }
			// project each line's two endpoints onto the vector of the other line.
			const aPt1 = b2a;
			const aPt2 = add2(aPt1, a.vector);
			const bPt1 = a2b;
			const bPt2 = add2(bPt1, b.vector);
			const aProjLen = dot2(a.vector, a.vector);
			const bProjLen = dot2(a.vector, a.vector);
			// these will be between 0 and 1 if the two segments overlap
			const aProj1 = dot2(aPt1, b.vector) / bProjLen;
			const aProj2 = dot2(aPt2, b.vector) / bProjLen;
			const bProj1 = dot2(bPt1, a.vector) / aProjLen;
			const bProj2 = dot2(bPt2, a.vector) / aProjLen;
			// use the supplied function parameters to allow line/ray/segment
			// clamping and check if either point from either line is inside
			// the other line's vector, and if the function (l/r/s) allows it
			return aDomain(bProj1, epsilon) || aDomain(bProj2, epsilon)
				|| bDomain(aProj1, epsilon) || bDomain(aProj2, epsilon);
		}
		const t0 = cross2(a2b, b.vector) / denominator0;
		const t1 = cross2(b2a, a.vector) / denominator1;
		return aDomain(t0, epsilon / magnitude2(a.vector))
			&& bDomain(t1, epsilon / magnitude2(b.vector));
	};
	/**
	 * @description Test if a point lies inside of a circle.
	 * @param {Circle} circle a circle in radius origin form
	 * @param {number[]} point a point in array form
	 * @param {function} fn is the circle's boundary inclusive or exclusive
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersect/overlap.js 99
	*/
	const overlapCirclePoint = (
		{ radius, origin },
		point,
		circleDomain = exclude,
		epsilon = EPSILON,
	) => (
		circleDomain(radius - distance2(origin, point), epsilon)
	);
	/**
	 * @description tests if a point is inside a convex polygon. Polygon is
	 * expected to be counter-clockwise winding.
	 * @param {number[][]} polygon a polygon in array of array form
	 * @param {number[]} point a point in array form
	 * @param {function} polyDomain determines if the polygon boundary
	 * is inclusive or exclusive
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} is the point inside the polygon?
	 * @linkcode Math ./src/intersect/overlap.js 117
	 */
	const overlapConvexPolygonPoint = (
		polygon,
		point,
		polyDomain = exclude,
		epsilon = EPSILON,
	) => polygon
		.map((p, i, arr) => [p, arr[(i + 1) % arr.length]])
		.map(s => cross2(normalize2(subtract2(s[1], s[0])), subtract2(point, s[0])))
		.map(side => polyDomain(side, epsilon))
		.map((s, _, arr) => s === arr[0])
		.reduce((prev, curr) => prev && curr, true);
	/**
	 * @description Find out if two convex polygons are overlapping by searching
	 * for a dividing axis, which should be one side from one of the polygons.
	 * @param {number[][]} poly1 a polygon as an array of points
	 * @param {number[][]} poly2 a polygon as an array of points
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersect/overlap.js 136
	 */
	const overlapConvexPolygons = (poly1, poly2, epsilon = EPSILON) => {
		for (let p = 0; p < 2; p += 1) {
			// for non-overlapping convex polygons, it's possible that only only
			// one edge on one polygon holds the property of being a dividing axis.
			// we must run the algorithm on both polygons
			const polyA = p === 0 ? poly1 : poly2;
			const polyB = p === 0 ? poly2 : poly1;
			for (let i = 0; i < polyA.length; i += 1) {
				// each edge of polygonA will become a line
				const origin = polyA[i];
				const vector = rotate90(subtract2(polyA[(i + 1) % polyA.length], polyA[i]));
				// project each point from the other polygon on to the line's perpendicular
				// also, subtracting the origin (from the first poly) such that the
				// numberline is centered around zero. if the test passes, this polygon's
				// projections will be entirely above or below 0.
				const projected = polyB
					.map(point => subtract2(point, origin))
					.map(v => dot2(vector, v));
				// is the first polygon on the positive or negative side?
				const other_test_point = polyA[(i + 2) % polyA.length];
				const side_a = dot2(vector, subtract2(other_test_point, origin));
				const side = side_a > 0; // use 0. not epsilon
				// is the second polygon on whichever side of 0 that the first isn't?
				const one_sided = projected
					.map(dotProd => (side ? dotProd < epsilon : dotProd > -epsilon))
					.reduce((a, b) => a && b, true);
				// if true, we found a dividing axis
				if (one_sided) { return false; }
			}
		}
		return true;
	};
	/**
	 * @description Test if two axis-aligned bounding boxes overlap each other.
	 * @param {Box} box1 an axis-aligned bounding box
	 * @param {Box} box2 an axis-aligned bounding box
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} true if the bounding boxes overlap each other
	 * @linkcode Math ./src/intersect/overlap.js 176
	 */
	const overlapBoundingBoxes = (box1, box2, epsilon = EPSILON) => {
		const dimensions = Math.min(box1.min.length, box2.min.length);
		for (let d = 0; d < dimensions; d += 1) {
			// if one minimum is above the other's maximum, or visa versa
			if (box1.min[d] > box2.max[d] + epsilon
				|| box1.max[d] < box2.min[d] - epsilon) {
				return false;
			}
		}
		return true;
	};

	var overlap = /*#__PURE__*/Object.freeze({
		__proto__: null,
		overlapBoundingBoxes: overlapBoundingBoxes,
		overlapCirclePoint: overlapCirclePoint,
		overlapConvexPolygonPoint: overlapConvexPolygonPoint,
		overlapConvexPolygons: overlapConvexPolygons,
		overlapLineLine: overlapLineLine,
		overlapLinePoint: overlapLinePoint
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Iterate through all vertices in a graph and find the one nearest to a
	 * provided point. This is the only of the "nearest" graph operations that works in 3D.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the nearest vertex
	 * @returns {number} the index of the nearest vertex
	 * @todo improve with space partitioning
	 * @linkcode Origami ./src/graph/nearest.js 26
	 */
	const nearestVertex = ({ vertices_coords }, point) => {
		if (!vertices_coords) { return undefined; }
		// resize our point to be the same dimension as the first vertex
		const p = resize(vertices_coords[0].length, point);
		// sort by distance, hold onto the original index in vertices_coords
		const nearest = vertices_coords
			.map((v, i) => ({ d: distance(p, v), i }))
			.sort((a, b) => a.d - b.d)
			.shift();
		// return index, not vertex
		return nearest ? nearest.i : undefined;
	};
	/**
	 * @description Iterate through all edges in a graph and find the one nearest to a provided point.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the nearest edge
	 * @returns {number|undefined} the index of the nearest edge, or undefined
	 * if there are no vertices_coords or edges_vertices
	 * @linkcode Origami ./src/graph/nearest.js 46
	 */
	const nearestEdge = ({ vertices_coords, edges_vertices }, point) => {
		if (!vertices_coords || !edges_vertices) { return undefined; }
		const nearest_points = edges_vertices
			.map(e => e.map(ev => vertices_coords[ev]))
			.map(e => nearestPointOnLine(
				{ vector: subtract(e[1], e[0]), origin: e[0] },
				point,
				clampSegment,
			));
		return smallestComparisonSearch(nearest_points, point, distance);
	};
	/**
	 * @description Iterate through all faces in a graph and find one that encloses a point.
	 * This method assumes the graph is in 2D, it ignores any z components.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the enclosing face
	 * @returns {number|undefined} the index of the face, or undefined if no face encloses a point
	 * @linkcode Origami ./src/graph/nearest.js 65
	 */
	const faceContainingPoint = ({ vertices_coords, faces_vertices }, point) => {
		if (!vertices_coords || !faces_vertices) { return undefined; }
		const face = faces_vertices
			.map((fv, i) => ({ face: fv.map(v => vertices_coords[v]), i }))
			.filter(f => overlapConvexPolygonPoint(f.face, point))
			.shift();
		return (face === undefined ? undefined : face.i);
	};
	/**
	 * @description Iterate through all faces in a graph and find one nearest to a point.
	 * This method assumes the graph is in 2D, it ignores any z components.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the nearest face
	 * @returns {number|undefined} the index of the face, or undefined if edges_faces is not defined.
	 * @todo make this work if edges_faces is not defined (not hard)
	 * @linkcode Origami ./src/graph/nearest.js 82
	 */
	const nearestFace = (graph, point) => {
		const face = faceContainingPoint(graph, point);
		if (face !== undefined) { return face; }
		if (graph.edges_faces) {
			const edge = nearestEdge(graph, point);
			const faces = graph.edges_faces[edge];
			if (faces.length === 1) { return faces[0]; }
			if (faces.length > 1) {
				const faces_center = makeFacesConvexCenter({
					vertices_coords: graph.vertices_coords,
					faces_vertices: faces.map(f => graph.faces_vertices[f]),
				});
				const distances = faces_center
					.map(center => distance(center, point));
				let shortest = 0;
				for (let i = 0; i < distances.length; i += 1) {
					if (distances[i] < distances[shortest]) { shortest = i; }
				}
				return faces[shortest];
			}
		}
		return undefined;
	};
	/**
	 * @description Return an object which contains information regarding
	 * vertices, edges, and faces, which indices are closest to the provided point.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} point the point to find the nearest face
	 * @returns {object} object which contains information about the nearest components,
	 * some of which is stored in a getter, which delays the computation until called.
	 * @linkcode Origami ./src/graph/nearest.js 114
	 */
	const nearest = (graph, ...args) => {
		const nearestMethods = {
			vertices: nearestVertex,
			edges: nearestEdge,
			faces: nearestFace,
		};
		const point = getVector(...args);
		const nears = Object.create(null);
		["vertices", "edges", "faces"].forEach(key => {
			Object.defineProperty(nears, singularize[key], {
				enumerable: true,
				get: () => nearestMethods[key](graph, point),
			});
			filterKeysWithPrefix(graph, key)
				.forEach(fold_key => Object.defineProperty(nears, fold_key, {
					enumerable: true,
					get: () => graph[fold_key][nears[singularize[key]]],
				}));
		});
		return nears;
	};
	/**
	 * @todo this needs testing: does the cache cause a memory leak after many repeated calls?
	 */
	// export const nearest = (graph, ...args) => {
	// 	const nearestMethods = {
	// 		vertices: nearestVertex,
	// 		edges: nearestEdge,
	// 		faces: nearestFace,
	// 	};
	// 	const point = getVector(...args);
	// 	const nears = Object.create(null);
	// 	const cache = {};
	// 	["vertices", "edges", "faces"].forEach(key => {
	// 		Object.defineProperty(nears, singularize[key], {
	// 			enumerable: true,
	// 			get: () => {
	// 				if (cache[key] !== undefined) { return cache[key]; }
	// 				cache[key] = nearestMethods[key](graph, point);
	// 				return cache[key];
	// 			},
	// 		});
	// 		filterKeysWithPrefix(graph, key)
	// 			.forEach(fold_key => Object.defineProperty(nears, fold_key, {
	// 				enumerable: true,
	// 				get: () => graph[fold_key][nears[singularize[key]]],
	// 			}));
	// 	});
	// 	return nears;
	// };

	var nearestMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		faceContainingPoint: faceContainingPoint,
		nearest: nearest,
		nearestEdge: nearestEdge,
		nearestFace: nearestFace,
		nearestVertex: nearestVertex
	});

	/**
	 *
	 */
	const edgeifyFaces = ({ vertices_coords, faces_vertices }, axis = 0) => faces_vertices
		.map(vertices => [
			vertices
				.reduce((a, b) => (vertices_coords[a][axis] < vertices_coords[b][axis] ? a : b)),
			vertices
				.reduce((a, b) => (vertices_coords[a][axis] > vertices_coords[b][axis] ? a : b)),
		]);
	/**
	 * @description Perform a line sweep through the vertices of a graph,
	 * the default direction is to sweep along the +X axis.
	 * This method will sort the vertices along the sweep direction and
	 * group those which have a similar value within an epsilon.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [axis=0] which axis to sweep along
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} an array of event objects, each event contains:
	 * - t: the position along the axis
	 * - vertices: the vertices (one or more) at this event along the axis
	 */
	const sweepVertices = ({ vertices_coords }, axis = 0, epsilon = EPSILON) => (
		clusterScalars(vertices_coords.map(p => p[axis]), epsilon)
			.map(vertices => ({
				vertices,
				t: vertices.reduce((p, c) => p + vertices_coords[c][axis], 0) / vertices.length,
			}))
	);
	/**
	 * @description This is the sweep method used by sweepEdges and sweepFaces.
	 * @param {number[]} values an array of scalars constructed from the
	 * vertices_coords array where for each coord, only the relevant value is taken
	 * @param {number[][]} edges_vertices an array of pairs of indices to the
	 * values array. note: the sweepFaces constructs new edges that span the entire
	 * face, so this has no relation to the graph's original edges_vertices.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 */
	// const sweepComponent = (values, { edges_vertices, faces_vertices }, epsilon = EPSILON) => {
	const sweepComponent = (values, { edges_vertices, vertices_edges }, epsilon = EPSILON) => {
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		const edgesValues = edges_vertices.map(edge => edge.map(e => values[e]));
		// is the span degenerate? (both values are an epsilon away from each other)
		const isDegenerate = edgesValues.map(pair => epsilonEqual(...pair, epsilon));
		// which vertex comes first along the sweep axis
		const edgesDirection = edgesValues.map(([a, b]) => Math.sign(a - b));
		// for each edge, for each of its two vertices, is the vertex +1, 0, -1?
		// -1: first point's coordinate is smaller
		//  0: coordinates are same (within an epsilon)
		// +1: second point's coordinate is smaller
		const edgesVertexSide = edges_vertices
			.map(([v1, v2], i) => (isDegenerate[i]
				? { [v1]: 0, [v2]: 0 }
				: { [v1]: edgesDirection[i], [v2]: -edgesDirection[i] }));
		// within each cluster, if there are a lot of consecutive lines orthogonal
		// to the sweep axis, there will be repeats of edges when converting these
		// vertices into their adjacent edges by looking at vertices_edges.
		// we have to pile these into a Set and extract an array of unique values.
		return clusterScalars(values, epsilon)
			// ensure that every vertex is used in the graph, filter out any vertices
			// which aren't found in vertices_edges, and if this creates empty clusters
			// with no vertices, filter out these clusters
			.map(vertices => vertices.filter(v => vertices_edges[v]))
			.filter(vertices => vertices.length)
			.map(vertices => ({
				vertices,
				t: vertices.reduce((p, c) => p + values[c], 0) / vertices.length,
				start: uniqueElements(vertices.flatMap(v => vertices_edges[v]
					.filter(edge => edgesVertexSide[edge][v] <= 0))),
				end: uniqueElements(vertices.flatMap(v => vertices_edges[v]
					.filter(edge => edgesVertexSide[edge][v] >= 0))),
			}));
	};
	/**
	 * @description Perform a line sweep through the edges of a graph,
	 * This method will create an array of events, each event will either
	 * "start" edges or "end" edges, and for those edges which are orthogonal
	 * to the sweep axis within an epsilon, they will only exist inside one
	 * event and be present in both the "start" and the "end" arrays.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [axis=0] which axis to sweep along
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} an array of event objects, each event contains:
	 * - t: the position along the axis
	 * - vertices: the vertices (one or more) at this event along the axis
	 * - start: the edges which begin at this event in the sweep
	 * - end: the edges which end at this event in the sweep
	 */
	const sweepEdges = ({
		vertices_coords, edges_vertices, vertices_edges,
	}, axis = 0, epsilon = EPSILON) => (
		sweepComponent(vertices_coords.map(p => p[axis]), { edges_vertices, vertices_edges }, epsilon)
	);
	/**
	 * @description Perform a line sweep through the faces of a graph,
	 * This method will create an array of events, each event will either
	 * "start" faces or "end" faces. In the case of degenerate faces whose
	 * vertices all lie on a line and that line is orthogonal to the sweep
	 * axis, within an epsilon, these faces will only exist inside one
	 * event and be present in both the "start" and the "end" arrays.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [axis=0] which axis to sweep along
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} an array of event objects, each event contains:
	 * - t: the position along the axis
	 * - vertices: the vertices (one or more) at this event along the axis
	 * - start: the faces which begin at this event in the sweep
	 * - end: the faces which end at this event in the sweep
	 */
	const sweepFaces = ({
		vertices_coords, faces_vertices,
	}, axis = 0, epsilon = EPSILON) => sweepComponent(
		vertices_coords.map(p => p[axis]),
		// get the min/max vertex for each face along the sweep axis.
		// this will serve as the "edge" that spans the breadth of the face
		{ edges_vertices: edgeifyFaces({ vertices_coords, faces_vertices }, axis) },
		epsilon,
	);
	/**
	 *
	 */
	const sweep = (graph, axis = 0, epsilon = EPSILON) => {
		const values = graph.vertices_coords.map(p => p[axis]);
		const edges_vertices = graph.edges_vertices;
		// "faces_vertices" contains only two vertices for each face,
		// and can be treated just like edges_vertices.
		const faces_vertices = edgeifyFaces(graph, axis);
		const vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		const vertices_faces = makeVerticesEdgesUnsorted({ edges_vertices: faces_vertices });
		const edgesValues = edges_vertices.map(edge => edge.map(e => values[e]));
		const facesValues = faces_vertices.map(face => face.map(e => values[e]));
		// is the span degenerate? (both values are an epsilon away from each other)
		const edgesDegenerate = edgesValues.map(pair => epsilonEqual(...pair, epsilon));
		const facesDegenerate = facesValues.map(pair => epsilonEqual(...pair, epsilon));
		// which vertex comes first along the sweep axis
		const edgesDirection = edgesValues.map(([a, b]) => Math.sign(a - b));
		const facesDirection = facesValues.map(([a, b]) => Math.sign(a - b));
		// for each edge, for each of its two vertices, is the vertex +1, 0, -1?
		// -1: first point's coordinate is smaller
		//  0: coordinates are same (within an epsilon)
		// +1: second point's coordinate is smaller
		const edgesVertexSide = edges_vertices
			.map(([v1, v2], i) => (edgesDegenerate[i]
				? { [v1]: 0, [v2]: 0 }
				: { [v1]: edgesDirection[i], [v2]: -edgesDirection[i] }));
		const facesVertexSide = faces_vertices
			.map(([v1, v2], i) => (facesDegenerate[i]
				? { [v1]: 0, [v2]: 0 }
				: { [v1]: facesDirection[i], [v2]: -facesDirection[i] }));
		// within each cluster, if there are a lot of consecutive lines orthogonal
		// to the sweep axis, there will be repeats of edges when converting these
		// vertices into their adjacent edges by looking at vertices_edges.
		// we have to pile these into a Set and extract an array of unique values.
		return clusterScalars(values, epsilon)
			.map(vertices => ({
				vertices,
				t: vertices.reduce((p, c) => p + values[c], 0) / vertices.length,
				edges: {
					start: uniqueElements(vertices
						.filter(v => vertices_edges[v] !== undefined)
						.flatMap(v => vertices_edges[v]
							.filter(edge => edgesVertexSide[edge][v] <= 0))),
					end: uniqueElements(vertices
						.filter(v => vertices_edges[v] !== undefined)
						.flatMap(v => vertices_edges[v]
							.filter(edge => edgesVertexSide[edge][v] >= 0))),
				},
				faces: {
					start: uniqueElements(vertices
						.filter(v => vertices_faces[v] !== undefined)
						.flatMap(v => vertices_faces[v]
							.filter(face => facesVertexSide[face][v] <= 0))),
					end: uniqueElements(vertices
						.filter(v => vertices_faces[v] !== undefined)
						.flatMap(v => vertices_faces[v]
							.filter(face => facesVertexSide[face][v] >= 0))),
				},
			}));
	};

	var sweep$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		sweep: sweep,
		sweepEdges: sweepEdges,
		sweepFaces: sweepFaces,
		sweepVertices: sweepVertices
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * check each vertex against each edge, we want to know if a vertex is
	 * lying collinear along an edge, the usual intention is to substitute
	 * the edge with 2 edges that include the collinear vertex.
	 */
	/**
	 * this DOES NOT return vertices that are already connected
	 * between two adjacent and collinear edges, in a valid graph
	 *    O------------O------------O
	 * for this you want: ___________ method
	 */
	/**
	 * @description Get a list of lists where for every edge there is a
	 * list filled with vertices that lies collinear to the edge, where
	 * collinearity only counts if the vertex lies between the edge's endpoints,
	 * excluding the endpoints themselves.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} size matched to the edges_ arrays, with an empty array
	 * unless a vertex lies collinear, the edge's array will contain that vertex's index.
	 * @linkcode Origami ./src/graph/verticesCollinear.js 59
	 */
	const getVerticesEdgesOverlap = ({
		vertices_coords, edges_vertices, vertices_edges, edges_vector,
	}, epsilon = EPSILON) => {
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		const edgesLine = edges_vertices.map((_, i) => ({
			vector: edges_vector[i],
			origin: vertices_coords[edges_vertices[i][0]],
		}));
		// check the Y value against the bounding box and skip the call to the
		// overlap method if possible. results in 2x speed up (200ms to 100ms)
		const edgesYs = edges_vertices
			.map(ev => ev.map(v => vertices_coords[v][1]))
			.map(ys => (ys[0] < ys[1] ? ys : [ys[1], ys[0]]))
			// inclusive, so, we expand the y-span
			.map(ys => [ys[0] - epsilon, ys[1] + epsilon]);
		const overlaps = [];
		const setOfEdges = [];
		sweepEdges({ vertices_coords, edges_vertices, vertices_edges }, epsilon)
			.forEach(event => {
				event.start.forEach(e => { setOfEdges[e] = true; });
				setOfEdges
					.forEach((_, e) => event.vertices
						.forEach(v => {
							if (edges_vertices[e][0] === v || edges_vertices[e][1] === v) { return; }
							const vertY = vertices_coords[v][1];
							if (vertY < edgesYs[e][0] || vertY > edgesYs[e][1]) { return; }
							if (!overlaps[e]) { overlaps[e] = []; }
							overlaps[e][v] = overlapLinePoint(
								edgesLine[e],
								vertices_coords[v],
								excludeS,
								epsilon,
							);
						}));
				event.end.forEach(e => delete setOfEdges[e]);
			});
		return overlaps
			.map(verts => verts
				.map((vert, i) => (vert ? i : undefined))
				.filter(i => i !== undefined));
	};

	var intersectVerticesEdges = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getVerticesEdgesOverlap: getVerticesEdgesOverlap
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Find the intersection of two lines. Lines can be
	 * lines/rays/segments, and can be inclusive or exclusive in terms
	 * of their endpoints and the epsilon value.
	 * @param {VecLine} a line object with "vector" and "origin"
	 * @param {VecLine} b line object with "vector" and "origin"
	 * @param {function} [aDomain=includeL] the domain of the first line
	 * @param {function} [bDomain=includeL] the domain of the second line
	 * @param {number} [epsilon=1e-6] optional epsilon
	 * @returns {number[]|undefined} one 2D point or undefined
	 * @linkcode Math ./src/intersect/intersect.js 39
	*/
	const intersectLineLine = (
		a,
		b,
		aDomain = includeL,
		bDomain = includeL,
		epsilon = EPSILON,
	) => {
		// a normalized determinant gives consistent values across all epsilon ranges
		const det_norm = cross2(normalize2(a.vector), normalize2(b.vector));
		// lines are parallel
		if (Math.abs(det_norm) < epsilon) { return undefined; }
		const determinant0 = cross2(a.vector, b.vector);
		const determinant1 = -determinant0;
		const a2b = [b.origin[0] - a.origin[0], b.origin[1] - a.origin[1]];
		const b2a = [-a2b[0], -a2b[1]];
		const t0 = cross2(a2b, b.vector) / determinant0;
		const t1 = cross2(b2a, a.vector) / determinant1;
		if (aDomain(t0, epsilon / magnitude2(a.vector))
			&& bDomain(t1, epsilon / magnitude2(b.vector))) {
			return add2(a.origin, scale2(a.vector, t0));
		}
		return undefined;
	};
	/**
	 * @description Calculate the intersection of a circle and a line;
	 * the line can be a line, ray, or segment.
	 * @param {Circle} circle a circle in "radius" "origin" form
	 * @param {VecLine} line a line in "vector" "origin" form
	 * @param {function} [circleDomain=include] the inclusivity of
	 * the circle boundary (currently not used).
	 * @param {function} [lineFunc=includeL] set the line/ray/segment
	 * and inclusive/exclusive
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @linkcode Math ./src/intersect/intersect.js 74
	 */
	const intersectCircleLine = (
		circle,
		line,
		circleDomain = include,
		lineDomain = includeL,
		epsilon = EPSILON,
	) => {
		const magSq = line.vector[0] ** 2 + line.vector[1] ** 2;
		const mag = Math.sqrt(magSq);
		const norm = mag === 0 ? line.vector : line.vector.map(c => c / mag);
		const rot90 = rotate90(norm);
		const bvec = subtract2(line.origin, circle.origin);
		const det = cross2(bvec, norm);
		if (Math.abs(det) > circle.radius + epsilon) { return undefined; }
		const side = Math.sqrt((circle.radius ** 2) - (det ** 2));
		const f = (s, i) => circle.origin[i] - rot90[i] * det + norm[i] * s;
		const results = Math.abs(circle.radius - Math.abs(det)) < epsilon
			? [side].map((s) => [s, s].map(f)) // tangent to circle
			: [-side, side].map((s) => [s, s].map(f));
		const ts = results.map(res => res.map((n, i) => n - line.origin[i]))
			.map(v => v[0] * line.vector[0] + line.vector[1] * v[1])
			.map(d => d / magSq);
		return results.filter((_, i) => lineDomain(ts[i], epsilon));
	};

	const acosSafe = (x) => {
		if (x >= 1.0) return 0;
		if (x <= -1.0) return Math.PI;
		return Math.acos(x);
	};

	const rotateVector2 = (center, pt, a) => {
		const x = pt[0] - center[0];
		const y = pt[1] - center[1];
		const xRot = x * Math.cos(a) + y * Math.sin(a);
		const yRot = y * Math.cos(a) - x * Math.sin(a);
		return [center[0] + xRot, center[1] + yRot];
	};
	/**
	 * @description calculate the intersection of two circles, resulting
	 * in either no intersection, or one or two points.
	 * @param {Circle} c1 circle in "radius" "origin" form
	 * @param {Circle} c2 circle in "radius" "origin" form
	 * @param {function} [circleDomain=include] the inclusivity of
	 * the first circle parameter (currently not used).
	 * @param {function} [circleDomain=include] the inclusivity of
	 * the second circle parameter (currently not used).
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]|undefined} an array of one or two points, or undefined if no intersection
	 * @linkcode Math ./src/intersect/intersect.js 121
	 */
	const intersectCircleCircle = (
		c1,
		c2,
		c1Domain = include,
		c2Domain = include,
		epsilon = EPSILON,
	) => {
		// sort by largest-smallest radius
		const r = (c1.radius < c2.radius) ? c1.radius : c2.radius;
		const R = (c1.radius < c2.radius) ? c2.radius : c1.radius;
		const smCenter = (c1.radius < c2.radius) ? c1.origin : c2.origin;
		const bgCenter = (c1.radius < c2.radius) ? c2.origin : c1.origin;
		// this is also the starting vector to rotate around the big circle
		const vec = [smCenter[0] - bgCenter[0], smCenter[1] - bgCenter[1]];
		const d = Math.sqrt((vec[0] ** 2) + (vec[1] ** 2));
		// infinite solutions // don't need this because the below case covers it
		// if (d < epsilon && Math.abs(R - r) < epsilon) { return undefined; }
		// no intersection (same center, different size)
		if (d < epsilon) { return undefined; }
		const point = vec.map((v, i) => (v / d) * R + bgCenter[i]);
		// kissing circles
		if (Math.abs((R + r) - d) < epsilon
			|| Math.abs(R - (r + d)) < epsilon) { return [point]; }
		// circles are contained
		if ((d + r) < R || (R + r < d)) { return undefined; }
		const angle = acosSafe((r * r - d * d - R * R) / (-2.0 * d * R));
		const pt1 = rotateVector2(bgCenter, point, +angle);
		const pt2 = rotateVector2(bgCenter, point, -angle);
		return [pt1, pt2];
	};

	// todo, this is copied over in clip/polygon.js
	const getUniquePair = (intersections) => {
		for (let i = 1; i < intersections.length; i += 1) {
			if (!epsilonEqualVectors(intersections[0], intersections[i])) {
				return [intersections[0], intersections[i]];
			}
		}
		return undefined;
	};
	/**
	 * generalized line-ray-segment intersection with convex polygon function
	 * for lines and rays, line1 and line2 are the vector, origin in that order.
	 * for segments, line1 and line2 are the two endpoints.
	 */
	const intersectConvexPolygonLineInclusive = (
		poly,
		{ vector, origin },
		fn_poly = includeS,
		fn_line = includeL,
		epsilon = EPSILON,
	) => {
		const intersections = poly
			.map((p, i, arr) => [p, arr[(i + 1) % arr.length]]) // into segment pairs
			.map(side => intersectLineLine(
				{ vector: subtract2(side[1], side[0]), origin: side[0] },
				{ vector, origin },
				fn_poly,
				fn_line,
				epsilon,
			))
			.filter(a => a !== undefined);
		switch (intersections.length) {
		case 0: return undefined;
		case 1: return [intersections];
		default:
			// for two intersection points or more, in the case of vertex-
			// collinear intersections the same point from 2 polygon sides
			// can be returned. we need to filter for unique points.
			// if no 2 unique points found:
			// there was only one unique intersection point after all.
			return getUniquePair(intersections) || [intersections[0]];
		}
	};
	/**
	 * @description Generalized line-ray-segment intersection with convex
	 * polygons.
	 * @param {number[][]} poly a polygon as an array of points
	 * @param {VecLine} line a line in "vector" "origin" form.
	 * @param {function} [fn_poly=includeS] the inclusivity of
	 * the edges of the polygon
	 * @param {function} [aDomain=includeL] the domain of the line
	 * @returns {number[][]} an array of one or two points, or
	 * undefined if there is no intersection.
	 * @note this doubles as the exclusive condition, and the main export
	 * since it checks for exclusive/inclusive and can early-return
	 * @linkcode Math ./src/intersect/intersect.js 204
	 */
	const intersectConvexPolygonLine = (
		poly,
		{ vector, origin },
		fn_poly = includeS,
		fn_line = excludeL,
		epsilon = EPSILON,
	) => {
		const sects = intersectConvexPolygonLineInclusive(
			poly,
			{ vector, origin },
			fn_poly,
			fn_line,
			epsilon,
		);
		// const sects = convex_poly_line_intersect(intersect_func, poly, line1, line2, epsilon);
		let altFunc; // the opposite func, as far as inclusive/exclusive
		switch (fn_line) {
		// case excludeL: altFunc = includeL; break;
		case excludeR: altFunc = includeR; break;
		case excludeS: altFunc = includeS; break;
		default: return sects;
		}
		// here on, we are only dealing with exclusive tests, parsing issues with
		// vertex-on intersections that still intersect or don't intersect the polygon.
		// repeat the computation but include intersections with the polygon's vertices.
		const includes = intersectConvexPolygonLineInclusive(
			poly,
			{ vector, origin },
			includeS,
			altFunc,
			epsilon,
		);
		// const includes = convex_poly_line_intersect(altFunc, poly, line1, line2, epsilon);
		// if there are still no intersections, the line doesn't intersect.
		if (includes === undefined) { return undefined; }
		// if there are intersections, see if the line crosses the entire polygon
		// (gives us 2 unique points)
		const uniqueIncludes = getUniquePair(includes);
		// first, deal with the case that there are no unique 2 points.
		if (uniqueIncludes === undefined) {
			switch (fn_line) {
			// if there is one intersection, check if a ray's origin is inside.
			// 1. if the origin is inside, consider the intersection valid
			// 2. if the origin is outside, same as the line case above. no intersection.
			case excludeR:
				// is the ray origin inside?
				return overlapConvexPolygonPoint(poly, origin, exclude, epsilon)
					? includes
					: undefined;
			// if there is one intersection, check if either of a segment's points are
			// inside the polygon, same as the ray above. if neither are, consider
			// the intersection invalid for the exclusive case.
			case excludeS:
				return overlapConvexPolygonPoint(poly, add2(origin, vector), exclude, epsilon)
					|| overlapConvexPolygonPoint(poly, origin, exclude, epsilon)
					? includes
					: undefined;
			// if there is one intersection, an infinite line is intersecting the
			// polygon from the outside touching at just one vertex. this should be
			// considered undefined for the exclusive case.
			case excludeL: return undefined;
			default: return undefined;
			}
		}
		// now that we've covered all the other cases, we know that the line intersects
		// the polygon at two unique points. this should return true for all cases
		// except one: when the line is collinear to an edge of the polygon.
		// to test this, get the midpoint of the two intersects and do an exclusive
		// check if the midpoint is inside the polygon. if it is, the line is crossing
		// the polygon and the intersection is valid.
		return overlapConvexPolygonPoint(poly, midpoint2(...uniqueIncludes), exclude, epsilon)
			? uniqueIncludes
			: sects;
	};

	var intersect$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		intersectCircleCircle: intersectCircleCircle,
		intersectCircleLine: intersectCircleLine,
		intersectConvexPolygonLine: intersectConvexPolygonLine,
		intersectLineLine: intersectLineLine
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description get all intersections between edges in a 2D graph.
	 * Edge endpoints are excluded.
	 * @param {FOLD} graph a FOLD graph with 2D vertices
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns maybe this should be refactored
	 */
	const getEdgesEdgesIntersection = ({
		vertices_coords, edges_vertices, vertices_edges, edges_vector, edges_origin,
	}, epsilon = EPSILON) => {
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		if (!edges_origin) {
			edges_origin = edges_vertices.map(ev => vertices_coords[ev[0]]);
		}
		const intersections = [];
		// as we progress through the line sweep, maintain a list (hash table)
		// of the set of edges which are currently overlapping this sweep line.
		const setOfEdges = [];
		sweepEdges({ vertices_coords, edges_vertices, vertices_edges }, epsilon)
			.forEach(event => {
				event.start.forEach(e => { setOfEdges[e] = true; });
				setOfEdges
					.forEach((_, e1) => event.start
						.forEach(e2 => {
							if (e1 === e2) { return; }
							const intersection = intersectLineLine(
								{ vector: edges_vector[e1], origin: edges_origin[e1] },
								{ vector: edges_vector[e2], origin: edges_origin[e2] },
								excludeS,
								excludeS,
								epsilon,
							);
							if (intersection) {
								if (!intersections[e1]) { intersections[e1] = []; }
								if (!intersections[e2]) { intersections[e2] = []; }
								intersections[e1][e2] = intersection;
								intersections[e2][e1] = intersection;
							}
						}));
				event.end.forEach(e => delete setOfEdges[e]);
			});
		return intersections;
	};
	/**
	 * @description Create an NxN matrix (N number of edges) that relates edges to each other,
	 * inside each entry is true/false, true if the two edges are parallel within an epsilon.
	 * Both sides of the matrix are filled, the diagonal is left undefined.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean[][]} a boolean matrix, are two edges parallel?
	 * @todo wait, no, this is not setting the main diagonal undefined now. what is up?
	 * @linkcode Origami ./src/graph/edgesEdges.js 82
	 */
	const makeEdgesEdgesParallel = ({
		vertices_coords, edges_vertices, edges_vector,
	}, epsilon = EPSILON) => {
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		const normalized = edges_vector.map(vec => normalize(vec));
		return normalized
			.map((vec1, i) => normalized
				.map((vec2, j) => (i === j
					? undefined
					: (1 - Math.abs(dot(normalized[i], normalized[j])) < epsilon)))
				.map((parallel, j) => (parallel ? j : undefined))
				.filter(a => a !== undefined));
	};
	/**
	 * @description A subroutine for the two methods below.
	 * given a matrix which was already worked on, consider only the true values,
	 * compute the overlapLineLine method for each edge-pairs.
	 * provide a comparison function (func) to specify inclusive/exclusivity.
	 */
	const overwriteEdgesOverlaps = (edges_edges, vectors, origins, func, epsilon) => {
		const edges_edgesOverlap = edges_edges.map(() => []);
		edges_edges
			.forEach((arr, i) => arr
				.forEach(j => {
					if (i >= j) { return; }
					if (overlapLineLine(
						{ vector: vectors[i], origin: origins[i] },
						{ vector: vectors[j], origin: origins[j] },
						func,
						func,
						epsilon,
					)) {
						edges_edgesOverlap[i].push(j);
						edges_edgesOverlap[j].push(i);
					}
				}));
		return edges_edgesOverlap;
	};
	/**
	 * @description Find all edges which are parallel to each other AND they overlap.
	 * The epsilon space around vertices is not considered, so, edges must be
	 * overlapping beyond just their endpoints for them to be considered.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean[][]} a boolean matrix, do two edges cross each other?
	 */
	const makeEdgesEdgesParallelOverlap = ({
		vertices_coords, edges_vertices, edges_vector,
	}, epsilon) => {
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		const edges_origin = edges_vertices.map(verts => vertices_coords[verts[0]]);
		// start with edges-edges parallel matrix
		const edges_edgesParallel = makeEdgesEdgesParallel({
			vertices_coords, edges_vertices, edges_vector,
		}, epsilon);
		// only if lines are parallel, then run the more expensive overlap method
		return overwriteEdgesOverlaps(
			edges_edgesParallel,
			edges_vector,
			edges_origin,
			excludeS,
			epsilon,
		);
	};

	// todo, improvement suggestion:
	// first grouping edges into categories with edges which share parallel-ness.
	// then, express every edge's endpoints in terms of the length along
	// the vector. converting it into 2 numbers, and now all you have to do is
	// test if these two numbers overlap other edges' two numbers.

	/**
	 * we want to include this case, where one edge may not overlap another
	 * but it still gets included because both are overlapped by a common edge.
	 *
	 *  |----a-----|    |-------c------|
	 *          |-----b----|
	 *
	 * "a" and "c" are included together because b causes them to be so.
	 */

	// export const makeEdgesEdgesParallel = ({
	// 	vertices_coords, edges_vertices, edges_vector,
	// }, epsilon) => { // = EPSILON) => {
	// 	if (!edges_vector) {
	// 		edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
	// 	}
	// 	// let lastTime = new Date();
	// 	const edge_count = edges_vector.length;
	// 	const normalized = edges_vector
	// 		.map(vec => math.normalize(vec));
	// 	// ///////////////////////////////////////
	// 	// idk why this isn't working. it's leaving out some indices. something with
	// 	// the group building - indices.slice(), something there.
	// 	// const dots = normalized
	// 	// 	.map(vec => math.dot(vec, [1, 0]));
	// 	// const indices = Array.from(Array(edge_count))
	// 	// 	.map((_, i) => i)
	// 	// 	.sort((a, b) => dots[a] - dots[b]);
	// 	// let start = 0;
	// 	// const groups = [];
	// 	// for (let i = 1; i < indices.length; i += 1) {
	// 	// 	if (!epsilonEqual(dots[indices[start]], dots[indices[i]], epsilon)) {
	// 	// 		groups.push(indices.slice(start, i));
	// 	// 		start = i;
	// 	// 	}
	// 	// }
	// 	// if (groups.length > 2) {
	// 	// 	if (epsilonEqual(groups[0][0], -1, epsilon)
	// 	// 		&& epsilonEqual(groups[groups.length - 1][0], 1, epsilon)) {
	// 	// 		const lastGroup = groups.pop();
	// 	// 		groups[0] = groups[0].concat(lastGroup);
	// 	// 	}
	// 	// }
	// 	// const edges_edges_parallel = Array
	// 	// 	.from(Array(edge_count))
	// 	// 	.map(() => Array(edge_count).fill(false));
	// 	// for (let g = 0; g < groups.length; g += 1) {
	// 	// 	for (let i = 0; i < groups[g].length - 1; i += 1) {
	// 	// 		for (let j = i + 1; j < groups[g].length; j += 1) {
	// 	// 			edges_edges_parallel[groups[g][i]][groups[g][j]] = true;
	// 	// 			edges_edges_parallel[groups[g][j]][groups[g][i]] = true;
	// 	// 		}
	// 	// 	}
	// 	// }
	// 	// console.log("groups", groups);
	// 	// for (let i = 0; i < edge_count; i += 1) {
	// 	// 	edges_edges_parallel[i][i] = undefined;
	// 	// }
	// 	const edges_edges_parallel = Array
	// 		.from(Array(edge_count))
	// 		.map(() => Array.from(Array(edge_count)));
	// 	for (let i = 0; i < edge_count - 1; i += 1) {
	// 		for (let j = i + 1; j < edge_count; j += 1) {
	// 			const p = (1 - Math.abs(math.dot(normalized[i], normalized[j])) < epsilon);
	// 			edges_edges_parallel[i][j] = p;
	// 			edges_edges_parallel[j][i] = p;
	// 		}
	// 	}
	// 	return edges_edges_parallel;
	// };

	// const edges_radians = edges_vector
	//   .map(v => Math.atan2(v[1], v[0]));
	// const sorted = edges_radians
	//   .map(rad => rad > 0 ? rad : rad + Math.PI)
	//   .map((radians, i) => ({ radians, i }))
	//   .sort((a, b) => a.radians - b.radians);

	// const similar_num = (a, b, epsilon = 0.001) => Math
	//   .abs(a - b) < epsilon;

	// const parallel_groups = [
	//   []
	// ];
	// let group_i = 0;

	// const edges_parallel = Array
	//   .from(Array(edge_count))
	//   .map(() => []);
	// let walk = 0;
	// for (let i = 1; i < edge_count; i++) {
	//   while (!similar_num(sorted[walk].radians, sorted[i].radians) && walk < i) {
	//     walk++;
	//   }
	//   for (let j = walk; j < i; j++) {
	//     edges_parallel[j].push(i);
	//   }
	// }

	var intersectEdgesEdges = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getEdgesEdgesIntersection: getEdgesEdgesIntersection,
		makeEdgesEdgesParallelOverlap: makeEdgesEdgesParallelOverlap
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * Fragment converts a graph into a planar graph. it flattens all the
	 * coordinates onto the 2D plane.
	 *
	 * it modifies edges and vertices. splitting overlapping edges
	 * at their intersections, merging vertices that lie too near to one another.
	 * # of edges may increase. # of vertices may decrease. (is that for sure?)
	 *
	 * This function requires an epsilon (1e-6), for example a busy
	 * edge crossing should be able to resolve to one point
	 *
	 * 1. merge vertices that are within the epsilon.
	 *
	 * 2. gather all intersections, for every line.
	 *    for example, the first line in the list gets compared to other lines
	 *    resulting in a list of intersection points,
	 *
	 * 3. replace the edge with a new, rebuilt, sequence of edges, with
	 *    new vertices.
	 */
	const fragmentGraph = (graph, epsilon = EPSILON) => {
		const edges_coords = graph.edges_vertices
			.map(ev => ev.map(v => graph.vertices_coords[v]));
		// when we rebuild an edge we need the intersection points sorted
		// so we can walk down it and rebuild one by one. sort along vector
		const edges_vector = edges_coords.map(e => subtract(e[1], e[0]));
		const edges_origin = edges_coords.map(e => e[0]);
		// both edge-edge and edge-vertex methods use this. precalculate it.
		const vertices_edges = makeVerticesEdgesUnsorted(graph);
		// for each edge, get all the intersection points
		// this array will match edges_, each an array containing intersection
		// points (an [x,y] array), with an important detail, because each edge
		// intersects with another edge, this [x,y] point is a shallow pointer
		// to the same one in the other edge's intersection array.
		const edges_intersections = getEdgesEdgesIntersection({
			vertices_coords: graph.vertices_coords,
			vertices_edges,
			edges_vertices: graph.edges_vertices,
			edges_vector,
			edges_origin,
		}, 1e-6);

		// todo:
		// this is the slowest subroutine in the entire planarize() method.
		// see if it can be sped up...
		// check the new edges' vertices against every edge, in case
		// one of the endpoints lies along an edge.
		// const edges_collinear_vertices_old = getVerticesEdgesOverlap({
		// 	vertices_coords: graph.vertices_coords,
		// 	edges_vertices: graph.edges_vertices,
		// 	edges_coords,
		// }, epsilon);
		const edges_collinear_vertices = getVerticesEdgesOverlap({
			vertices_coords: graph.vertices_coords,
			vertices_edges,
			edges_vertices: graph.edges_vertices,
			edges_vector,
		}, epsilon);
		// exit early
		if (edges_intersections.flat().filter(a => a !== undefined).length === 0
			&& edges_collinear_vertices.flat().filter(a => a !== undefined).length === 0) {
			return undefined;
		}
		// remember, edges_intersections contains intersections [x,y] points
		// each one appears twice (both edges that intersect) and is the same
		// object, shallow pointer.
		//
		// iterate over this list and move each vertex into new_vertices_coords.
		// in their place put the index of this new vertex in the new array.
		// when we get to the second appearance of the same point, it will have
		// been replaced with the index, so we can skip it. (check length of
		// item, 2=point, 1=index)
		const counts = { vertices: graph.vertices_coords.length };
		// add new vertices (intersection points) to the graph
		edges_intersections
			.forEach(edge => edge
				.filter(a => a !== undefined)
				.filter(a => a.length === 2)
				.forEach((intersect) => {
					const newIndex = graph.vertices_coords.length;
					graph.vertices_coords.push([...intersect]);
					intersect.splice(0, 2);
					intersect.push(newIndex);
				}));
		// replace arrays with indices
		edges_intersections.forEach((edge, i) => {
			edge.forEach((intersect, j) => {
				if (intersect) {
					edges_intersections[i][j] = intersect[0];
				}
			});
		});

		const edges_intersections_flat = edges_intersections
			.map(arr => arr.filter(a => a !== undefined));
		// add lists of vertices into each element in edges_vertices
		// edges verts now contains an illegal arrangement of more than 2 verts
		// to be resolved below
		// graph.edges_vertices.forEach((verts, i) => verts
		// 	.push(...edges_intersections_flat[i], ...edges_collinear_vertices[i]));
		// // .push(...edges_intersections_flat[i]));
		graph.edges_vertices.forEach((verts, i) => {
			if (edges_intersections_flat[i]) {
				verts.push(...edges_intersections_flat[i]);
			}
			if (edges_collinear_vertices[i]) {
				verts.push(...edges_collinear_vertices[i]);
			}
		});

		graph.edges_vertices.forEach((edge, i) => {
			graph.edges_vertices[i] = sortVerticesAlongVector({
				vertices_coords: graph.vertices_coords,
			}, edge, edges_vector[i]);
		});

		// edge_map is length edges_vertices in the new, fragmented graph.
		// the value at each index is the edge that this edge was formed from.
		const edge_map = graph.edges_vertices
			.map((edge, i) => Array(edge.length - 1).fill(i))
			.flat();

		graph.edges_vertices = graph.edges_vertices
			.map(edge => Array.from(Array(edge.length - 1))
				.map((_, i, arr) => [edge[i], edge[i + 1]])) // todo, is this supposed to be % arr.length
			.flat();
		// copy over edge metadata if it exists
		// make foldAngles and assignments match if foldAngle is longer
		if (graph.edges_assignment && graph.edges_foldAngle
			&& graph.edges_foldAngle.length > graph.edges_assignment.length) {
			for (let i = graph.edges_assignment.length; i < graph.edges_foldAngle.length; i += 1) {
				graph.edges_assignment[i] = edgeFoldAngleToAssignment(graph.edges_foldAngle[i]);
			}
		}
		// copy over assignments and fold angle and base fold angle off assigments if it's shorter
		if (graph.edges_assignment) {
			graph.edges_assignment = edge_map.map(i => graph.edges_assignment[i] || "U");
		}
		if (graph.edges_foldAngle) {
			graph.edges_foldAngle = edge_map
				.map(i => graph.edges_foldAngle[i])
				.map((a, i) => (a === undefined
					? edgeAssignmentToFoldAngle(graph.edges_assignment[i])
					: a));
		}
		return {
			vertices: {
				new: Array.from(Array(graph.vertices_coords.length - counts.vertices))
					.map((_, i) => counts.vertices + i),
			},
			edges: {
				backmap: edge_map,
			},
		};
	};
	/**
	 * @description During the planarize process, faces will be entirely
	 * re-constructed, edges will be chopped; we can remove most arrays from
	 * the graph in preparation, except for these arrays, these need to stay.
	 */
	const planarKeepKeys = [
		_vertices_coords,
		_edges_vertices,
		_edges_assignment,
		_edges_foldAngle,
	];
	/**
	 * @description Planarize a graph into the 2D XY plane, split edges, rebuild faces.
	 * The graph provided as a method argument will be modified in place.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a summary of changes to the graph
	 * @linkcode Origami ./src/graph/fragment.js 174
	 */
	const planarize = (graph, epsilon = EPSILON) => {
		// project all vertices onto the XY plane
		graph.vertices_coords = graph.vertices_coords.map(coord => coord.slice(0, 2));

		[_vertices, _edges, _faces]
			.map(key => filterKeysWithPrefix(graph, key))
			.flat()
			.filter(key => !(planarKeepKeys.includes(key)))
			.forEach(key => delete graph[key]);

		const change = {
			vertices: {},
			edges: {},
		};
		let i;
		// most of the time this will loop twice, but exit early during the second
		// iteration due to all checks being passed. rarely, but still possible,
		// the merging of two vertices will bring one of the vertices over another
		// vertex junction, creating more edge-edge overlaps which requires another
		// iteration through this loop. at most, this has only ever been
		// observed to require one or two more loops, about 3 loops in total.
		for (i = 0; i < 20; i += 1) {
			const resVert = removeDuplicateVertices(graph, epsilon / 2);
			const resEdgeDup = removeDuplicateEdges(graph);
			const resEdgeCirc = removeCircularEdges(graph);
			const resFrag = fragmentGraph(graph, epsilon);
			if (resFrag === undefined) {
				change.vertices.map = (change.vertices.map === undefined
					? resVert.map
					: mergeNextmaps(change.vertices.map, resVert.map));
				change.edges.map = (change.edges.map === undefined
					? mergeNextmaps(resEdgeDup.map, resEdgeCirc.map)
					: mergeNextmaps(change.edges.map, resEdgeDup.map, resEdgeCirc.map));
				break;
			}
			const invert_frag = invertMap(resFrag.edges.backmap);
			const edgemap = mergeNextmaps(resEdgeDup.map, resEdgeCirc.map, invert_frag);
			change.vertices.map = (change.vertices.map === undefined
				? resVert.map
				: mergeNextmaps(change.vertices.map, resVert.map));
			change.edges.map = (change.edges.map === undefined
				? edgemap
				: mergeNextmaps(change.edges.map, edgemap));
		}
		if (i === 20) {
			throw new Error(Messages$1.planarize);
		}
		return change;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description populate() has been one of the hardest methods to
	 * nail down, not to write, moreso in what it should do, and what
	 * function it serves in the greater library.
	 * Currently, it is run once when a user imports their crease pattern
	 * for the first time, preparing it for use with methods like
	 * "splitFace" or "flatFold", which expect a well-populated graph.
	 */
	//
	// big todo: populate assumes the graph is planar and rebuilds planar faces
	//

	// try best not to lose information
	const buildAssignmentsIfNeeded = (graph) => {
		const len = graph.edges_vertices.length;
		// we know that edges_vertices exists
		if (!graph.edges_assignment) { graph.edges_assignment = []; }
		if (!graph.edges_foldAngle) { graph.edges_foldAngle = []; }
		// complete the shorter array to match the longer one
		if (graph.edges_assignment.length > graph.edges_foldAngle.length) {
			for (let i = graph.edges_foldAngle.length; i < graph.edges_assignment.length; i += 1) {
				graph.edges_foldAngle[i] = edgeAssignmentToFoldAngle(graph.edges_assignment[i]);
			}
		}
		if (graph.edges_foldAngle.length > graph.edges_assignment.length) {
			for (let i = graph.edges_assignment.length; i < graph.edges_foldAngle.length; i += 1) {
				graph.edges_assignment[i] = edgeFoldAngleToAssignment(graph.edges_foldAngle[i]);
			}
		}
		// two arrays should be at the same length now. even if they are not complete
		for (let i = graph.edges_assignment.length; i < len; i += 1) {
			graph.edges_assignment[i] = "U";
			graph.edges_foldAngle[i] = 0;
		}
	};
	/**
	 * @param {object} a FOLD object
	 * @param {boolean} reface should be set to "true" to force the algorithm into
	 * rebuilding the faces from scratch (walking edge to edge in the plane).
	 */
	const buildFacesIfNeeded = (graph, reface) => {
		// if faces_vertices does not exist, we need to build it.
		// todo: if faces_edges exists but not vertices (unusual but possible),
		// then build faces_vertices from faces_edges and call it done.
		if (reface === undefined && !graph.faces_vertices && !graph.faces_edges) {
			reface = true;
		}
		// build planar faces (no Z) if the user asks for it or if faces do not exist.
		// todo: this is making a big assumption that the faces are even planar
		// to begin with.
		if (reface && graph.vertices_coords) {
			const faces = makePlanarFaces(graph);
			graph.faces_vertices = faces.faces_vertices;
			graph.faces_edges = faces.faces_edges;
			// graph.faces_sectors = faces.faces_sectors;
			return;
		}
		// if both faces exist, and no request to be rebuilt, exit.
		if (graph.faces_vertices && graph.faces_edges) { return; }
		// between the two: faces_vertices and faces_edges,
		// if only one exists, build the other.
		if (graph.faces_vertices && !graph.faces_edges) {
			graph.faces_edges = makeFacesEdgesFromVertices(graph);
		} else if (graph.faces_edges && !graph.faces_vertices) {
			graph.faces_vertices = makeFacesVerticesFromEdges(graph);
		} else {
			// neither array exists, set placeholder empty arrays.
			graph.faces_vertices = [];
			graph.faces_edges = [];
		}
	};
	/**
	 * this function attempts to rebuild useful geometries in your graph.
	 * right now let's say it's important to have:
	 * - vertices_coords
	 * - either edges_vertices or faces_vertices - todo: this isn't true yet.
	 * - either edges_foldAngle or edges_assignment
	 *
	 * this WILL REWRITE components that aren't the primary source keys,
	 * like vertices_vertices.
	 *
	 * if you do have edges_assignment instead of edges_foldAngle the origami
	 * will be limited to flat-foldable.
	 */
	/**
	 * @description Populate all arrays in a FOLD graph. This includes building adjacency
	 * components like vertices_vertices, making edges_assignments from foldAngles or
	 * visa-versa, and building faces if they don't exist.
	 * @param {FOLD} graph a FOLD graph
	 * @param {boolean} [reface=false] optional boolean, request to rebuild all faces
	 * @return {FOLD} graph the same input graph object
	 * @linkcode Origami ./src/graph/populate.js 114
	 */
	const populate = (graph, reface) => {
		if (typeof graph !== "object") { return graph; }
		if (!graph.edges_vertices) { return graph; }
		graph.vertices_edges = makeVerticesEdgesUnsorted(graph);
		graph.vertices_vertices = makeVerticesVertices(graph);
		graph.vertices_edges = makeVerticesEdges(graph);
		// make sure "edges_foldAngle" and "edges_assignment" are built
		buildAssignmentsIfNeeded(graph);
		// make sure "faces_vertices" and "faces_edges" are built
		buildFacesIfNeeded(graph, reface);
		// depending on the presence of vertices_vertices, this will
		// run the simple algorithm (no radial sorting) or the proper one.
		graph.vertices_faces = makeVerticesFaces(graph);
		graph.edges_faces = makeEdgesFacesUnsorted(graph);
		graph.faces_faces = makeFacesFaces(graph);
		return graph;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * Not to be included in the main export
	 */
	/**
	 * @description Given an edge, uncover the adjacent faces.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} edge index of the edge in the graph
	 * {number[]} indices of the two vertices making up the edge
	 * @returns {number[]} array of 0, 1, or 2 numbers, the edge's adjacent faces
	 * @linkcode Origami ./src/graph/find.js 10
	 */
	const findAdjacentFacesToEdge = ({
		vertices_faces, edges_vertices, edges_faces, faces_edges, faces_vertices,
	}, edge) => {
		// easiest case, if edges_faces already exists.
		if (edges_faces && edges_faces[edge]) {
			return edges_faces[edge];
		}
		// if that doesn't exist, uncover the data by looking at our incident
		// vertices' faces, compare every index against every index, looking
		// for 2 indices that are present in both arrays. there should be 2.
		const vertices = edges_vertices[edge];
		if (vertices_faces !== undefined) {
			const faces = [];
			for (let i = 0; i < vertices_faces[vertices[0]].length; i += 1) {
				for (let j = 0; j < vertices_faces[vertices[1]].length; j += 1) {
					if (vertices_faces[vertices[0]][i] === vertices_faces[vertices[1]][j]) {
						// todo: now allowing undefined to be in vertices_faces,
						// but, do we want to exclude them from the result?
						if (vertices_faces[vertices[0]][i] === undefined) { continue; }
						faces.push(vertices_faces[vertices[0]][i]);
					}
				}
			}
			return faces;
		}
		if (faces_edges) {
			const faces = [];
			for (let i = 0; i < faces_edges.length; i += 1) {
				for (let e = 0; e < faces_edges[i].length; e += 1) {
					if (faces_edges[i][e] === edge) { faces.push(i); }
				}
			}
			return faces;
		}
		if (faces_vertices) {
			console.warn("todo: findAdjacentFacesToEdge");
			// let faces = [];
			// for (let i = 0; i < faces_vertices.length; i += 1) {
			//   for (let v = 0; v < faces_vertices[i].length; v += 1) {
			//   }
			// }
		}
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description an edge was just split into two by the addition of a vertex.
	 * update new vertex's vertices_vertices, as well as the split edge's
	 * endpoint's vertices_vertices to include the new vertex in place of the
	 * old endpoints, preserving all other vertices_vertices of the endpoints.
	 * @param {object} graph a FOLD object, modified in place
	 * @param {number} vertex index of new vertex
	 * @param {number[]} incident_vertices vertices that make up the split edge.
	 * the new vertex lies between.
	 */
	const update_vertices_vertices$2 = ({ vertices_vertices }, vertex, incident_vertices) => {
		if (!vertices_vertices) { return; }
		// create a new entry for this new vertex
		// only 2 vertices, no need to worry about winding order.
		vertices_vertices[vertex] = [...incident_vertices];
		// for each incident vertex in the vertices_vertices, replace the other incident
		// vertex's entry with this new vertex, the new vertex takes its place.
		incident_vertices.forEach((v, i, arr) => {
			const otherV = arr[(i + 1) % arr.length];
			const otherI = vertices_vertices[v].indexOf(otherV);
			vertices_vertices[v][otherI] = vertex;
		});
	};
	/**
	 * @description run this after vertices_vertices has been built
	 */
	const update_vertices_sectors = ({
		vertices_coords, vertices_vertices, vertices_sectors,
	}, vertex) => {
		if (!vertices_sectors) { return; }
		vertices_sectors[vertex] = vertices_vertices[vertex].length === 1
			? [TWO_PI]
			: counterClockwiseSectors2(vertices_vertices[vertex]
				.map(v => subtract2(vertices_coords[v], vertices_coords[vertex])));
	};
	/**
	 * @description an edge was just split into two by the addition of a vertex.
	 * update vertices_edges for the new vertex, as well as the split edge's
	 * endpoint's vertices_edges to include the two new edges in place of the
	 * old one while preserving all other vertices_vertices in each endpoint.
	 * @param {object} graph a FOLD object, modified in place
	 * @param {number} old_edge the index of the old edge
	 * @param {number} new_vertex the index of the new vertex splitting the edge
	 * @param {number[]} vertices the old edge's two vertices, must be aligned with "new_edges"
	 * @param {number[]} new_edges the two new edges, must be aligned with "vertices"
	 */
	const update_vertices_edges$2 = ({
		vertices_edges,
	}, old_edge, new_vertex, vertices, new_edges) => {
		if (!vertices_edges) { return; }
		// update 1 vertex, our new vertex
		vertices_edges[new_vertex] = [...new_edges];
		// update the two vertices, our new vertex replaces the alternate
		// vertex in each of their arrays.  0-------x-------0
		vertices
			.map(v => vertices_edges[v].indexOf(old_edge))
			.forEach((index, i) => {
				vertices_edges[vertices[i]][index] = new_edges[i];
			});
	};
	/**
	 * @description a new vertex was added between two faces, update the
	 * vertices_faces with the already-known faces indices.
	 * @param {object} graph a FOLD object, modified in place
	 * @param {number} vertex the index of the new vertex
	 * @param {number[]} faces array of 0, 1, or 2 incident faces.
	 */
	const update_vertices_faces$1 = ({ vertices_faces }, vertex, faces) => {
		if (!vertices_faces) { return; }
		vertices_faces[vertex] = [...faces];
	};
	/**
	 * @description a new vertex was added between two faces, update the
	 * edges_faces with the already-known faces indices.
	 * @param {object} graph a FOLD object, modified in place
	 * @param {number[]} new_edges array of 2 new edges
	 * @param {number[]} faces array of 0, 1, or 2 incident faces.
	 */
	const update_edges_faces$1 = ({ edges_faces }, new_edges, faces) => {
		if (!edges_faces) { return; }
		new_edges.forEach(edge => { edges_faces[edge] = [...faces]; });
	};
	/**
	 * @description a new vertex was added, splitting an edge. rebuild the
	 * two incident faces by replacing the old edge with new one.
	 * @param {object} graph a FOLD object, modified in place
	 * @param {number[]} new_vertex indices of two faces to be rebuilt
	 * @param {number} incident_vertices new vertex index
	 * @param {number[]} faces the two vertices of the old edge
	 */
	const update_faces_vertices = ({ faces_vertices }, new_vertex, incident_vertices, faces) => {
		// exit if we don't even have faces_vertices
		if (!faces_vertices) { return; }
		faces
			.map(i => faces_vertices[i])
			.forEach(face => face
				.map((fv, i, arr) => {
					const nextI = (i + 1) % arr.length;
					return (fv === incident_vertices[0]
									&& arr[nextI] === incident_vertices[1])
									|| (fv === incident_vertices[1]
									&& arr[nextI] === incident_vertices[0])
						? nextI : undefined;
				}).filter(el => el !== undefined)
				.sort((a, b) => b - a)
				.forEach(i => face.splice(i, 0, new_vertex)));
	};
	const update_faces_edges_with_vertices = ({
		edges_vertices, faces_vertices, faces_edges,
	}, faces) => {
		const edge_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		faces
			.map(f => faces_vertices[f]
				.map((vertex, i, arr) => [vertex, arr[(i + 1) % arr.length]])
				.map(pair => edge_map[pair.join(" ")]))
			.forEach((edges, i) => { faces_edges[faces[i]] = edges; });
	};

	// const edges_shared_vertex = ({ edges_vertices }, e0, e1) => {
	//   const verts0 = edges_vertices[e0];
	//   const verts1 = edges_vertices[e1];
	//   if (verts0[0] === verts1[0]) { return verts0[0]; }
	//   if (verts0[0] === verts1[1]) { return verts0[0]; }
	//   if (verts0[1] === verts1[0]) { return verts0[1]; }
	//   if (verts0[1] === verts1[1]) { return verts0[1]; }
	//   console.error("edges_shared_vertex");
	// };
	// const sort_edges = ({ edges_vertices }, new_edges, three_edges) => {
	//   const prev_vertex = edges_shared_vertex({ edges_vertices }, three_edges[0], three_edges[1]);
	//   const next_vertex = edges_shared_vertex({ edges_vertices }, three_edges[1], three_edges[2]);
	//   console.log("prev_vertex", prev_vertex);
	//   console.log("next_vertex", next_vertex);
	//   console.log("edges_vertices[new_edges[0]]", edges_vertices[new_edges[0]]);
	//   console.log("edges_vertices[new_edges[1]]", edges_vertices[new_edges[1]]);
	//   if (edges_vertices[new_edges[0]].includes(prev_vertex)
	//     && edges_vertices[new_edges[1]].includes(next_vertex)) {
	//     return [new_edges[0], new_edges[1]];
	//   }
	//   if (edges_vertices[new_edges[1]].includes(prev_vertex)
	//     && edges_vertices[new_edges[0]].includes(next_vertex)) {
	//     return [new_edges[1], new_edges[0]];
	//   }
	//   console.error("sort_edges");
	// };
	// /**
	//  * @description a new vertex was added, splitting an edge. rebuild the
	//  * two incident faces by replacing the old edge with two new ones.
	//  * @param {object} FOLD object, modified in place
	//  * @param {number[]} indices of two faces to be rebuilt
	//  * @param {number} new vertex index
	//  * @param {number[]} indices of the two new edges
	//  * @param {number} old edge index
	//  */
	// export const update_faces_edges = ({ edges_vertices, faces_edges }, old_edge, new_vertex, new_edges, faces) => {
	//   // exit if we don't even have faces_edges
	//   if (!faces_edges) { return; }
	//   const splices = faces
	//     .map(f => {
	//     // .map(i => faces_edges[i])
	//     // .map((face, f) => {
	//       // in each face, find the index of the old edge in this faces_edges,
	//       // as well as the index of the prev and next edges.
	//       const splice_indices = faces_edges[f]
	//         .map((fe, i, arr) => fe === old_edge ? i : undefined)
	//         .filter(el => el !== undefined)
	//         .sort((a, b) => b - a)
	//       const splice_prev = splice_indices
	//         .map(i => (i + faces_edges[f].length - 1) % faces_edges[f].length);
	//       const splice_next = splice_indices
	//         .map(i => (i + 1) % faces_edges[f].length);
	//       // make these three consecutive splice indices into a tuple:
	//       // [prev, curr, next]
	//       const three_indices = splice_indices
	//         .map((curr, i) => [splice_prev[i], curr, splice_next[i]]);
	//       // convert these three indices into the edges they point to.
	//       const three_indices_edges = three_indices
	//         .map(tuple => tuple.map(i => faces_edges[f][i]));
	//       // figure out which order the two new faces need to be inserted.
	//       console.log("splice_indices", splice_indices);
	//       console.log("splice_prev", splice_prev);
	//       console.log("splice_next", splice_next);
	//       console.log("three_indices", three_indices);
	//       console.log("three_indices_edges", three_indices_edges);
	//       console.log("old edge vertices", edges_vertices[old_edge]);
	//       const sort_new_edges = three_indices_edges
	//         .map(three => sort_edges({ edges_vertices }, new_edges, three));
	//       console.log("sort_new_edges", sort_new_edges);
	//       return splice_indices.map((splice, i) => ({
	//         face_edges: faces_edges[f],
	//         splice,
	//         insert: sort_new_edges[i],
	//       }))
	//       // splice_indices
	//       //   .forEach((index, i) => face.splice(index, 1, sort_new_edges[i]));
	//       // .forEach(i => face.splice(i, 0, new_vertex))
	//     })
	//     .reduce((a, b) => a.concat(b), [])
	//     .sort((a, b) => b.splice - a.splice);

	//   console.log("splices", splices);
	//   splices
	//     .forEach(el => {
	//       el.face_edges.splice(el.splice, 1, ...el.insert);
	//       console.log("HERE", JSON.parse(JSON.stringify(el.face_edges)));
	//     });
	// };

	// export const update_faces_edges = ({ edges_vertices, faces_edges }, old_edge, new_vertex, new_edges, faces) => {
	//   // exit if we don't even have faces_edges
	//   if (!faces_edges) { return; }
	//   faces
	//     .map(i => faces_edges[i])
	//     .forEach((face) => {
	//       // there should be 2 faces in this array, incident to the removed edge
	//       // find the location of the removed edge in this face
	//       const edgeIndex = face.indexOf(old_edge);
	//       // the previous and next edge in this face, counter-clockwise
	//       const prevEdge = face[(edgeIndex + face.length - 1) % face.length];
	//       const nextEdge = face[(edgeIndex + 1) % face.length];
	//       const vertices = [
	//         [prevEdge, old_edge],
	//         [old_edge, nextEdge],
	//       ].map((pairs) => {
	//         const verts = pairs.map(e => edges_vertices[e]);
	//         return verts[0][0] === verts[1][0] || verts[0][0] === verts[1][1]
	//           ? verts[0][0] : verts[0][1];
	//       }).reduce((a, b) => a.concat(b), []);
	//       const edges = [
	//         [vertices[0], new_vertex],
	//         [new_vertex, vertices[1]],
	//       ].map((verts) => {
	//         const in0 = verts.map(v => edges_vertices[new_edges[0]].indexOf(v) !== -1)
	//           .reduce((a, b) => a && b, true);
	//         const in1 = verts.map(v => edges_vertices[new_edges[1]].indexOf(v) !== -1)
	//           .reduce((a, b) => a && b, true);
	//         if (in0) { return new_edges[0]; }
	//         if (in1) { return new_edges[1]; }
	//         throw new Error("splitEdge() bad faces_edges");
	//       });
	//       if (edgeIndex === face.length - 1) {
	//         // replacing the edge at the end of the array, we have to be careful
	//         // to put the first at the end, the second at the beginning
	//         face.splice(edgeIndex, 1, edges[0]);
	//         face.unshift(edges[1]);
	//       } else {
	//         face.splice(edgeIndex, 1, ...edges);
	//       }
	//       return edges;
	//     });
	// };

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description this does not modify the graph. it builds 2 objects with:
	 * { edges_vertices, edges_assignment, edges_foldAngle }
	 * including external to the spec: { edges_length, edges_vector }
	 * this does not rebuild edges_edges.
	 * @param {object} graph a FOLD object, modified in place
	 * @param {number} edge_index the index of the edge that will be split by the new vertex
	 * @param {number} new_vertex the index of the new vertex
	 * @returns {object[]} array of two edge objects, containing edge data as FOLD keys
	 */
	const splitEdgeIntoTwo = (graph, edge_index, new_vertex) => {
		const edge_vertices = graph.edges_vertices[edge_index];
		const new_edges = [
			{ edges_vertices: [edge_vertices[0], new_vertex] },
			{ edges_vertices: [new_vertex, edge_vertices[1]] },
		];
		new_edges.forEach(edge => [_edges_assignment, _edges_foldAngle]
			.filter(key => graph[key] && graph[key][edge_index] !== undefined)
			.forEach(key => { edge[key] = graph[key][edge_index]; }));
		return new_edges;
	};
	/**
	 * @description split an edge with a new vertex, replacing the old
	 * edge with two new edges sharing the common vertex. rebuilding:
	 * - vertices_coords, vertices_vertices, vertices_edges, vertices_faces,
	 * - edges_vertices, edges_faces, edges_assignment,
	 * - edges_foldAngle, edges_vector
	 * - faces_vertices, faces_edges,
	 * without rebuilding:
	 * - faces_faces
	 * todo: edgeOrders
	 * @usage requires edges_vertices to be defined
	 * @param {object} graph FOLD object, modified in place
	 * @param {number} old_edge index of old edge to be split
	 * @param {number[]} coords coordinates of the new vertex to be added. optional.
	 * if omitted, a vertex will be generated at the edge's midpoint.
	 * @param {number} [epsilon=1e-6] if an incident vertex is within this distance
	 * the function will not split the edge, simply return this vertex.
	 * @returns {object} a summary of the changes with keys "vertex", "edges"
	 * "vertex" is the index of the new vertex (or old index, if similar)
	 * "edge" is a summary of changes to edges, with "map" and "remove"
	 * @linkcode Origami ./src/graph/splitEdge/index.js 63
	 */
	const splitEdge = (graph, old_edge, coords, epsilon = EPSILON) => {
		// make sure old_edge is a valid index
		if (graph.edges_vertices.length < old_edge) { return {}; }
		const incident_vertices = graph.edges_vertices[old_edge];
		if (!coords) {
			coords = midpoint(...incident_vertices);
		}
		// test similarity with the incident vertices, if similar, return.
		const similar = incident_vertices
			.map(v => graph.vertices_coords[v])
			.map(vert => distance(vert, coords) < epsilon);
		if (similar[0]) { return { vertex: incident_vertices[0], edges: {} }; }
		if (similar[1]) { return { vertex: incident_vertices[1], edges: {} }; }
		// the new vertex will sit at the end of the array
		const vertex = graph.vertices_coords.length;
		graph.vertices_coords[vertex] = coords;
		// indices of new edges
		const new_edges = [0, 1].map(i => i + graph.edges_vertices.length);
		// create 2 new edges, add them to the graph
		splitEdgeIntoTwo(graph, old_edge, vertex)
			.forEach((edge, i) => Object.keys(edge)
				.forEach((key) => { graph[key][new_edges[i]] = edge[key]; }));
		// done with: vertices_coords, edges_vertices, edges_assignment, edges_foldAngle
		update_vertices_vertices$2(graph, vertex, incident_vertices);
		update_vertices_sectors(graph, vertex); // after vertices_vertices
		update_vertices_edges$2(graph, old_edge, vertex, incident_vertices, new_edges);
		// done with: vertices_edges, vertices_vertices, and
		// vertices_sectors if it exists.
		const incident_faces = findAdjacentFacesToEdge(graph, old_edge);
		if (incident_faces) {
			update_vertices_faces$1(graph, vertex, incident_faces);
			update_edges_faces$1(graph, new_edges, incident_faces);
			update_faces_vertices(graph, vertex, incident_vertices, incident_faces);
			update_faces_edges_with_vertices(graph, incident_faces);
			// update_faces_edges(graph, old_edge, vertex, new_edges, incident_faces);
		}
		// done with: vertices_faces, edges_faces, faces_vertices, faces_edges
		// and we don't need to bother with faces_faces and faceOrders.
		// todo: edgeOrders. the only spec key remaining.
		// remove old data
		const edge_map = removeGeometryIndices(graph, _edges, [old_edge]);
		// shift our new edge indices since these relate to the graph before remove().
		new_edges.forEach((_, i) => { new_edges[i] = edge_map[new_edges[i]]; });
		// we had to run "remove" with the new edges added. to return the change info,
		// we need to adjust the map to exclude these edges.
		edge_map.splice(-2);
		// replace the "undefined" in the map with the two new edge indices.
		edge_map[old_edge] = new_edges;
		return {
			vertex,
			edges: {
				map: edge_map,
				new: new_edges,
				remove: old_edge,
			},
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given two vertices and incident faces, create all new
	 * "edges_" entries to describe a new edge that sits between the params.
	 * @param {object} FOLD graph
	 * @param {number[]} two incident vertices that make up this edge
	 * @param {number[]} two edge-adjacent faces to this new edge
	 * @param {number[]} TEMPORARILY holds 2x the index of the face that
	 *  this edge currently lies inside, because the faces arrays will be
	 *  rebuilt from scratch, we need the old data.
	 * @returns {object} all FOLD spec "edges_" entries for this new edge.
	 */
	// const make_edge = ({ vertices_coords }, vertices, faces) => {
	const make_edge = ({ vertices_coords }, vertices, face) => {
		// coords reversed for "vector", so index [0] comes last in subtract
		const new_edge_coords = vertices
			.map(v => vertices_coords[v])
			.reverse();
		return {
			edges_vertices: [...vertices],
			edges_foldAngle: 0,
			edges_assignment: "U",
			edges_length: distance(...new_edge_coords),
			edges_vector: subtract(...new_edge_coords),
			edges_faces: [face, face],
		};
	};
	/**
	 *
	 */
	const rebuild_edge = (graph, face, vertices) => {
		// now that 2 vertices are in place, add a new edge between them.
		const edge = graph.edges_vertices.length;
		// construct data for our new edge (vertices, assignent, foldAngle...)
		// and the entry for edges_faces will be [x, x] where x is the index of
		// the old face, twice, and will be replaced later in this function.
		const new_edge = make_edge(graph, vertices, face);
		// ignoring any keys that aren't a part of our graph, add the new edge
		Object.keys(new_edge)
			.filter(key => graph[key] !== undefined)
			.forEach((key) => { graph[key][edge] = new_edge[key]; });
		return edge;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * this must be done AFTER edges_vertices has been updated with the new edge.
	 *
	 * @param {object} FOLD graph
	 * @param {number} the face that will be replaced by these 2 new
	 * @param {number[]} vertices (in the face) that split the face into 2 sides
	 */
	const make_faces = ({
		edges_vertices, faces_vertices, faces_edges,
	}, face, vertices) => {
		// the indices of the two vertices inside the face_vertices array.
		// this is where we will split the face into two.
		const indices = vertices.map(el => faces_vertices[face].indexOf(el));
		const faces = splitCircularArray(faces_vertices[face], indices)
			.map(fv => ({ faces_vertices: fv }));
		if (faces_edges) {
			// table to build faces_edges
			const vertices_to_edge = makeVerticesToEdgeBidirectional({ edges_vertices });
			faces
				.map(this_face => this_face.faces_vertices
					.map((fv, i, arr) => `${fv} ${arr[(i + 1) % arr.length]}`)
					.map(key => vertices_to_edge[key]))
				.forEach((face_edges, i) => { faces[i].faces_edges = face_edges; });
		}
		return faces;
	};
	/**
	 *
	 */
	const build_faces = (graph, face, vertices) => {
		// new face indices at the end of the list
		const faces = [0, 1].map(i => graph.faces_vertices.length + i);
		// construct new face data for faces_vertices, faces_edges
		// add them to the graph
		make_faces(graph, face, vertices)
			.forEach((newface, i) => Object.keys(newface)
				.forEach((key) => { graph[key][faces[i]] = newface[key]; }));
		return faces;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description this is a highly specific method, it takes in the output
	 * from intersectConvexFaceLine and applies it to a graph by splitting
	 * the edges (in the case of edge, not vertex intersection),
	 * @param {object} a FOLD object. modified in place.
	 * @param {object} the result from calling "intersectConvexFaceLine".
	 * each value must be an array. these will be modified in place.
	 * @returns {object} with "vertices" and "edges" keys where
	 * - vertices is an array of indices (the new vertices)
	 * - edges is an object with keys "map", the changes to edge array, and
	 * "remove", the indices of edges that have been removed.
	 * look inside of "map" at the indices from "removed" for the indices
	 * of the new edges which replaced them.
	 */
	const split_at_intersections = (graph, { vertices, edges }) => {
		// intersection will contain 2 items, either in "vertices" or "edges",
		// however we will split edges and store their new vertex in "vertices"
		// so in the end, "vertices" will contain 2 items.
		let map;
		// split the edge (modifying the graph), and store the changes so that during
		// the next loop the second edge to split will be updated to the new index
		const split_results = edges.map((el) => {
			const res = splitEdge(graph, map ? map[el.edge] : el.edge, el.coords);
			map = map ? mergeNextmaps(map, res.edges.map) : res.edges.map;
			return res;
		});
		vertices.push(...split_results.map(res => res.vertex));
		// if two edges were split, the second one contains a "remove" key that was
		// based on the mid-operation graph, update this value to match the graph
		// before any changes occurred.
		let bkmap;
		// todo: if we extend this to include non-convex polygons, this is the
		// only part of the code we need to test. cumulative backmap merge.
		// this was written without any testing, as convex polygons never have
		// more than 2 intersections
		split_results.forEach(res => {
			res.edges.remove = bkmap ? bkmap[res.edges.remove] : res.edges.remove;
			const inverted = invertSimpleMap(res.edges.map);
			bkmap = bkmap ? mergeBackmaps(bkmap, inverted) : inverted;
		});
		return {
			vertices,
			edges: {
				map,
				remove: split_results.map(res => res.edges.remove),
			},
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description a newly-added edge needs to update its two endpoints'
	 * vertices_vertices. each vertices_vertices gains one additional
	 * vertex, then the whole array is re-sorted counter-clockwise
	 * @param {object} FOLD object
	 * @param {number} index of the newly-added edge
	 */
	const update_vertices_vertices$1 = ({
		vertices_coords, vertices_vertices, edges_vertices,
	}, edge) => {
		const v0 = edges_vertices[edge][0];
		const v1 = edges_vertices[edge][1];
		vertices_vertices[v0] = sortVerticesCounterClockwise(
			{ vertices_coords },
			vertices_vertices[v0].concat(v1),
			v0,
		);
		vertices_vertices[v1] = sortVerticesCounterClockwise(
			{ vertices_coords },
			vertices_vertices[v1].concat(v0),
			v1,
		);
	};
	/**
	 * vertices_vertices was just run before this method. use it.
	 * vertices_edges should be up to date, except for the addition
	 * of this one new edge at both ends of
	 */
	const update_vertices_edges$1 = ({
		edges_vertices, vertices_edges, vertices_vertices,
	}, edge) => {
		// the expensive way, rebuild all arrays
		// graph.vertices_edges = makeVerticesEdges(graph);
		if (!vertices_edges || !vertices_vertices) { return; }
		const vertices = edges_vertices[edge];
		// for each of the two vertices, check its vertices_vertices for the
		// index of the opposite vertex. this is the edge. return its position
		// in the vertices_vertices to be used to insert into vertices_edges.
		vertices
			.map(v => vertices_vertices[v])
			.map((vert_vert, i) => vert_vert
				.indexOf(vertices[(i + 1) % vertices.length]))
			.forEach((radial_index, i) => vertices_edges[vertices[i]]
				.splice(radial_index, 0, edge));
	};
	/**
	 * @description search inside vertices_faces for an occurence
	 * of the removed face, determine which of our two new faces
	 * needs to be put in its place by checking faces_vertices
	 * by way of this map we build at the beginning.
	 */
	const update_vertices_faces = (graph, old_face, new_faces) => {
		// for each of the vertices (only the vertices involved in this split),
		// use the new faces_vertices data (built in the previous method) to get
		// a list of the new faces to be added to this vertex's vertices_faces.
		const vertices_replacement_faces = {};
		new_faces
			.forEach(f => graph.faces_vertices[f]
				.forEach(v => {
					if (!vertices_replacement_faces[v]) {
						vertices_replacement_faces[v] = [];
					}
					vertices_replacement_faces[v].push(f);
				}));
		// these vertices need updating
		graph.faces_vertices[old_face].forEach(v => {
			const index = graph.vertices_faces[v].indexOf(old_face);
			const replacements = vertices_replacement_faces[v];
			if (index === -1 || !replacements) {
				throw new Error(Messages$1.convexFace);
			}
			graph.vertices_faces[v].splice(index, 1, ...replacements);
		});
	};
	/**
	 * @description called near the end of the split_convex_face method.
	 * update the "edges_faces" array for every edge involved.
	 * figure out where the old_face's index is in each edges_faces array,
	 * figure out which of the new faces (or both) need to be added and
	 * substitute the old index with the new face's index/indices.
	 */
	const update_edges_faces = (graph, old_face, new_edge, new_faces) => {
		// for each of the edges (only the edges involved in this split),
		// use the new faces_edges data (built in the previous method) to get
		// a list of the new faces to be added to this edge's edges_faces.
		// most will be length of 1, except the edge which split the face will be 2.
		const edges_replacement_faces = {};
		new_faces
			.forEach(f => graph.faces_edges[f]
				.forEach(e => {
					if (!edges_replacement_faces[e]) { edges_replacement_faces[e] = []; }
					edges_replacement_faces[e].push(f);
				}));
		// these edges need updating
		const edges = [...graph.faces_edges[old_face], new_edge];
		edges.forEach(e => {
			// these are the faces which should be inserted into this edge's
			// edges_faces array, we just need to find the old index to replace.
			const replacements = edges_replacement_faces[e];
			// basically rewriting .indexOf(), but supporting multiple results.
			// these will be the indices containing a reference to the old face.
			const indices = [];
			for (let i = 0; i < graph.edges_faces[e].length; i += 1) {
				if (graph.edges_faces[e][i] === old_face) { indices.push(i); }
			}
			if (indices.length === 0 || !replacements) {
				throw new Error(Messages$1.convexFace);
			}
			// "indices" will most often be length 1, except for the one edge which
			// was added which splits the face in half. the previous methods which
			// did this gave that edge two references both to the same face, knowing
			// that here we will replace both references to the pair of the new
			// faces which the edge now divides.
			// remove the old indices.
			indices.reverse().forEach(index => graph.edges_faces[e].splice(index, 1));
			// in both cases when "indices" is length 1 or 2, get just one index
			// at which to insert the new reference(s).
			const index = indices[indices.length - 1];
			graph.edges_faces[e].splice(index, 0, ...replacements);
		});
	};
	/**
	 * @description one face was removed and two faces put in its place.
	 * regarding the faces_faces array, updates need to be made to the two
	 * new faces, as well as all the previously neighboring faces of
	 * the removed face.
	 */
	const update_faces_faces = ({ faces_vertices, faces_faces }, old_face, new_faces) => {
		// this is presuming that new_faces have their updated faces_vertices by now
		const incident_faces = faces_faces[old_face];
		const new_faces_vertices = new_faces.map(f => faces_vertices[f]);
		// for each of the incident faces (to the old face), set one of two
		// indices, one of the two new faces. this is the new incident face.
		const incident_face_face = incident_faces.map(f => {
			const incident_face_vertices = faces_vertices[f];
			const score = [0, 0];
			for (let n = 0; n < new_faces_vertices.length; n += 1) {
				let count = 0;
				for (let j = 0; j < incident_face_vertices.length; j += 1) {
					if (new_faces_vertices[n].indexOf(incident_face_vertices[j]) !== -1) {
						count += 1;
					}
				}
				score[n] = count;
			}
			if (score[0] >= 2) { return new_faces[0]; }
			if (score[1] >= 2) { return new_faces[1]; }
		});
		// prepare the new faces' face_faces empty arrays, filled with one
		// face, the opposite of the pair of the new faces.
		new_faces.forEach((f, i, arr) => {
			faces_faces[f] = [arr[(i + 1) % new_faces.length]];
		});
		// 2 things, fill the new face's arrays and update each of the
		// incident faces to point to the correct of the two new faces.
		incident_faces.forEach((f, i) => {
			for (let j = 0; j < faces_faces[f].length; j += 1) {
				if (faces_faces[f][j] === old_face) {
					faces_faces[f][j] = incident_face_face[i];
					faces_faces[incident_face_face[i]].push(f);
				}
			}
		});
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const signLine = () => 0;
	const signRay = (n, epsilon) => (n < -epsilon ? -1 : 0);
	const signSegment = (n, epsilon) => (n < -epsilon ? -1 : (n > 1 + epsilon ? 1 : 0));
	/**
	 * @description Given a line, does each face inclusively overlap the line?
	 * This takes a signFunc which will treat the line as a line/ray/segment.
	 * The algorithm establishes a coordinate system aligned with the line's
	 * vector, every vertex is filtered into three states per axis: -1, 0, 1,
	 * indicating -1/+1 on either side, and 0 meaning an overlap.
	 * Faces which overlap the line will include vertices which cross over
	 * sections, or lie inside the overlap area.
	 * This assumes that the faces of the graph are convex.
	 *
	 * behind left    |  overlap left   |  infront left
	 * --------------------------------------------------
	 * behind overlap | overlap overlap | infront overlap
	 * --------------------------------------------------
	 * behind right   |  overlap right  |  infront right
	 *
	 * where the line/segment/ray is inside the middle section:
	 *
	 *                |                 |
	 * --------------------------------------------------
	 *                |----the line---->|
	 * --------------------------------------------------
	 *                |                 |
	 */
	const facesLineTypeOverlap = (
		{ vertices_coords, faces_vertices },
		{ vector, origin },
		signFunc = signLine,
		epsilon = EPSILON,
	) => {
		const magSq = dot2(vector, vector);
		const unitVector = normalize2(vector);
		// for every vertex, which side (+1/-1) of the segment is the point?
		// if the point lies along the line within an epsilon it will be 0.
		const verticesCrossSide = vertices_coords
			.map(coord => subtract2(coord, origin))
			.map(vec => normalize2(vec))
			.map(vec => cross2(unitVector, vec))
			.map(s => (Math.abs(s) < epsilon ? 0 : Math.sign(s)));
		// for every vertex, project the point onto the line, scaled between 0 and 1
		// in relation to the line's vector. Then, convert this number into -1, 0, 1
		// where 0 means the projection lies between the endpoints, inclusive, and
		// -1 or +1 mean it's on either side of one of the endpoints.
		// this is irrelevant for infinite lines, all faces will be 0 (between endpoints).
		const verticesDotSide = vertices_coords
			.map(coord => subtract2(coord, origin))
			.map(vec => dot2(vec, vector))
			.map(dot => dot / magSq)
			.map(s => signFunc(s, epsilon));
		// for each face, if all of its vertices are on the same side,
		// then the face is considered "not overlapping" and will be "false".
		const crossSideOverlap = faces_vertices
			.map(fv => fv
				.map(v => verticesCrossSide[v])
				// are all vertices on the same side?
				.map((side, _, arr) => side === arr[0])
				.reduce((a, b) => a && b, true))
			// invert: are some vertices on different sides?
			.map(b => !b);
		// for each face, if all of its vertices are on the same side,
		// then the face is considered "not overlapping" and will be "false".
		const dotSideOverlap = faces_vertices
			.map(fv => fv
				.map(v => verticesDotSide[v])
				// are all vertices on the same side?
				.map((side, _, arr) => side === arr[0])
				.reduce((a, b) => a && b, true))
			// invert: are some vertices on different sides?
			.map(b => !b)
			// invert: are some vertices on different sides, OR, are all of them 0?
			.map((b, i) => b || verticesDotSide[faces_vertices[i][0]] === 0);
		// faces that might overlap are those that have an overlap in both axes.
		return faces_vertices
			.map((_, i) => i)
			.filter(i => crossSideOverlap[i] && dotSideOverlap[i]);
	};
	/**
	 * @description Given a line, does each face inclusively overlap the line?
	 * Note, this works by overlapping bounding boxes (line-aligned, not axis),
	 * so it will turn up some false positives, however the faces which are
	 * determined to not overlap definitely do not overlap.
	 * This includes faces that only touch the line with a collinear vertex.
	 * This assumes that the faces of the graph are convex.
	 * @param {FOLD} graph a FOLD graph
	 * @param {VecLine} line a line with a "vector" and "origin"
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[]} indices of the overlapping faces
	 * @linkcode
	 */
	const getFacesLineOverlap = (graph, { vector, origin }, epsilon = EPSILON) => (
		facesLineTypeOverlap(graph, { vector, origin }, signLine, epsilon)
	);
	/**
	 * @description Given a ray, does each face inclusively overlap the ray?
	 * Note, this works by overlapping bounding boxes (line-aligned, not axis),
	 * so it will turn up some false positives, however the faces which are
	 * determined to not overlap definitely do not overlap.
	 * This includes faces that only touch the line with a collinear vertex.
	 * This assumes that the faces of the graph are convex.
	 * @param {FOLD} graph a FOLD graph
	 * @param {VecLine} line a line with a "vector" and "origin"
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[]} indices of the overlapping faces
	 * @linkcode
	 */
	const getFacesRayOverlap = (graph, { vector, origin }, epsilon = EPSILON) => (
		facesLineTypeOverlap(graph, { vector, origin }, signRay, epsilon)
	);
	/**
	 * @description Given a segment, does each face inclusively overlap the segment?
	 * Note, this works by overlapping bounding boxes (line-aligned, not axis),
	 * so it will turn up some false positives, however the faces which are
	 * determined to not overlap definitely do not overlap.
	 * This includes faces that only touch the line with a collinear vertex.
	 * This assumes that the faces of the graph are convex.
	 * @param {FOLD} graph a FOLD graph
	 * @param {VecLine} line a line with a "vector" and "origin"
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[]} indices of the overlapping faces
	 * @linkcode
	 */
	const getFacesSegmentOverlap = (graph, segment, epsilon = EPSILON) => {
		const vector = subtract2(segment[1], segment[0]);
		const origin = segment[0];
		return facesLineTypeOverlap(graph, { vector, origin }, signSegment, epsilon);
	};
	/**
	 * @description intersect a convex face with a line and return the location
	 * of the intersections as components of the graph. this is an EXCLUSIVE
	 * intersection. line collinear to the edge counts as no intersection.
	 * there are 5 cases:
	 * - no intersection (undefined)
	 * - intersect one vertex (undefined)
	 * - intersect two vertices (valid, or undefined if neighbors)
	 * - intersect one vertex and one edge (valid)
	 * - intersect two edges (valid)
	 * @param {FOLD} graph a FOLD object
	 * @param {number} face the index of the face
	 * @param {number[]} vector the vector component describing the line
	 * @param {number[]} origin a point that lies along the line
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object|undefined} "vertices" and "edges" keys, indices of the
	 * components which intersect the line. or undefined if no intersection
	 * @linkcode Origami ./src/graph/intersect.js 162
	 */
	const intersectConvexFaceLine = ({
		vertices_coords, edges_vertices, faces_vertices, faces_edges,
	}, face, { vector, origin }, epsilon = EPSILON) => {
		// give us back the indices in the faces_vertices[face] array
		// we can count on these being sorted (important later)
		const face_vertices_indices = faces_vertices[face]
			.map(v => vertices_coords[v])
			.map(coord => overlapLinePoint({ vector, origin }, coord, () => true, epsilon))
			.map((overlap, i) => (overlap ? i : undefined))
			.filter(i => i !== undefined);
		// o-----o---o  we have to test against cases like this, where more than two
		// |         |  vertices lie along one line.
		// o---------o
		const vertices = face_vertices_indices.map(i => faces_vertices[face][i]);
		// concat a duplication of the array where the second array's vertices'
		// indices' are all increased by the faces_vertices[face].length.
		// ask every neighbor pair if they are 1 away from each other, if so, the line
		// lies along an outside edge of the convex poly, return "no intersection".
		// the concat is needed to detect neighbors across the end-beginning loop.
		const vertices_are_neighbors = face_vertices_indices
			.concat(face_vertices_indices.map(i => i + faces_vertices[face].length))
			.map((n, i, arr) => arr[i + 1] - n === 1)
			.reduce((a, b) => a || b, false);
		// if vertices are neighbors
		// because convex polygon, if collinear vertices lie along an edge,
		// it must be an outside edge. this case returns no intersection.
		if (vertices_are_neighbors) { return undefined; }
		if (vertices.length > 1) { return { vertices, edges: [] }; }
		// run the line-segment intersection on every side of the face polygon
		const edges = faces_edges[face]
			.map(edge => edges_vertices[edge]
				.map(v => vertices_coords[v]))
			.map(seg => intersectLineLine(
				{ vector, origin },
				{ vector: subtract2(seg[1], seg[0]), origin: seg[0] },
				includeL,
				excludeS,
				epsilon,
			)).map((coords, face_edge_index) => ({
				coords,
				edge: faces_edges[face][face_edge_index],
			}))
			// remove edges with no intersection
			.filter(el => el.coords !== undefined)
			// remove edges which share a vertex with a previously found vertex.
			// these edges are because the intersection is near a vertex but also
			// intersects the edge very close to the end.
			.filter(el => !(vertices
				.map(v => edges_vertices[el.edge].includes(v))
				.reduce((a, b) => a || b, false)));
		// only return the case with 2 intersections. for example, only 1 vertex
		// intersection implies outside the polygon, collinear with one vertex.
		return (edges.length + vertices.length === 2
			? { vertices, edges }
			: undefined);
	};

	var intersectFaces = /*#__PURE__*/Object.freeze({
		__proto__: null,
		facesLineTypeOverlap: facesLineTypeOverlap,
		getFacesLineOverlap: getFacesLineOverlap,
		getFacesRayOverlap: getFacesRayOverlap,
		getFacesSegmentOverlap: getFacesSegmentOverlap,
		intersectConvexFaceLine: intersectConvexFaceLine
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description divide a **convex** face into two polygons with a straight line cut.
	 * if the line ends exactly along existing vertices, they will be
	 * used, otherwise, new vertices will be added (splitting edges).
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @param {number} face index of face to split
	 * @param {VecLine} line with a "vector" and an "origin" component
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object|undefined} a summary of changes to the FOLD object,
	 *  or undefined if no change (no intersection).
	 * @linkcode Origami ./src/graph/splitFace/index.js 28
	 */
	const splitFace = (graph, face, line, epsilon) => {
		// survey face for any intersections which cross directly over a vertex
		const intersect = intersectConvexFaceLine(graph, face, line, epsilon);
		// if no intersection exists, return undefined.
		if (intersect === undefined) { return undefined; }
		// this result will be appended to (vertices, edges) and returned by this method.
		const result = split_at_intersections(graph, intersect);
		// this modifies the graph by only adding an edge between existing vertices
		result.edges.new = rebuild_edge(graph, face, result.vertices);
		// update all changes to vertices and edges (anything other than faces).
		update_vertices_vertices$1(graph, result.edges.new);
		update_vertices_edges$1(graph, result.edges.new);
		// done: vertices_coords, vertices_edges, vertices_vertices, edges_vertices
		// at this point the graph is once again technically valid, except
		// the face data is a little weird as one face is ignoring the newly-added
		// edge that cuts through it.
		const faces = build_faces(graph, face, result.vertices);
		// update all arrays having to do with face data
		update_vertices_faces(graph, face, faces);
		update_edges_faces(graph, face, result.edges.new, faces);
		update_faces_faces(graph, face, faces);
		// remove old data
		const faces_map = removeGeometryIndices(graph, _faces, [face]);
		// the graph is now complete, however our return object needs updating.
		// shift our new face indices since these relate to the graph before remove().
		faces.forEach((_, i) => { faces[i] = faces_map[faces[i]]; });
		// we had to run "remove" with the new faces added. to return the change info,
		// we need to adjust the map to exclude these faces.
		faces_map.splice(-2);
		// replace the "undefined" in the map with the two new edge indices.
		faces_map[face] = faces;
		result.faces = {
			map: faces_map,
			new: faces,
			remove: face,
		};
		return result;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given a self-relational array like faces_faces or
	 * vertices_vertices, and a list of indices with which to keep,
	 * copy the array so that only those elements found in "indices"
	 * are copied over, including the data in the inner most arrays.
	 * This will produce an array with holes.
	 * @param {number[][]} array_array a self-relational index array,
	 * such as "faces_faces".
	 * @param {number[]} indices a list of indices to keep.
	 * @returns {number[][]} a copy of the array_array but excluding
	 * all indices which were not included in the "indices" parameter set.
	 */
	const selfRelationalArraySubset = (array_array, indices) => {
		// quick lookup, is an index to be included?
		const hash = {};
		indices.forEach(f => { hash[f] = true; });
		// only include those faces which are in the group, both at
		// the top level and inside the inside reference arrays.
		const array_arraySubset = [];
		indices.forEach(i => {
			array_arraySubset[i] = array_array[i].filter(j => hash[j]);
		});
		return array_arraySubset;
	};
	/**
	 * @description Create a subgraph from a graph, with shallow pointers
	 * to arrays by providing a list of vertices, edges, and faces which
	 * will be carried over.
	 * The subgraph component arrays will contain holes, meaning the
	 * indices are preserved, making it useful for performing operations
	 * on a subgraph, then carrying that information back to the original.
	 * @param {FOLD} graph a FOLD graph
	 * @param {object} indices an object containing:
	 * { vertices: [], edges: [], faces: [] }
	 * all of which contains a list of indices to keep in the copied graph.
	 * the values can be integers or integer-strings, doesn't matter.
	 * @returns {FOLD} a shallow copy of the graph parameter provided.
	 */
	const subgraph = (graph, indices = {}) => {
		// allow user to only specify one or two; fill in the empty arrays.
		if (!indices.vertices) { indices.vertices = []; }
		if (!indices.edges) { indices.edges = []; }
		if (!indices.faces) { indices.faces = []; }

		const components = ["faces", "edges", "vertices"];
		// create a lookup which will be used when a component is a suffix
		// and we need to filter out elements which don't appear in other arrays
		const lookup = {};
		components.forEach(component => { lookup[component] = {}; });
		components.forEach(component => indices[component].forEach(i => {
			lookup[component][i] = true;
		}));
		// get all prefix arrays ("edges_") and suffix arrays ("_edges")
		// for all geometry component type.
		const keys = {};
		components.forEach(c => {
			filterKeysWithPrefix(graph, c).forEach(key => { keys[key] = {}; });
			filterKeysWithSuffix(graph, c).forEach(key => { keys[key] = {}; });
		});
		components.forEach(c => {
			filterKeysWithPrefix(graph, c).forEach(key => { keys[key].prefix = c; });
			filterKeysWithSuffix(graph, c).forEach(key => { keys[key].suffix = c; });
		});
		// shallow copy of the graph. excluding all geometry arrays.
		// this allows all metadata, including that which is unknown to
		// the spec to be carried over.
		const copy = { ...graph };
		// delete all graph data. only carry over metadata
		foldKeys.graph.forEach(key => delete copy[key]);
		delete copy.file_frames;
		// use prefixes and suffixes to make sure we initialize all
		// geometry array types. this even supports out of spec arrays,
		// like: faces_matrix, colors_edges...
		Object.keys(keys).forEach(key => { copy[key] = []; });
		Object.keys(keys).forEach(key => {
			const { prefix, suffix } = keys[key];
			// if prefix exists, filter outer array elements (creating holes)
			// if suffix exists, filter inner elements using the quick lookup
			if (prefix && suffix) {
				indices[prefix].forEach(i => {
					copy[key][i] = graph[key][i].filter(j => lookup[suffix][j]);
				});
			} else if (prefix) {
				indices[prefix].forEach(i => { copy[key][i] = graph[key][i]; });
			} else if (suffix) {
				copy[key] = graph[key].map(arr => arr.filter(j => lookup[suffix][j]));
			} else {
				copy[key] = graph[key];
			}
		});
		return copy;
	};
	/**
	 * @description Create a subgraph from a graph, with shallow pointers
	 * to arrays by providing a list of faces which will be carried over,
	 * and this list of faces will determine which vertices and edges
	 * get carried over as well.
	 * The subgraph component arrays will contain holes, meaning the
	 * indices are preserved, making it useful for performing operations
	 * on a subgraph, then carrying that information back to the original.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[]} faces a list of face indices which will
	 * be carried over into the subgraph.
	 * @returns {FOLD} a shallow copy of the graph parameter provided.
	 */
	const subgraphWithFaces = (graph, faces) => {
		// vertices will be take from one place:
		// - faces_vertices, every vertex involved in the subset of faces
		// there is no way to take it from edges_vertices, as edges_vertices
		// itself needs to be determined by this "vertices" array.
		let vertices = [];
		if (graph.faces_vertices) {
			vertices = uniqueSortedNumbers(
				faces.flatMap(f => graph.faces_vertices[f]),
			);
		}
		// edges will be taken from one of two places, either:
		// - faces edges, the edges involved in the subset of faces
		// - edges_vertices where BOTH vertices involved are in "vertices".
		// otherwise, no edges will be carried over.
		let edges = [];
		if (graph.faces_edges) {
			edges = uniqueSortedNumbers(
				faces.flatMap(f => graph.faces_edges[f]),
			);
		} else if (graph.edges_vertices) {
			const vertices_lookup = {};
			vertices.forEach(v => { vertices_lookup[v] = true; });
			edges = graph.edges_vertices
				.map((v, i) => (vertices_lookup[v[0]] && vertices_lookup[v[1]]
					? i
					: undefined))
				.filter(a => a !== undefined);
		}
		return subgraph(graph, {
			faces,
			edges,
			vertices,
		});
	};

	var subgraphMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		selfRelationalArraySubset: selfRelationalArraySubset,
		subgraph: subgraph,
		subgraphWithFaces: subgraphWithFaces
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// import getVerticesEdgesOverlap from "./vertices_edges_overlap";

	/**
	 * @description iterate over all graph cross-references between vertices,
	 * edges, and faces, and, instead of checking if each index exists,
	 * (which would be nice), do the faster operation of simply checking
	 * if the largest reference is out of bounds of the component array length.
	 * @returns {boolean} true if all references are valid within bounds.
	 */
	const validate_references = (graph) => {
		const counts = {
			vertices: count.vertices(graph),
			edges: count.edges(graph),
			faces: count.faces(graph),
		};
		const implied = {
			vertices: countImplied.vertices(graph),
			edges: countImplied.edges(graph),
			faces: countImplied.faces(graph),
		};
		return {
			vertices: counts.vertices >= implied.vertices,
			edges: counts.edges >= implied.edges,
			faces: counts.faces >= implied.faces,
		};
	};

	/**
	 * @description Validate a graph, get back a report on its duplicate/circular components.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a report on the validity state of the graph. a "summary" string,
	 * and "vertices" "edges" and "faces" information
	 * 
	 * todo: if creasePattern test if faces are counterclockwise
	 * 
	 * also, do that operation after an affine scale transform,
	 * since it's possible that that gets messed up.
	 * 
	 * @linkcode Origami ./src/graph/validate.js 47
	 */
	const validate = (graph, epsilon) => {
		const duplicate_edges = duplicateEdges(graph);
		const circular_edges = circularEdges(graph);
		const isolated_vertices = isolatedVertices(graph);
		const duplicate_vertices = duplicateVertices(graph, epsilon);
		const references = validate_references(graph);
		const is_perfect = duplicate_edges.length === 0
			&& circular_edges.length === 0
			&& isolated_vertices.length === 0
			&& references.vertices && references.edges && references.faces;
			// && more..?
		const summary = is_perfect ? "valid" : "problematic";
		return {
			summary,
			vertices: {
				isolated: isolated_vertices,
				duplicate: duplicate_vertices,
				references: references.vertices,
			},
			edges: {
				circular: circular_edges,
				duplicate: duplicate_edges,
				references: references.edges,
			},
			faces: {
				references: references.faces,
			},
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Make an axis-aligned bounding box that encloses the vertices of
	 * a FOLD object. the optional padding is used to make the bounding box
	 * inclusive / exclusive by adding padding on all sides, or inset in the case
	 * of negative number. (positive=inclusive boundary, negative=exclusive boundary)
	 * @param {FOLD} graph a FOLD graph
	 * @param {number?} padding an optional padding around the vertices
	 * to be included in the bounding box.
	 * @returns {BoundingBox?} dimensions stored as "span" "min" and "max".
	 * "undefined" if no vertices exist in the graph.
	 * @linkcode Origami ./src/graph/boundary.js 22
	 */
	const boundingBox = ({ vertices_coords }, padding) => (
		boundingBox$1(vertices_coords, padding)
	);
	/**
	 * @description For every vertex return a true if the vertex lies along a boundary
	 * edge, as defined by edges_assignment. If edges_assignment is not present,
	 * or does not contain boundary edges, this will return an empty array.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {number[]} unsorted list of vertex indices which lie along the boundary.
	 * @linkcode Origami ./src/graph/boundary.js 33
	 */
	const boundaryVertices = ({ edges_vertices, edges_assignment }) => (
		uniqueElements(edges_vertices
			.filter((_, i) => edges_assignment[i] === "B" || edges_assignment[i] === "b")
			.flat()));
	// export const boundaryVertices = ({ edges_vertices, edges_assignment }) => {
	// 	// assign vertices to a hash table to make sure they are unique.
	// 	const vertices = {};
	// 	edges_vertices.forEach((v, i) => {
	// 		const boundary = edges_assignment[i] === "B" || edges_assignment[i] === "b";
	// 		if (!boundary) { return; }
	// 		vertices[v[0]] = true;
	// 		vertices[v[1]] = true;
	// 	});
	// 	return Object.keys(vertices).map(str => parseInt(str));
	// };

	const emptyBoundaryObject = () => ({ vertices: [], edges: [], polygon: [] });
	/**
	 * @description Get the boundary of a FOLD graph in terms of both vertices and edges.
	 * This works by walking the boundary edges as defined by edges_assignment ("B" or "b").
	 * If edges_assignment doesn't exist, or contains errors, this will not work, and you
	 * will need the more robust algorithm planarBoundary() which walks the graph, but
	 * only works in 2D.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {object} with "vertices" and "edges" with arrays of indices.
	 * @linkcode Origami ./src/graph/boundary.js 60
	 */
	const boundary = ({ vertices_coords, vertices_edges, edges_vertices, edges_assignment }) => {
		if (!edges_assignment || !edges_vertices) { return emptyBoundaryObject(); }
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		const edges_vertices_b = edges_assignment
			.map(a => a === "B" || a === "b");
		const edge_walk = [];
		const vertex_walk = [];
		let edgeIndex = -1;
		for (let i = 0; i < edges_vertices_b.length; i += 1) {
			if (edges_vertices_b[i]) { edgeIndex = i; break; }
		}
		if (edgeIndex === -1) { return emptyBoundaryObject(); }
		edges_vertices_b[edgeIndex] = false;
		edge_walk.push(edgeIndex);
		vertex_walk.push(edges_vertices[edgeIndex][0]);
		let nextVertex = edges_vertices[edgeIndex][1];
		while (vertex_walk[0] !== nextVertex) {
			vertex_walk.push(nextVertex);
			edgeIndex = vertices_edges[nextVertex]
				.filter(v => edges_vertices_b[v])
				.shift();
			if (edgeIndex === undefined) { return emptyBoundaryObject(); }
			if (edges_vertices[edgeIndex][0] === nextVertex) {
				[, nextVertex] = edges_vertices[edgeIndex];
			} else {
				[nextVertex] = edges_vertices[edgeIndex];
			}
			edges_vertices_b[edgeIndex] = false;
			edge_walk.push(edgeIndex);
		}
		// if vertices_coords exist, create a "polygon" entry
		return {
			vertices: vertex_walk,
			edges: edge_walk,
			polygon: vertices_coords ? vertex_walk.map(v => vertices_coords[v]) : [],
		};
	};
	/**
	 * @description When a graph does not have boundary assignment information,
	 * this method is used to uncover the boundary, so long as the graph is planar.
	 * Get the boundary as two arrays of vertices and edges
	 * by walking the boundary edges in 2D and uncovering the concave hull.
	 * Does not consult edges_assignment, but does require vertices_coords.
	 * For repairing crease patterns, this will uncover boundary edges_assignments.
	 * @param {FOLD} graph a FOLD graph
	 * (vertices_coords, vertices_vertices, edges_vertices)
	 * (vertices edges only required in case vertices_vertices needs to be built)
	 * @returns {object} "vertices" and "edges" with arrays of indices.
	 * @usage call populate() before to ensure this works.
	 * @linkcode Origami ./src/graph/boundary.js 109
	 */
	const planarBoundary = ({
		vertices_coords, vertices_edges, vertices_vertices, edges_vertices,
	}, infiniteLoopProtection = true) => {
		if (!vertices_vertices) {
			vertices_vertices = makeVerticesVertices({ vertices_coords, vertices_edges, edges_vertices });
		}
		const edge_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		const edge_walk = [];
		const vertex_walk = [];
		const walk = {
			vertices: vertex_walk,
			edges: edge_walk,
		};

		let largestX = -Infinity;
		let first_vertex_i = -1;
		vertices_coords.forEach((v, i) => {
			if (v[0] > largestX) {
				largestX = v[0];
				first_vertex_i = i;
			}
		});

		if (first_vertex_i === -1) { return walk; }
		vertex_walk.push(first_vertex_i);
		const first_vc = vertices_coords[first_vertex_i];
		const first_neighbors = vertices_vertices[first_vertex_i];
		if (!first_neighbors) { return walk; }
		// sort adjacent vertices by next most clockwise vertex;
		const counter_clock_first_i = first_neighbors
			.map(i => vertices_coords[i])
			.map(vc => [vc[0] - first_vc[0], vc[1] - first_vc[1]])
			.map(vec => Math.atan2(vec[1], vec[0]))
			.map(angle => (angle < 0 ? angle + Math.PI * 2 : angle))
			.map((a, i) => ({ a, i }))
			.sort((a, b) => a.a - b.a)
			.shift()
			.i;
		const second_vertex_i = first_neighbors[counter_clock_first_i];
		// find this edge that connects these 2 vertices
		const first_edge_lookup = first_vertex_i < second_vertex_i
			? `${first_vertex_i} ${second_vertex_i}`
			: `${second_vertex_i} ${first_vertex_i}`;
		const first_edge = edge_map[first_edge_lookup];
		// vertex_walk.push(second_vertex_i);
		edge_walk.push(first_edge);

		// now we begin the loop

		// walking the graph, we look at 3 vertices at a time. in sequence:
		// prev_vertex, this_vertex, next_vertex
		let prev_vertex_i = first_vertex_i;
		let this_vertex_i = second_vertex_i;
		// because this is an infinite loop, and it relies on vertices_vertices
		// being well formed (if it was user-made, we cannot guarantee),
		// this loop protection will mod 1000 loops and check the duration.
		const start = performance.now();
		// 10 seconds. more than enough to verify something went wrong
		const MAX_DURATION = 10000;
		let count = 0;
		while (true) {
			const next_neighbors = vertices_vertices[this_vertex_i];
			const from_neighbor_i = next_neighbors.indexOf(prev_vertex_i);
			const next_neighbor_i = (from_neighbor_i + 1) % next_neighbors.length;
			const next_vertex_i = next_neighbors[next_neighbor_i];
			const next_edge_lookup = this_vertex_i < next_vertex_i
				? `${this_vertex_i} ${next_vertex_i}`
				: `${next_vertex_i} ${this_vertex_i}`;
			const next_edge_i = edge_map[next_edge_lookup];
			// exit loop condition
			if (next_edge_i === edge_walk[0]) {
				return walk;
			}
			vertex_walk.push(this_vertex_i);
			edge_walk.push(next_edge_i);
			prev_vertex_i = this_vertex_i;
			this_vertex_i = next_vertex_i;
			count += 1;
			// if loop protection is turned on, check elapsed time every 1000 loops
			// so that we reduce number of calls to the performance API.
			if (infiniteLoopProtection
				&& count % 1000 === 0
				&& performance.now() - start > MAX_DURATION) {
				throw new Error(Messages$1.planarBoundary);
			}
		}
	};

	var boundary$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		boundary: boundary,
		boundaryVertices: boundaryVertices,
		boundingBox: boundingBox,
		planarBoundary: planarBoundary
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @typedef FaceTreeNode
	 * @type {{ face: number, parent: number, edge_vertices: number[] }}
	 * @description A node in a tree specifically intended to map edge-
	 * connected faces.
	 * @property {number} face - the index of this face
	 * @property {number} parent - this face's parent node's face index
	 * @property {number[]} edge_vertices: the vertices that make up the
	 * edge connecting this face to the parent face.
	 */
	/**
	 * @description given two faces, get the vertices which are shared between the two faces.
	 * @param {number[]} face_a_vertices the faces_vertices entry for face A
	 * @param {number[]} face_b_vertices the faces_vertices entry for face B
	 * @returns {number[]} indices of vertices that are shared between faces maintaining
	 * the vertices in the same order as the winding order of face A.
	 * @linkcode Origami ./src/graph/faceSpanningTree.js 16
	 */
	// todo: this was throwing errors in the case of weird nonconvex faces with
	// single edges poking in. the "already_added" was added to fix this.
	// tbd if this fix covers all cases of weird polygons in a planar graph.
	const getFaceFaceSharedVertices = (face_a_vertices, face_b_vertices) => {
		// build a quick lookup table: T/F is a vertex in face B
		const hash = {};
		face_b_vertices.forEach((v) => { hash[v] = true; });
		// make a copy of face A containing T/F, if the vertex is shared in face B
		const match = face_a_vertices.map(v => !!hash[v]);
		// filter and keep only the shared vertices.
		const shared_vertices = [];
		const notShared = match.indexOf(false); // -1 if no match, code below still works
		// before we filter the array we just need to cover the special case that
		// the shared edge starts near the end of the array and wraps around
		const already_added = {};
		for (let i = notShared + 1; i < match.length; i += 1) {
			if (match[i] && !already_added[face_a_vertices[i]]) {
				shared_vertices.push(face_a_vertices[i]);
				already_added[face_a_vertices[i]] = true;
			}
		}
		for (let i = 0; i < notShared; i += 1) {
			if (match[i] && !already_added[face_a_vertices[i]]) {
				shared_vertices.push(face_a_vertices[i]);
				already_added[face_a_vertices[i]] = true;
			}
		}
		return shared_vertices;
	};

	// const getFaceFaceSharedVertices = (graph, face0, face1) => graph
	//   .faces_vertices[face0]
	//   .filter(v => graph.faces_vertices[face1].indexOf(v) !== -1)

	// each element will have
	// except for the first level. the root level has no reference to the
	// parent face, or the edge_vertices shared between them
	// root_face will become the root node
	/**
	 * @description Make a minimum spanning tree of a graph of edge-adjacent faces.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the face index to be the root node
	 * @returns {FaceTreeNode[][]} a tree arranged as an array containing
	 * arrays of FaceTreeNode. Each inner array contains all nodes at that
	 * depth (0, 1, 2...).
	 * @linkcode Origami ./src/graph/faceSpanningTree.js 59
	 */
	const makeFaceSpanningTree = ({ faces_vertices, faces_faces }, root_face = 0) => {
		if (!faces_faces) {
			faces_faces = makeFacesFaces({ faces_vertices });
		}
		if (faces_faces.length === 0) { return []; }

		const tree = [[{ face: root_face }]];
		const visited_faces = {};
		visited_faces[root_face] = true;
		do {
			// iterate the previous level's faces and gather their adjacent faces
			const next_level_with_duplicates = tree[tree.length - 1]
				.map(current => faces_faces[current.face]
					.map(face => ({ face, parent: current.face })))
				.reduce((a, b) => a.concat(b), []);
			// at this point its likely many faces are duplicated either because:
			// 1. they were already visited in previous levels
			// 2. the same face was adjacent to a few different faces from this step
			const dup_indices = {};
			next_level_with_duplicates.forEach((el, i) => {
				if (visited_faces[el.face]) { dup_indices[i] = true; }
				visited_faces[el.face] = true;
			});
			// unqiue set of next level faces
			const next_level = next_level_with_duplicates
				.filter((_, i) => !dup_indices[i]);
			// set next_level's edge_vertices
			// we cannot depend on faces being convex and only sharing 2 vertices in common.
			// if there are more than 2 edges, let's hope they are collinear.
			// either way, grab the first 2 vertices if there are more.
			next_level
				.map(el => getFaceFaceSharedVertices(
					faces_vertices[el.face],
					faces_vertices[el.parent],
				)).forEach((ev, i) => {
					const edge_vertices = ev.slice(0, 2);
					// const edgeKey = edge_vertices.join(" ");
					next_level[i].edge_vertices = edge_vertices;
					// next_level[i].edge = edge_map[edgeKey];
				});
			// append this next_level to the master tree
			tree[tree.length] = next_level;
		} while (tree[tree.length - 1].length > 0);
		if (tree.length > 0 && tree[tree.length - 1].length === 0) {
			tree.pop();
		}
		return tree;
	};

	var facesSpanningTree = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getFaceFaceSharedVertices: getFaceFaceSharedVertices,
		makeFaceSpanningTree: makeFaceSpanningTree
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given a FOLD object and a set of 2x3 matrices, one per face,
	 * "fold" the vertices by finding one matrix per vertex and multiplying them.
	 * @param {object} FOLD graph with vertices_coords, faces_vertices, and
	 * if vertices_faces does not exist it will be built.
	 * @param {number[][]} an array of 2x3 matrices. one per face.
	 * @returns {number[][]} a new set of vertices_coords, transformed.
	 * @linkcode Origami ./src/graph/facesMatrix.js 37
	 */
	const multiplyVerticesFacesMatrix2 = ({
		vertices_coords, vertices_faces, faces_vertices,
	}, faces_matrix) => {
		if (!vertices_faces) {
			vertices_faces = makeVerticesFaces({ faces_vertices });
		}
		const vertices_matrix = vertices_faces
			.map(faces => faces
				.filter(a => a != null)
				.shift())
			.map(face => (face === undefined
				? identity2x3
				: faces_matrix[face]));
		return vertices_coords
			.map((coord, i) => multiplyMatrix2Vector2(vertices_matrix[i], coord));
	};
	const unassigned_angle = { U: true, u: true };
	/**
	 * @description Create a transformation matrix for every face by virtually folding
	 * the graph along all of the creases (this works in 3D too). This traverses
	 * a face-adjacency tree (edge-adjacent faces) and recursively applies the
	 * affine transform that represents a fold across the edge between the faces.
	 * "flat" creases are ignored.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the index of the face that will remain in place
	 * @returns {number[][]} for every face, a 3x4 matrix (an array of 12 numbers).
	 * @linkcode Origami ./src/graph/facesMatrix.js 65
	 */
	// { vertices_coords, edges_vertices, edges_foldAngle, faces_vertices, faces_faces}
	const makeFacesMatrix = ({
		vertices_coords, edges_vertices, edges_foldAngle, edges_assignment, faces_vertices, faces_faces,
	}, root_face = 0) => {
		if (!edges_assignment && edges_foldAngle) {
			edges_assignment = makeEdgesAssignmentSimple({ edges_foldAngle });
		}
		if (!edges_foldAngle) {
			if (edges_assignment) {
				edges_foldAngle = makeEdgesFoldAngle({ edges_assignment });
			} else {
				// if no edges_foldAngle data exists, everyone gets identity matrix
				edges_foldAngle = Array(edges_vertices.length).fill(0);
			}
		}
		const edge_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		const faces_matrix = faces_vertices.map(() => identity3x4);
		makeFaceSpanningTree({ faces_vertices, faces_faces }, root_face)
			.slice(1) // remove the first level, it has no parent face
			.forEach(level => level
				.forEach((entry) => {
					const coords = entry.edge_vertices.map(v => vertices_coords[v]);
					const edgeKey = entry.edge_vertices.join(" ");
					const edge = edge_map[edgeKey];
					// if the assignment is unassigned, assume it is a flat fold.
					const foldAngle = unassigned_angle[edges_assignment[edge]]
						? Math.PI
						: (edges_foldAngle[edge] * Math.PI) / 180;
					const local_matrix = makeMatrix3Rotate(
						foldAngle, // rotation angle
						subtract(...resizeUp(coords[1], coords[0])), // line-vector
						coords[0], // line-origin
					);
					faces_matrix[entry.face] = multiplyMatrices3(faces_matrix[entry.parent], local_matrix);
					// to build the inverse matrix, switch these two parameters
					// .multiplyMatrices3(local_matrix, faces_matrix[entry.parent]);
				}));
		return faces_matrix;
	};
	/**
	 * @description This ignores any 3D data, and treats all creases as flat-folded.
	 * This will generate a 2D matrix for every face by virtually folding the graph
	 * at every edge according to the assignment or foldAngle.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the index of the face that will remain in place
	 * @returns {number[][]} for every face, a 2x3 matrix (an array of 6 numbers).
	 * @linkcode Origami ./src/graph/facesMatrix.js 141
	 */
	const makeFacesMatrix2 = ({
		vertices_coords, edges_vertices, edges_foldAngle, edges_assignment, faces_vertices, faces_faces,
	}, root_face = 0) => {
		if (!edges_foldAngle) {
			if (edges_assignment) {
				edges_foldAngle = makeEdgesFoldAngle({ edges_assignment });
			} else {
				// if no edges_foldAngle data exists, everyone gets identity matrix
				edges_foldAngle = Array(edges_vertices.length).fill(0);
			}
		}
		// However, if there is no edges_assignments, and we have to use edges_foldAngle,
		// the "unassigned" trick will no longer work, only +/- non zero numbers get
		// counted as folded edges (true).
		// For this reason, treating "unassigned" as a folded edge, this method's
		// functionality is better considered to be specific to makeFacesMatrix2,
		// instead of a generalized method.
		const edges_is_folded = makeEdgesIsFolded({ edges_vertices, edges_foldAngle, edges_assignment });
		const edge_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		const faces_matrix = faces_vertices.map(() => identity2x3);
		makeFaceSpanningTree({ faces_vertices, faces_faces }, root_face)
			.slice(1) // remove the first level, it has no parent face
			.forEach(level => level
				.forEach((entry) => {
					const coords = entry.edge_vertices.map(v => vertices_coords[v]);
					const edgeKey = entry.edge_vertices.join(" ");
					const edge = edge_map[edgeKey];
					const reflect_vector = subtract2(coords[1], coords[0]);
					const reflect_origin = coords[0];
					const local_matrix = edges_is_folded[edge]
						? makeMatrix2Reflect(reflect_vector, reflect_origin)
						: identity2x3;
					faces_matrix[entry.face] = multiplyMatrices2(faces_matrix[entry.parent], local_matrix);
					// to build the inverse matrix, switch these two parameters
					// .multiplyMatrices2(local_matrix, faces_matrix[entry.parent]);
				}));
		return faces_matrix;
	};

	var facesMatrix = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeFacesMatrix: makeFacesMatrix,
		makeFacesMatrix2: makeFacesMatrix2,
		multiplyVerticesFacesMatrix2: multiplyVerticesFacesMatrix2
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Fold a graph along its edges and return the position
	 * of the folded vertices. This method works in both 2D and 3D
	 * unassigned edges are treated as flat fold (mountain/valley 180deg)
	 * as a way of (assuming the user is giving a flat folded origami), help
	 * solve things about an origami that is currently being figured out.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the index of the face that will remain in place
	 * @returns {number[][]} a new set of `vertices_coords` with the new positions.
	 * @linkcode Origami ./src/graph/verticesCoordsFolded.js 36
	 */
	const makeVerticesCoordsFolded = ({
		vertices_coords, vertices_faces, edges_vertices, edges_foldAngle,
		edges_assignment, faces_vertices, faces_faces, faces_matrix,
	}, root_face) => {
		faces_matrix = makeFacesMatrix({
			vertices_coords, edges_vertices, edges_foldAngle, edges_assignment, faces_vertices, faces_faces,
		}, root_face);
		if (!vertices_faces) {
			vertices_faces = makeVerticesFaces({ faces_vertices });
		}
		// assign one matrix to every vertex from faces, identity matrix if none exist
		const vertices_matrix = vertices_faces
			.map(faces => faces
				.filter(a => a != null) // must filter "undefined" and "null"
				.shift()) // get any face from the list
			.map(face => (face === undefined
				? identity3x4
				: faces_matrix[face]));
		return vertices_coords
			.map(coord => resize(3, coord))
			.map((coord, i) => multiplyMatrix3Vector3(vertices_matrix[i], coord));
	};
	/**
	 * @description Fold a graph along its edges and return the position of the folded
	 * vertices. this method works for 2D only (no z value).
	 * if a edges_assignment is "U", assumed to be folded ("V" or "M").
	 * Finally, if no edge foldAngle or assignments exist, this method will
	 * assume all edges are flat-folded (except boundary) and will fold everything.
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} [root_face=0] the index of the face that will remain in place
	 * @returns {number[][]} a new set of `vertices_coords` with the new positions.
	 * @linkcode Origami ./src/graph/verticesCoordsFolded.js 69
	 */
	const makeVerticesCoordsFlatFolded = ({
		vertices_coords, edges_vertices, edges_foldAngle, edges_assignment, faces_vertices, faces_faces,
	}, root_face = 0) => {
		const edges_is_folded = makeEdgesIsFolded({ edges_vertices, edges_foldAngle, edges_assignment });
		const vertices_coords_folded = [];
		faces_vertices[root_face]
			.forEach(v => { vertices_coords_folded[v] = [...vertices_coords[v]]; });
		const faces_flipped = [];
		faces_flipped[root_face] = false;
		const edge_map = makeVerticesToEdgeBidirectional({ edges_vertices });
		makeFaceSpanningTree({ faces_vertices, faces_faces }, root_face)
			.slice(1) // remove the first level, it has no parent face
			.forEach(level => level
				.forEach(entry => {
					// coordinates and vectors of the reflecting edge
					const edge_key = entry.edge_vertices.join(" ");
					const edge = edge_map[edge_key];
					// build a basis axis using the folding edge, normalized.
					const coords = edges_vertices[edge].map(v => vertices_coords_folded[v]);
					if (coords[0] === undefined || coords[1] === undefined) { return; }
					const coords_cp = edges_vertices[edge].map(v => vertices_coords[v]);
					// the basis axis origin, x-basis axis (vector) and y-basis (normal)
					const origin_cp = coords_cp[0];
					const vector_cp = normalize2(subtract2(coords_cp[1], coords_cp[0]));
					const normal_cp = rotate90(vector_cp);
					// if we are crossing a flipping edge (m/v), set this face to be
					// flipped opposite of the parent face. otherwise keep it the same.
					faces_flipped[entry.face] = edges_is_folded[edge]
						? !faces_flipped[entry.parent]
						: faces_flipped[entry.parent];
					const vector_folded = normalize2(subtract2(coords[1], coords[0]));
					const origin_folded = coords[0];
					const normal_folded = faces_flipped[entry.face]
						? rotate270(vector_folded)
						: rotate90(vector_folded);
					// remaining_faces_vertices
					faces_vertices[entry.face]
						.filter(v => vertices_coords_folded[v] === undefined)
						.forEach(v => {
							const to_point = subtract2(vertices_coords[v], origin_cp);
							const project_norm = dot(to_point, normal_cp);
							const project_line = dot(to_point, vector_cp);
							const walk_up = scale2(vector_folded, project_line);
							const walk_perp = scale2(normal_folded, project_norm);
							const folded_coords = add2(add2(origin_folded, walk_up), walk_perp);
							vertices_coords_folded[v] = folded_coords;
						});
				}));
		return vertices_coords_folded;
	};

	var verticesFolded = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeVerticesCoordsFlatFolded: makeVerticesCoordsFlatFolded,
		makeVerticesCoordsFolded: makeVerticesCoordsFolded
	});

	/* svg (c) Kraft, MIT License */
	const str_class = "class";
	const str_function = "function";
	const str_undefined = "undefined";
	const str_boolean = "boolean";
	const str_number = "number";
	const str_string = "string";
	const str_object = "object";
	const str_svg = "svg";
	const str_path = "path";
	const str_id = "id";
	const str_style = "style";
	const str_viewBox = "viewBox";
	const str_transform = "transform";
	const str_points = "points";
	const str_stroke = "stroke";
	const str_fill = "fill";
	const str_none = "none";
	const str_arrow = "arrow";
	const str_head = "head";
	const str_tail = "tail";

	/* svg (c) Kraft, MIT License */

	const isBrowser = typeof window !== str_undefined
		&& typeof window.document !== str_undefined;
	typeof process !== str_undefined
		&& process.versions != null
		&& process.versions.node != null;

	/* svg (c) Kraft, MIT License */
	const Messages = {
		window: "window not set; svg.window = @xmldom/xmldom",
	};

	/* svg (c) Kraft, MIT License */

	const svgWindowContainer = { window: undefined };
	const buildHTMLDocument = (newWindow) => new newWindow.DOMParser()
		.parseFromString("<!DOCTYPE html><title>.</title>", "text/html");
	const setSVGWindow = (newWindow) => {
		if (!newWindow.document) { newWindow.document = buildHTMLDocument(newWindow); }
		svgWindowContainer.window = newWindow;
		return svgWindowContainer.window;
	};
	if (isBrowser) { svgWindowContainer.window = window; }
	const SVGWindow = () => {
		if (svgWindowContainer.window === undefined) {
			throw Messages.window;
		}
		return svgWindowContainer.window;
	};

	/* svg (c) Kraft, MIT License */
	const NS = "http://www.w3.org/2000/svg";

	/* svg (c) Kraft, MIT License */
	const classes_attributes = {
		presentation: [
			"color",
			"color-interpolation",
			"cursor",
			"direction",
			"display",
			"fill",
			"fill-opacity",
			"fill-rule",
			"font-family",
			"font-size",
			"font-size-adjust",
			"font-stretch",
			"font-style",
			"font-variant",
			"font-weight",
			"image-rendering",
			"letter-spacing",
			"opacity",
			"overflow",
			"paint-order",
			"pointer-events",
			"preserveAspectRatio",
			"shape-rendering",
			"stroke",
			"stroke-dasharray",
			"stroke-dashoffset",
			"stroke-linecap",
			"stroke-linejoin",
			"stroke-miterlimit",
			"stroke-opacity",
			"stroke-width",
			"tabindex",
			"transform-origin",
			"user-select",
			"vector-effect",
			"visibility",
		],
		animation: [
			"accumulate",
			"additive",
			"attributeName",
			"begin",
			"by",
			"calcMode",
			"dur",
			"end",
			"from",
			"keyPoints",
			"keySplines",
			"keyTimes",
			"max",
			"min",
			"repeatCount",
			"repeatDur",
			"restart",
			"to",
			"values",
		],
		effects: [
			"azimuth",
			"baseFrequency",
			"bias",
			"color-interpolation-filters",
			"diffuseConstant",
			"divisor",
			"edgeMode",
			"elevation",
			"exponent",
			"filter",
			"filterRes",
			"filterUnits",
			"flood-color",
			"flood-opacity",
			"in",
			"in2",
			"intercept",
			"k1",
			"k2",
			"k3",
			"k4",
			"kernelMatrix",
			"lighting-color",
			"limitingConeAngle",
			"mode",
			"numOctaves",
			"operator",
			"order",
			"pointsAtX",
			"pointsAtY",
			"pointsAtZ",
			"preserveAlpha",
			"primitiveUnits",
			"radius",
			"result",
			"seed",
			"specularConstant",
			"specularExponent",
			"stdDeviation",
			"stitchTiles",
			"surfaceScale",
			"targetX",
			"targetY",
			"type",
			"xChannelSelector",
			"yChannelSelector",
		],
		text: [
			"dx",
			"dy",
			"alignment-baseline",
			"baseline-shift",
			"dominant-baseline",
			"lengthAdjust",
			"method",
			"overline-position",
			"overline-thickness",
			"rotate",
			"spacing",
			"startOffset",
			"strikethrough-position",
			"strikethrough-thickness",
			"text-anchor",
			"text-decoration",
			"text-rendering",
			"textLength",
			"underline-position",
			"underline-thickness",
			"word-spacing",
			"writing-mode",
		],
		gradient: [
			"gradientTransform",
			"gradientUnits",
			"spreadMethod",
		],
	};

	/* svg (c) Kraft, MIT License */
	const classes_nodes = {
		svg: [
			"svg",
		],
		defs: [
			"defs",
		],
		header: [
			"desc",
			"filter",
			"metadata",
			"style",
			"script",
			"title",
			"view",
		],
		cdata: [
			"cdata",
		],
		group: [
			"g",
		],
		visible: [
			"circle",
			"ellipse",
			"line",
			"path",
			"polygon",
			"polyline",
			"rect",
			"arc",
			"arrow",
			"curve",
			"parabola",
			"roundRect",
			"wedge",
			"origami",
		],
		text: [
			"text",
		],
		invisible: [
			"marker",
			"symbol",
			"clipPath",
			"mask",
		],
		patterns: [
			"linearGradient",
			"radialGradient",
			"pattern",
		],
		childrenOfText: [
			"textPath",
			"tspan",
		],
		gradients: [
			"stop",
		],
		filter: [
			"feBlend",
			"feColorMatrix",
			"feComponentTransfer",
			"feComposite",
			"feConvolveMatrix",
			"feDiffuseLighting",
			"feDisplacementMap",
			"feDistantLight",
			"feDropShadow",
			"feFlood",
			"feFuncA",
			"feFuncB",
			"feFuncG",
			"feFuncR",
			"feGaussianBlur",
			"feImage",
			"feMerge",
			"feMergeNode",
			"feMorphology",
			"feOffset",
			"fePointLight",
			"feSpecularLighting",
			"feSpotLight",
			"feTile",
			"feTurbulence",
		],
	};

	/* svg (c) Kraft, MIT License */

	const nodes_attributes = {
		svg: [str_viewBox],
		line: ["x1", "y1", "x2", "y2"],
		rect: ["x", "y", "width", "height"],
		circle: ["cx", "cy", "r"],
		ellipse: ["cx", "cy", "rx", "ry"],
		polygon: [str_points],
		polyline: [str_points],
		path: ["d"],
		text: ["x", "y"],
		mask: [str_id],
		symbol: [str_id],
		clipPath: [str_id, "clip-rule"],
		marker: [
			str_id,
			"markerHeight",
			"markerUnits",
			"markerWidth",
			"orient",
			"refX",
			"refY",
		],
		linearGradient: ["x1", "x2", "y1", "y2"],
		radialGradient: ["cx", "cy", "r", "fr", "fx", "fy"],
		stop: ["offset", "stop-color", "stop-opacity"],
		pattern: ["patternContentUnits", "patternTransform", "patternUnits"],
	};
	const additionalNodeAttributes = [{
		nodes: [str_svg, "defs", "g"].concat(classes_nodes.visible, classes_nodes.text),
		attr: classes_attributes.presentation,
	}, {
		nodes: ["filter"],
		attr: classes_attributes.effects,
	}, {
		nodes: classes_nodes.childrenOfText.concat("text"),
		attr: classes_attributes.text,
	}, {
		nodes: classes_nodes.filter,
		attr: classes_attributes.effects,
	}, {
		nodes: classes_nodes.gradients,
		attr: classes_attributes.gradient,
	}];
	additionalNodeAttributes
		.forEach(el => el.nodes
			.forEach(nodeName => {
				if (!nodes_attributes[nodeName]) { nodes_attributes[nodeName] = []; }
				nodes_attributes[nodeName].push(...el.attr);
			}));

	/* svg (c) Kraft, MIT License */

	const headerStuff = [
		classes_nodes.header,
		classes_nodes.invisible,
		classes_nodes.patterns,
	].flat();
	const drawingShapes = [
		classes_nodes.group,
		classes_nodes.visible,
		classes_nodes.text,
	].flat();
	const nodes_children = {
		svg: [["svg", "defs"], headerStuff, drawingShapes].flat(),
		defs: headerStuff,
		filter: classes_nodes.filter,
		g: drawingShapes,
		text: classes_nodes.childrenOfText,
		marker: drawingShapes,
		symbol: drawingShapes,
		clipPath: drawingShapes,
		mask: drawingShapes,
		linearGradient: classes_nodes.gradients,
		radialGradient: classes_nodes.gradients,
	};

	/* svg (c) Kraft, MIT License */

	const nodeNames = Object.values(classes_nodes).flat();

	/* svg (c) Kraft, MIT License */
	const cssColors = {
		black: "#000000",
		silver: "#c0c0c0",
		gray: "#808080",
		white: "#ffffff",
		maroon: "#800000",
		red: "#ff0000",
		purple: "#800080",
		fuchsia: "#ff00ff",
		green: "#008000",
		lime: "#00ff00",
		olive: "#808000",
		yellow: "#ffff00",
		navy: "#000080",
		blue: "#0000ff",
		teal: "#008080",
		aqua: "#00ffff",
		orange: "#ffa500",
		aliceblue: "#f0f8ff",
		antiquewhite: "#faebd7",
		aquamarine: "#7fffd4",
		azure: "#f0ffff",
		beige: "#f5f5dc",
		bisque: "#ffe4c4",
		blanchedalmond: "#ffebcd",
		blueviolet: "#8a2be2",
		brown: "#a52a2a",
		burlywood: "#deb887",
		cadetblue: "#5f9ea0",
		chartreuse: "#7fff00",
		chocolate: "#d2691e",
		coral: "#ff7f50",
		cornflowerblue: "#6495ed",
		cornsilk: "#fff8dc",
		crimson: "#dc143c",
		cyan: "#00ffff",
		darkblue: "#00008b",
		darkcyan: "#008b8b",
		darkgoldenrod: "#b8860b",
		darkgray: "#a9a9a9",
		darkgreen: "#006400",
		darkgrey: "#a9a9a9",
		darkkhaki: "#bdb76b",
		darkmagenta: "#8b008b",
		darkolivegreen: "#556b2f",
		darkorange: "#ff8c00",
		darkorchid: "#9932cc",
		darkred: "#8b0000",
		darksalmon: "#e9967a",
		darkseagreen: "#8fbc8f",
		darkslateblue: "#483d8b",
		darkslategray: "#2f4f4f",
		darkslategrey: "#2f4f4f",
		darkturquoise: "#00ced1",
		darkviolet: "#9400d3",
		deeppink: "#ff1493",
		deepskyblue: "#00bfff",
		dimgray: "#696969",
		dimgrey: "#696969",
		dodgerblue: "#1e90ff",
		firebrick: "#b22222",
		floralwhite: "#fffaf0",
		forestgreen: "#228b22",
		gainsboro: "#dcdcdc",
		ghostwhite: "#f8f8ff",
		gold: "#ffd700",
		goldenrod: "#daa520",
		greenyellow: "#adff2f",
		grey: "#808080",
		honeydew: "#f0fff0",
		hotpink: "#ff69b4",
		indianred: "#cd5c5c",
		indigo: "#4b0082",
		ivory: "#fffff0",
		khaki: "#f0e68c",
		lavender: "#e6e6fa",
		lavenderblush: "#fff0f5",
		lawngreen: "#7cfc00",
		lemonchiffon: "#fffacd",
		lightblue: "#add8e6",
		lightcoral: "#f08080",
		lightcyan: "#e0ffff",
		lightgoldenrodyellow: "#fafad2",
		lightgray: "#d3d3d3",
		lightgreen: "#90ee90",
		lightgrey: "#d3d3d3",
		lightpink: "#ffb6c1",
		lightsalmon: "#ffa07a",
		lightseagreen: "#20b2aa",
		lightskyblue: "#87cefa",
		lightslategray: "#778899",
		lightslategrey: "#778899",
		lightsteelblue: "#b0c4de",
		lightyellow: "#ffffe0",
		limegreen: "#32cd32",
		linen: "#faf0e6",
		magenta: "#ff00ff",
		mediumaquamarine: "#66cdaa",
		mediumblue: "#0000cd",
		mediumorchid: "#ba55d3",
		mediumpurple: "#9370db",
		mediumseagreen: "#3cb371",
		mediumslateblue: "#7b68ee",
		mediumspringgreen: "#00fa9a",
		mediumturquoise: "#48d1cc",
		mediumvioletred: "#c71585",
		midnightblue: "#191970",
		mintcream: "#f5fffa",
		mistyrose: "#ffe4e1",
		moccasin: "#ffe4b5",
		navajowhite: "#ffdead",
		oldlace: "#fdf5e6",
		olivedrab: "#6b8e23",
		orangered: "#ff4500",
		orchid: "#da70d6",
		palegoldenrod: "#eee8aa",
		palegreen: "#98fb98",
		paleturquoise: "#afeeee",
		palevioletred: "#db7093",
		papayawhip: "#ffefd5",
		peachpuff: "#ffdab9",
		peru: "#cd853f",
		pink: "#ffc0cb",
		plum: "#dda0dd",
		powderblue: "#b0e0e6",
		rosybrown: "#bc8f8f",
		royalblue: "#4169e1",
		saddlebrown: "#8b4513",
		salmon: "#fa8072",
		sandybrown: "#f4a460",
		seagreen: "#2e8b57",
		seashell: "#fff5ee",
		sienna: "#a0522d",
		skyblue: "#87ceeb",
		slateblue: "#6a5acd",
		slategray: "#708090",
		slategrey: "#708090",
		snow: "#fffafa",
		springgreen: "#00ff7f",
		steelblue: "#4682b4",
		tan: "#d2b48c",
		thistle: "#d8bfd8",
		tomato: "#ff6347",
		turquoise: "#40e0d0",
		violet: "#ee82ee",
		wheat: "#f5deb3",
		whitesmoke: "#f5f5f5",
		yellowgreen: "#9acd32",
	};

	/* svg (c) Kraft, MIT License */
	const hslToRgb = (hue, saturation, lightness) => {
		const s = saturation / 100;
		const l = lightness / 100;
		const k = n => (n + hue / 30) % 12;
		const a = s * Math.min(l, 1 - l);
		const f = n => (
			l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)))
		);
		return [f(0) * 255, f(8) * 255, f(4) * 255];
	};
	const mapHexNumbers = (numbers, map) => {
		const chars = Array.from(Array(map.length))
			.map((_, i) => numbers[i] || "0");
		return numbers.length <= 4
			? map.map(i => chars[i]).join("")
			: chars.join("");
	};
	const hexToRgb = (string) => {
		const numbers = string.replace(/#(?=\S)/g, "");
		const hasAlpha = numbers.length === 4 || numbers.length === 8;
		const hexString = hasAlpha
			? mapHexNumbers(numbers, [0, 0, 1, 1, 2, 2, 3, 3])
			: mapHexNumbers(numbers, [0, 0, 1, 1, 2, 2]);
		const c = parseInt(hexString, 16);
		return hasAlpha
			? [(c >> 24) & 255, (c >> 16) & 255, (c >> 8) & 255, c & 255]
			: [(c >> 16) & 255, (c >> 8) & 255, c & 255];
	};
	const rgbToHex = (red, green, blue, alpha) => {
		const to16 = n => `00${Math.max(0, Math.min(Math.round(n), 255)).toString(16)}`
			.slice(-2);
		const hex = `#${[red, green, blue].map(to16).join("")}`;
		return alpha === undefined
			? hex
			: `${hex}${to16(alpha * 255)}`;
	};

	var convert$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		hexToRgb: hexToRgb,
		hslToRgb: hslToRgb,
		rgbToHex: rgbToHex
	});

	/* svg (c) Kraft, MIT License */

	const getParenNumbers = str => {
		const match = str.match(/\(([^\)]+)\)/g);
		if (match == null || !match.length) { return []; }
		return match[0]
			.substring(1, match[0].length - 1)
			.split(/[\s,]+/)
			.map(parseFloat);
	};
	const parseColorToRgb = (string) => {
		if (cssColors[string]) { return hexToRgb(cssColors[string]); }
		if (string[0] === "#") { return hexToRgb(string); }
		if (string.substring(0, 4) === "rgba"
			|| string.substring(0, 3) === "rgb") {
			const values = getParenNumbers(string);
			[0, 1, 2]
				.filter(i => values[i] === undefined)
				.forEach(i => { values[i] = 0; });
			return values;
		}
		if (string.substring(0, 4) === "hsla"
			|| string.substring(0, 3) === "hsl") {
			const values = getParenNumbers(string);
			[0, 1, 2]
				.filter(i => values[i] === undefined)
				.forEach(i => { values[i] = 0; });
			const rgb = hslToRgb(...values);
			if (values.length === 4) { rgb.push(values[3]); }
			return rgb;
		}
		return undefined;
	};
	const parseColorToHex = (string) => {
		if (cssColors[string]) { return cssColors[string].toUpperCase(); }
		if (string[0] === "#") { return rgbToHex(...hexToRgb(string)); }
		if (string.substring(0, 4) === "rgba"
			|| string.substring(0, 3) === "rgb") {
			return rgbToHex(...getParenNumbers(string));
		}
		if (string.substring(0, 4) === "hsla"
			|| string.substring(0, 3) === "hsl") {
			const values = getParenNumbers(string);
			[0, 1, 2]
				.filter(i => values[i] === undefined)
				.forEach(i => { values[i] = 0; });
			const rgb = hslToRgb(...values);
			if (values.length === 4) { rgb.push(values[3]); }
			[0, 1, 2].forEach(i => { rgb[i] *= 255; });
			rgbToHex(...rgb);
		}
		return undefined;
	};

	var parseColor = /*#__PURE__*/Object.freeze({
		__proto__: null,
		parseColorToHex: parseColorToHex,
		parseColorToRgb: parseColorToRgb
	});

	/* svg (c) Kraft, MIT License */

	const colors = {
		cssColors,
		...convert$1,
		...parseColor,
	};

	/* svg (c) Kraft, MIT License */
	const svg_add2 = (a, b) => [a[0] + b[0], a[1] + b[1]];
	const svg_sub2 = (a, b) => [a[0] - b[0], a[1] - b[1]];
	const svg_scale2 = (a, s) => [a[0] * s, a[1] * s];
	const svg_magnitudeSq2 = (a) => (a[0] ** 2) + (a[1] ** 2);
	const svg_magnitude2 = (a) => Math.sqrt(svg_magnitudeSq2(a));
	const svg_distanceSq2 = (a, b) => svg_magnitudeSq2(svg_sub2(a, b));
	const svg_distance2 = (a, b) => Math.sqrt(svg_distanceSq2(a, b));
	const svg_polar_to_cart = (a, d) => [Math.cos(a) * d, Math.sin(a) * d];
	const svg_multiplyMatrices2 = (m1, m2) => [
		m1[0] * m2[0] + m1[2] * m2[1],
		m1[1] * m2[0] + m1[3] * m2[1],
		m1[0] * m2[2] + m1[2] * m2[3],
		m1[1] * m2[2] + m1[3] * m2[3],
		m1[0] * m2[4] + m1[2] * m2[5] + m1[4],
		m1[1] * m2[4] + m1[3] * m2[5] + m1[5],
	];

	var algebra$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		svg_add2: svg_add2,
		svg_distance2: svg_distance2,
		svg_distanceSq2: svg_distanceSq2,
		svg_magnitude2: svg_magnitude2,
		svg_magnitudeSq2: svg_magnitudeSq2,
		svg_multiplyMatrices2: svg_multiplyMatrices2,
		svg_polar_to_cart: svg_polar_to_cart,
		svg_scale2: svg_scale2,
		svg_sub2: svg_sub2
	});

	/* svg (c) Kraft, MIT License */

	const parseTransform = function (transform) {
		const parsed = transform.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?\s*)+\))+/g);
		if (!parsed) { return []; }
		const listForm = parsed.map(a => a.match(/[\w\.\-]+/g));
		return listForm.map(a => ({
			transform: a.shift(),
			parameters: a.map(p => parseFloat(p)),
		}));
	};
	const matrixFormTranslate = function (params) {
		switch (params.length) {
		case 1: return [1, 0, 0, 1, params[0], 0];
		case 2: return [1, 0, 0, 1, params[0], params[1]];
		default: console.warn(`improper translate, ${params}`);
		}
		return undefined;
	};
	const matrixFormRotate = function (params) {
		const cos_p = Math.cos(params[0] / (180 * Math.PI));
		const sin_p = Math.sin(params[0] / (180 * Math.PI));
		switch (params.length) {
		case 1: return [cos_p, sin_p, -sin_p, cos_p, 0, 0];
		case 3: return [cos_p, sin_p, -sin_p, cos_p,
			-params[1] * cos_p + params[2] * sin_p + params[1],
			-params[1] * sin_p - params[2] * cos_p + params[2]];
		default: console.warn(`improper rotate, ${params}`);
		}
		return undefined;
	};
	const matrixFormScale = function (params) {
		switch (params.length) {
		case 1: return [params[0], 0, 0, params[0], 0, 0];
		case 2: return [params[0], 0, 0, params[1], 0, 0];
		default: console.warn(`improper scale, ${params}`);
		}
		return undefined;
	};
	const matrixFormSkewX = function (params) {
		return [1, 0, Math.tan(params[0] / (180 * Math.PI)), 1, 0, 0];
	};
	const matrixFormSkewY = function (params) {
		return [1, Math.tan(params[0] / (180 * Math.PI)), 0, 1, 0, 0];
	};
	const matrixForm = function (transformType, params) {
		switch (transformType) {
		case "translate": return matrixFormTranslate(params);
		case "rotate": return matrixFormRotate(params);
		case "scale": return matrixFormScale(params);
		case "skewX": return matrixFormSkewX(params);
		case "skewY": return matrixFormSkewY(params);
		case "matrix": return params;
		default: console.warn(`unknown transform type ${transformType}`);
		}
		return undefined;
	};
	const transformStringToMatrix = function (string) {
		return parseTransform(string)
			.map(el => matrixForm(el.transform, el.parameters))
			.filter(a => a !== undefined)
			.reduce((a, b) => svg_multiplyMatrices2(a, b), [1, 0, 0, 1, 0, 0]);
	};

	var transforms = /*#__PURE__*/Object.freeze({
		__proto__: null,
		transformStringToMatrix: transformStringToMatrix
	});

	/* svg (c) Kraft, MIT License */

	const xmlStringToElement = (input, mimeType = "text/xml") => {
		const result = (new (SVGWindow().DOMParser)()).parseFromString(input, mimeType);
		return result ? result.documentElement : null;
	};
	const getRootParent = (el) => {
		let parent = el;
		while (parent.parentNode != null) {
			parent = parent.parentNode;
		}
		return parent;
	};
	const findElementTypeInParents = (element, nodeName) => {
		if ((element.nodeName || "") === nodeName) {
			return element;
		}
		return element.parentNode
			? findElementTypeInParents(element.parentNode, nodeName)
			: undefined;
	};
	const polyfillClassListAdd = (el, ...classes) => {
		const hash = {};
		const getClass = el.getAttribute("class");
		const classArray = getClass ? getClass.split(" ") : [];
		classArray.push(...classes);
		classArray.forEach(str => { hash[str] = true; });
		const classString = Object.keys(hash).join(" ");
		el.setAttribute("class", classString);
	};
	const addClass = (el, ...classes) => {
		if (!el || !classes.length) { return undefined; }
		return el.classList
			? el.classList.add(...classes)
			: polyfillClassListAdd(el, ...classes);
	};
	const flattenDomTree = (el) => (el.children == null || !el.children.length
		? [el]
		: Array.from(el.children)
			.flatMap(child => flattenDomTree(child)));
	const nodeSpecificAttrs = {
		svg: ["viewBox", "xmlns", "version"],
		line: ["x1", "y1", "x2", "y2"],
		rect: ["x", "y", "width", "height"],
		circle: ["cx", "cy", "r"],
		ellipse: ["cx", "cy", "rx", "ry"],
		polygon: ["points"],
		polyline: ["points"],
		path: ["d"],
	};
	const getAttributes = element => {
		const attributes = Array.from(element.attributes);
		return nodeSpecificAttrs[element.nodeName]
			? attributes
				.filter(a => !nodeSpecificAttrs[element.nodeName].includes(a.name))
			: attributes;
	};
	const objectifyAttributes = (list) => {
		const obj = {};
		list.forEach((a) => { obj[a.nodeName] = a.value; });
		return obj;
	};
	const attrAssign = (parentAttrs, element) => {
		const attrs = objectifyAttributes(getAttributes(element));
		if (!attrs.transform && !parentAttrs.transform) {
			return { ...parentAttrs, ...attrs };
		}
		const elemTransform = attrs.transform || "";
		const parentTransform = parentAttrs.transform || "";
		const elemMatrix = transformStringToMatrix(elemTransform);
		const parentMatrix = transformStringToMatrix(parentTransform);
		const matrix = svg_multiplyMatrices2(parentMatrix, elemMatrix);
		const transform = `matrix(${matrix.join(", ")})`;
		return { ...parentAttrs, ...attrs, transform };
	};
	const flattenDomTreeWithStyle = (element, attributes = {}) => (
		element.children == null || !element.children.length
			? [{ element, attributes }]
			: Array.from(element.children)
				.flatMap(child => flattenDomTreeWithStyle(child, attrAssign(attributes, child)))
	);

	var dom$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		addClass: addClass,
		findElementTypeInParents: findElementTypeInParents,
		flattenDomTree: flattenDomTree,
		flattenDomTreeWithStyle: flattenDomTreeWithStyle,
		getRootParent: getRootParent,
		xmlStringToElement: xmlStringToElement
	});

	/* svg (c) Kraft, MIT License */

	const makeCDATASection = (text) => (new (SVGWindow()).DOMParser())
		.parseFromString("<root></root>", "text/xml")
		.createCDATASection(text);

	/* svg (c) Kraft, MIT License */
	const markerRegEx = /[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g;
	const digitRegEx = /-?[0-9]*\.?\d+/g;
	const pathCommandNames = {
		m: "move",
		l: "line",
		v: "vertical",
		h: "horizontal",
		a: "ellipse",
		c: "curve",
		s: "smoothCurve",
		q: "quadCurve",
		t: "smoothQuadCurve",
		z: "close",
	};
	Object.keys(pathCommandNames).forEach((key) => {
		const s = pathCommandNames[key];
		pathCommandNames[key.toUpperCase()] = s.charAt(0).toUpperCase() + s.slice(1);
	});
	const add2path = (a, b) => [a[0] + (b[0] || 0), a[1] + (b[1] || 0)];
	const getEndpoint = (command, values, offset = [0, 0]) => {
		const upper = command.toUpperCase();
		let origin = command === upper ? [0, 0] : offset;
		if (command === "V") { origin = [offset[0], 0]; }
		if (command === "H") { origin = [0, offset[1]]; }
		switch (upper) {
		case "V": return add2path(origin, [0, values[0]]);
		case "H": return add2path(origin, [values[0], 0]);
		case "M":
		case "L":
		case "T": return add2path(origin, values);
		case "A": return add2path(origin, [values[5], values[6]]);
		case "C": return add2path(origin, [values[4], values[5]]);
		case "S":
		case "Q": return add2path(origin, [values[2], values[3]]);
		case "Z": return undefined;
		default: return origin;
		}
	};
	const parsePathCommands = (d) => {
		const results = [];
		let match;
		while ((match = markerRegEx.exec(d)) !== null) {
			results.push(match);
		}
		return results
			.map((result, i, arr) => [
				result[0],
				result.index,
				i === arr.length - 1
					? d.length - 1
					: arr[(i + 1) % arr.length].index - 1,
			])
			.map(el => {
				const command = el[0];
				const valueString = d.substring(el[1] + 1, el[2] + 1);
				const strings = valueString.match(digitRegEx);
				const values = strings ? strings.map(parseFloat) : [];
				return { command, values };
			});
	};
	const parsePathCommandsWithEndpoints = (d) => {
		let pen = [0, 0];
		const commands = parsePathCommands(d);
		if (!commands.length) { return commands; }
		commands.forEach((command, i) => {
			commands[i].end = getEndpoint(command.command, command.values, pen);
			commands[i].start = i === 0 ? pen : commands[i - 1].end;
			pen = commands[i].end;
		});
		const last = commands[commands.length - 1];
		const firstDrawCommand = commands
			.filter(el => el.command.toUpperCase() !== "M"
				&& el.command.toUpperCase() !== "Z")
			.shift();
		if (last.command.toUpperCase() === "Z") {
			last.end = [...firstDrawCommand.start];
		}
		return commands;
	};

	var path = /*#__PURE__*/Object.freeze({
		__proto__: null,
		parsePathCommands: parsePathCommands,
		parsePathCommandsWithEndpoints: parsePathCommandsWithEndpoints,
		pathCommandNames: pathCommandNames
	});

	/* svg (c) Kraft, MIT License */

	const makeCoordinates = (...args) => args
		.filter(a => typeof a === str_number)
		.concat(args
			.filter(a => typeof a === str_object && a !== null)
			.map((el) => {
				if (typeof el.x === str_number) { return [el.x, el.y]; }
				if (typeof el[0] === str_number) { return [el[0], el[1]]; }
				return undefined;
			}).filter(a => a !== undefined)
			.reduce((a, b) => a.concat(b), []));

	/* svg (c) Kraft, MIT License */

	const viewBoxValuesToString = function (x, y, width, height, padding = 0) {
		const scale = 1.0;
		const d = (width / scale) - width;
		const X = (x - d) - padding;
		const Y = (y - d) - padding;
		const W = (width + d * 2) + padding * 2;
		const H = (height + d * 2) + padding * 2;
		return [X, Y, W, H].join(" ");
	};
	const makeViewBox = (...args) => {
		const numbers = makeCoordinates(...args.flat());
		if (numbers.length === 2) { numbers.unshift(0, 0); }
		return numbers.length === 4 ? viewBoxValuesToString(...numbers) : undefined;
	};

	/* svg (c) Kraft, MIT License */

	const setViewBox = (element, ...args) => {
		const viewBox = args.length === 1 && typeof args[0] === str_string
			? args[0]
			: makeViewBox(...args);
		if (viewBox) {
			element.setAttribute(str_viewBox, viewBox);
		}
		return element;
	};
	const getViewBox$1 = function (element) {
		const vb = element.getAttribute(str_viewBox);
		return (vb == null
			? undefined
			: vb.split(" ").map(n => parseFloat(n)));
	};
	const convertToViewBox = function (svg, x, y) {
		const pt = svg.createSVGPoint();
		pt.x = x;
		pt.y = y;
		const svgPoint = pt.matrixTransform(svg.getScreenCTM().inverse());
		return [svgPoint.x, svgPoint.y];
	};

	var viewBox = /*#__PURE__*/Object.freeze({
		__proto__: null,
		convertToViewBox: convertToViewBox,
		getViewBox: getViewBox$1,
		setViewBox: setViewBox
	});

	/* svg (c) Kraft, MIT License */

	const general$2 = {
		...algebra$1,
		...dom$1,
		makeCDATASection,
		...path,
		...transforms,
		...viewBox,
	};

	/* svg (c) Kraft, MIT License */

	const getSVGFrame = function (element) {
		const viewBox = getViewBox$1(element);
		if (viewBox !== undefined) {
			return viewBox;
		}
		if (typeof element.getBoundingClientRect === str_function) {
			const rr = element.getBoundingClientRect();
			return [rr.x, rr.y, rr.width, rr.height];
		}
		return [];
	};

	/* svg (c) Kraft, MIT License */

	const bgClass = "svg-background-rectangle";
	const makeBackground = function (element, color) {
		let backRect = Array.from(element.childNodes)
			.filter(child => child.getAttribute(str_class) === bgClass)
			.shift();
		if (backRect == null) {
			backRect = SVGWindow().document.createElementNS(NS, "rect");
			getSVGFrame(element).forEach((n, i) => backRect.setAttribute(nodes_attributes.rect[i], n));
			backRect.setAttribute(str_class, bgClass);
			backRect.setAttribute(str_stroke, str_none);
			element.insertBefore(backRect, element.firstChild);
		}
		backRect.setAttribute(str_fill, color);
		return element;
	};

	/* svg (c) Kraft, MIT License */

	const getAttr = (element) => {
		const t = element.getAttribute(str_transform);
		return (t == null || t === "") ? undefined : t;
	};
	const TransformMethods = {
		clearTransform: (el) => { el.removeAttribute(str_transform); return el; },
	};
	["translate", "rotate", "scale", "matrix"].forEach(key => {
		TransformMethods[key] = (element, ...args) => {
			element.setAttribute(
				str_transform,
				[getAttr(element), `${key}(${args.join(" ")})`]
					.filter(a => a !== undefined)
					.join(" "),
			);
			return element;
		};
	});

	/* svg (c) Kraft, MIT License */
	const toCamel = (s) => s
		.replace(/([-_][a-z])/ig, $1 => $1
			.toUpperCase()
			.replace("-", "")
			.replace("_", ""));
	const toKebab = (s) => s
		.replace(/([a-z0-9])([A-Z])/g, "$1-$2")
		.replace(/([A-Z])([A-Z])(?=[a-z])/g, "$1-$2")
		.toLowerCase();
	const capitalized = (s) => s
		.charAt(0).toUpperCase() + s.slice(1);

	/* svg (c) Kraft, MIT License */

	const removeChildren = (element) => {
		while (element.lastChild) {
			element.removeChild(element.lastChild);
		}
		return element;
	};
	const appendTo = (element, parent) => {
		if (parent && parent.appendChild) {
			parent.appendChild(element);
		}
		return element;
	};
	const setAttributes = (element, attrs) => {
		Object.keys(attrs)
			.forEach(key => element.setAttribute(toKebab(key), attrs[key]));
		return element;
	};

	var dom = /*#__PURE__*/Object.freeze({
		__proto__: null,
		appendTo: appendTo,
		removeChildren: removeChildren,
		setAttributes: setAttributes
	});

	/* svg (c) Kraft, MIT License */

	const setPadding = function (element, padding) {
		const viewBox = getViewBox$1(element);
		if (viewBox !== undefined) {
			setViewBox(element, ...[-padding, -padding, padding * 2, padding * 2]
				.map((nudge, i) => viewBox[i] + nudge));
		}
		return element;
	};
	const findOneElement = function (element, nodeName) {
		const styles = element.getElementsByTagName(nodeName);
		return styles.length ? styles[0] : null;
	};
	const stylesheet = function (element, textContent) {
		let styleSection = findOneElement(element, str_style);
		if (styleSection == null) {
			styleSection = SVGWindow().document.createElementNS(NS, str_style);
			styleSection.setTextContent = (text) => {
				styleSection.textContent = "";
				styleSection.appendChild(makeCDATASection(text));
				return styleSection;
			};
			element.insertBefore(styleSection, element.firstChild);
		}
		styleSection.textContent = "";
		styleSection.appendChild(makeCDATASection(textContent));
		return styleSection;
	};
	const clearSVG = (element) => {
		Array.from(element.attributes)
			.filter(attr => attr.name !== "xmlns" && attr.name !== "version")
			.forEach(attr => element.removeAttribute(attr.name));
		return removeChildren(element);
	};
	const methods$2 = {
		clear: clearSVG,
		size: setViewBox,
		setViewBox,
		getViewBox: getViewBox$1,
		padding: setPadding,
		background: makeBackground,
		getWidth: el => getSVGFrame(el)[2],
		getHeight: el => getSVGFrame(el)[3],
		stylesheet: function (el, text) { return stylesheet.call(this, el, text); },
		...TransformMethods,
		...dom,
	};

	/* svg (c) Kraft, MIT License */

	const eventNameCategories = {
		move: ["mousemove", "touchmove"],
		press: ["mousedown", "touchstart"],
		release: ["mouseup", "touchend"],
		leave: ["mouseleave", "touchcancel"],
	};
	const off = (el, handlers) => Object.values(eventNameCategories)
		.flat()
		.forEach((handlerName) => {
			handlers[handlerName].forEach(func => el
				.removeEventListener(handlerName, func));
			handlers[handlerName] = [];
		});
	const defineGetter = (obj, prop, value) => Object
		.defineProperty(obj, prop, {
			get: () => value,
			enumerable: true,
			configurable: true,
		});
	const TouchEvents = function (element) {
		const handlers = [];
		Object.keys(eventNameCategories).forEach((key) => {
			eventNameCategories[key].forEach((handler) => {
				handlers[handler] = [];
			});
		});
		const removeHandler = category => eventNameCategories[category]
			.forEach(handlerName => handlers[handlerName]
				.forEach(func => element.removeEventListener(handlerName, func)));
		Object.keys(eventNameCategories).forEach((category) => {
			Object.defineProperty(element, `on${capitalized(category)}`, {
				set: (handler) => {
					if (!element.addEventListener) { return; }
					if (handler == null) {
						removeHandler(category);
						return;
					}
					eventNameCategories[category].forEach((handlerName) => {
						const handlerFunc = (e) => {
							const pointer = (e.touches != null ? e.touches[0] : e);
							if (pointer !== undefined) {
								const { clientX, clientY } = pointer;
								const [x, y] = convertToViewBox(element, clientX, clientY);
								defineGetter(e, "x", x);
								defineGetter(e, "y", y);
							}
							handler(e);
						};
						handlers[handlerName].push(handlerFunc);
						element.addEventListener(handlerName, handlerFunc);
					});
				},
				enumerable: true,
			});
		});
		Object.defineProperty(element, "off", { value: () => off(element, handlers) });
	};

	/* svg (c) Kraft, MIT License */
	const makeUUID = () => Math.random()
		.toString(36)
		.replace(/[^a-z]+/g, "")
		.concat("aaaaa")
		.substr(0, 5);

	/* svg (c) Kraft, MIT License */

	const Animation = function (element) {
		let start;
		let frame = 0;
		let requestId;
		const handlers = {};
		const stop = () => {
			if (SVGWindow().cancelAnimationFrame) {
				SVGWindow().cancelAnimationFrame(requestId);
			}
			Object.keys(handlers).forEach(uuid => delete handlers[uuid]);
		};
		const play = (handler) => {
			stop();
			if (!handler || !(SVGWindow().requestAnimationFrame)) { return; }
			start = performance.now();
			frame = 0;
			const uuid = makeUUID();
			handlers[uuid] = (now) => {
				const time = (now - start) * 1e-3;
				handler({ time, frame });
				frame += 1;
				if (handlers[uuid]) {
					requestId = SVGWindow().requestAnimationFrame(handlers[uuid]);
				}
			};
			requestId = SVGWindow().requestAnimationFrame(handlers[uuid]);
		};
		Object.defineProperty(element, "play", { set: play, enumerable: true });
		Object.defineProperty(element, "stop", { value: stop, enumerable: true });
	};

	/* svg (c) Kraft, MIT License */

	const removeFromParent = svg => (svg && svg.parentNode
		? svg.parentNode.removeChild(svg)
		: undefined);
	const possiblePositionAttributes = [["cx", "cy"], ["x", "y"]];
	const controlPoint = function (parent, options = {}) {
		const position = [0, 0];
		const cp = {
			selected: false,
			svg: undefined,
			updatePosition: input => input,
		};
		const updateSVG = () => {
			if (!cp.svg) { return; }
			if (!cp.svg.parentNode) {
				parent.appendChild(cp.svg);
			}
			possiblePositionAttributes
				.filter(coords => cp.svg[coords[0]] != null)
				.forEach(coords => coords.forEach((attr, i) => {
					cp.svg.setAttribute(attr, position[i]);
				}));
		};
		const proxy = new Proxy(position, {
			set: (target, property, value) => {
				target[property] = value;
				updateSVG();
				return true;
			},
		});
		const setPosition = function (...args) {
			makeCoordinates(...args.flat())
				.forEach((n, i) => { position[i] = n; });
			updateSVG();
			if (typeof position.delegate === str_function) {
				position.delegate.apply(position.pointsContainer, [proxy, position.pointsContainer]);
			}
		};
		position.delegate = undefined;
		position.setPosition = setPosition;
		position.onMouseMove = mouse => (cp.selected
			? setPosition(cp.updatePosition(mouse))
			: undefined);
		position.onMouseUp = () => { cp.selected = false; };
		position.distance = mouse => Math.sqrt(svg_distanceSq2(mouse, position));
		["x", "y"].forEach((prop, i) => Object.defineProperty(position, prop, {
			get: () => position[i],
			set: (v) => { position[i] = v; }
		}));
		[str_svg, "updatePosition", "selected"].forEach(key => Object
			.defineProperty(position, key, {
				get: () => cp[key],
				set: (v) => { cp[key] = v; },
			}));
		Object.defineProperty(position, "remove", {
			value: () => {
				removeFromParent(cp.svg);
				position.delegate = undefined;
			},
		});
		return proxy;
	};
	const controls = function (svg, number, options) {
		let selected;
		let delegate;
		const points = Array.from(Array(number))
			.map(() => controlPoint(svg, options));
		const protocol = point => (typeof delegate === str_function
			? delegate.call(points, point, selected, points)
			: undefined);
		points.forEach((p) => {
			p.delegate = protocol;
			p.pointsContainer = points;
		});
		const mousePressedHandler = function (mouse) {
			if (!(points.length > 0)) { return; }
			selected = points
				.map((p, i) => ({ i, d: svg_distanceSq2(p, [mouse.x, mouse.y]) }))
				.sort((a, b) => a.d - b.d)
				.shift()
				.i;
			points[selected].selected = true;
		};
		const mouseMovedHandler = function (mouse) {
			points.forEach(p => p.onMouseMove(mouse));
		};
		const mouseReleasedHandler = function () {
			points.forEach(p => p.onMouseUp());
			selected = undefined;
		};
		svg.onPress = mousePressedHandler;
		svg.onMove = mouseMovedHandler;
		svg.onRelease = mouseReleasedHandler;
		Object.defineProperty(points, "selectedIndex", { get: () => selected });
		Object.defineProperty(points, "selected", { get: () => points[selected] });
		Object.defineProperty(points, "add", {
			value: (opt) => {
				points.push(controlPoint(svg, opt));
			},
		});
		points.removeAll = () => {
			while (points.length > 0) {
				points.pop().remove();
			}
		};
		const functionalMethods = {
			onChange: (func, runOnceAtStart) => {
				delegate = func;
				if (runOnceAtStart === true) {
					const index = points.length - 1;
					func.call(points, points[index], index, points);
				}
			},
			position: func => points.forEach((p, i) => p.setPosition(func.call(points, p, i, points))),
			svg: func => points.forEach((p, i) => { p.svg = func.call(points, p, i, points); }),
		};
		Object.keys(functionalMethods).forEach((key) => {
			points[key] = function () {
				if (typeof arguments[0] === str_function) {
					functionalMethods[key](...arguments);
				}
				return points;
			};
		});
		points.parent = function (parent) {
			if (parent != null && parent.appendChild != null) {
				points.forEach((p) => { parent.appendChild(p.svg); });
			}
			return points;
		};
		return points;
	};
	const applyControlsToSVG = (svg) => {
		svg.controls = (...args) => controls.call(svg, svg, ...args);
	};

	/* svg (c) Kraft, MIT License */

	const svgDef = {
		svg: {
			args: (...args) => [makeViewBox(makeCoordinates(...args))].filter(a => a != null),
			methods: methods$2,
			init: (...args) => {
				const element = SVGWindow().document.createElementNS(NS, "svg");
				element.setAttribute("version", "1.1");
				element.setAttribute("xmlns", NS);
				args.filter(a => a != null)
					.filter(el => el.appendChild)
					.forEach(parent => parent.appendChild(element));
				TouchEvents(element);
				Animation(element);
				applyControlsToSVG(element);
				return element;
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const findIdURL = function (arg) {
		if (arg == null) { return ""; }
		if (typeof arg === str_string) {
			return arg.slice(0, 3) === "url"
				? arg
				: `url(#${arg})`;
		}
		if (arg.getAttribute != null) {
			const idString = arg.getAttribute(str_id);
			return `url(#${idString})`;
		}
		return "";
	};
	const methods$1 = {};
	["clip-path",
		"mask",
		"symbol",
		"marker-end",
		"marker-mid",
		"marker-start",
	].forEach(attr => {
		methods$1[toCamel(attr)] = (element, parent) => {
			element.setAttribute(attr, findIdURL(parent));
			return element;
		};
	});

	/* svg (c) Kraft, MIT License */

	const gDef = {
		g: {
			methods: {
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const setRadius = (el, r) => {
		el.setAttribute(nodes_attributes.circle[2], r);
		return el;
	};
	const setOrigin$1 = (el, a, b) => {
		[...makeCoordinates(...[a, b].flat()).slice(0, 2)]
			.forEach((value, i) => el.setAttribute(nodes_attributes.circle[i], value));
		return el;
	};
	const fromPoints = (a, b, c, d) => [a, b, svg_distance2([a, b], [c, d])];
	const circleDef = {
		circle: {
			args: (a, b, c, d) => {
				const coords = makeCoordinates(...[a, b, c, d].flat());
				switch (coords.length) {
				case 0: case 1: return [, , ...coords];
				case 2: case 3: return coords;
				default: return fromPoints(...coords);
				}
			},
			methods: {
				radius: setRadius,
				setRadius,
				origin: setOrigin$1,
				setOrigin: setOrigin$1,
				center: setOrigin$1,
				setCenter: setOrigin$1,
				position: setOrigin$1,
				setPosition: setOrigin$1,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const setRadii = (el, rx, ry) => {
		[, , rx, ry].forEach((value, i) => el.setAttribute(nodes_attributes.ellipse[i], value));
		return el;
	};
	const setOrigin = (el, a, b) => {
		[...makeCoordinates(...[a, b].flat()).slice(0, 2)]
			.forEach((value, i) => el.setAttribute(nodes_attributes.ellipse[i], value));
		return el;
	};
	const ellipseDef = {
		ellipse: {
			args: (a, b, c, d) => {
				const coords = makeCoordinates(...[a, b, c, d].flat()).slice(0, 4);
				switch (coords.length) {
				case 0: case 1: case 2: return [, , ...coords];
				default: return coords;
				}
			},
			methods: {
				radius: setRadii,
				setRadius: setRadii,
				origin: setOrigin,
				setOrigin,
				center: setOrigin,
				setCenter: setOrigin,
				position: setOrigin,
				setPosition: setOrigin,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const svgIsIterable = (obj) => obj != null
		&& typeof obj[Symbol.iterator] === str_function;
	const svgSemiFlattenArrays = function () {
		switch (arguments.length) {
		case 0: return Array.from(arguments);
		case 1: return svgIsIterable(arguments[0]) && typeof arguments[0] !== str_string
			? svgSemiFlattenArrays(...arguments[0])
			: [arguments[0]];
		default:
			return Array.from(arguments).map(a => (svgIsIterable(a)
				? [...svgSemiFlattenArrays(a)]
				: a));
		}
	};

	/* svg (c) Kraft, MIT License */

	const Args$1 = (...args) => makeCoordinates(...svgSemiFlattenArrays(...args)).slice(0, 4);
	const setPoints$3 = (element, ...args) => {
		Args$1(...args).forEach((value, i) => element.setAttribute(nodes_attributes.line[i], value));
		return element;
	};
	const lineDef = {
		line: {
			args: Args$1,
			methods: {
				setPoints: setPoints$3,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const getD = (el) => {
		const attr = el.getAttribute("d");
		return (attr == null) ? "" : attr;
	};
	const clear = element => {
		element.removeAttribute("d");
		return element;
	};
	const appendPathCommand = (el, command, ...args) => {
		el.setAttribute("d", `${getD(el)}${command}${args.flat().join(" ")}`);
		return el;
	};
	const getCommands = element => parsePathCommands(getD(element));
	const path_methods = {
		addCommand: appendPathCommand,
		appendCommand: appendPathCommand,
		clear,
		getCommands: getCommands,
		get: getCommands,
		getD: el => el.getAttribute("d"),
		...TransformMethods,
		...methods$1,
		...dom,
	};
	Object.keys(pathCommandNames).forEach((key) => {
		path_methods[pathCommandNames[key]] = (el, ...args) => appendPathCommand(el, key, ...args);
	});
	const pathDef = {
		path: {
			methods: path_methods,
		},
	};

	/* svg (c) Kraft, MIT License */

	const setRectSize = (el, rx, ry) => {
		[, , rx, ry]
			.forEach((value, i) => el.setAttribute(nodes_attributes.rect[i], value));
		return el;
	};
	const setRectOrigin = (el, a, b) => {
		[...makeCoordinates(...[a, b].flat()).slice(0, 2)]
			.forEach((value, i) => el.setAttribute(nodes_attributes.rect[i], value));
		return el;
	};
	const fixNegatives = function (arr) {
		[0, 1].forEach(i => {
			if (arr[2 + i] < 0) {
				if (arr[0 + i] === undefined) { arr[0 + i] = 0; }
				arr[0 + i] += arr[2 + i];
				arr[2 + i] = -arr[2 + i];
			}
		});
		return arr;
	};
	const rectDef = {
		rect: {
			args: (a, b, c, d) => {
				const coords = makeCoordinates(...[a, b, c, d].flat()).slice(0, 4);
				switch (coords.length) {
				case 0: case 1: case 2: case 3: return fixNegatives([, , ...coords]);
				default: return fixNegatives(coords);
				}
			},
			methods: {
				origin: setRectOrigin,
				setOrigin: setRectOrigin,
				center: setRectOrigin,
				setCenter: setRectOrigin,
				size: setRectSize,
				setSize: setRectSize,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const styleDef = {
		style: {
			init: (text) => {
				const el = SVGWindow().document.createElementNS(NS, "style");
				el.setAttribute("type", "text/css");
				el.textContent = "";
				el.appendChild(makeCDATASection(text));
				return el;
			},
			methods: {
				setTextContent: (el, text) => {
					el.textContent = "";
					el.appendChild(makeCDATASection(text));
					return el;
				},
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const textDef = {
		text: {
			args: (a, b, c) => makeCoordinates(...[a, b, c].flat()).slice(0, 2),
			init: (a, b, c, d) => {
				const element = SVGWindow().document.createElementNS(NS, "text");
				const text = [a, b, c, d].filter(el => typeof el === str_string).shift();
				element.appendChild(SVGWindow().document.createTextNode(text || ""));
				return element;
			},
			methods: {
				...TransformMethods,
				...methods$1,
				appendTo,
				setAttributes,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const makeIDString = function () {
		return Array.from(arguments)
			.filter(a => typeof a === str_string || a instanceof String)
			.shift() || makeUUID();
	};
	const maskArgs = (...args) => [makeIDString(...args)];
	const maskTypes = {
		mask: {
			args: maskArgs,
			methods: {
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
		clipPath: {
			args: maskArgs,
			methods: {
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
		symbol: {
			args: maskArgs,
			methods: {
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
		marker: {
			args: maskArgs,
			methods: {
				size: setViewBox,
				setViewBox: setViewBox,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const getPoints = (el) => {
		const attr = el.getAttribute(str_points);
		return (attr == null) ? "" : attr;
	};
	const polyString = function () {
		return Array
			.from(Array(Math.floor(arguments.length / 2)))
			.map((_, i) => `${arguments[i * 2 + 0]},${arguments[i * 2 + 1]}`)
			.join(" ");
	};
	const stringifyArgs = (...args) => [
		polyString(...makeCoordinates(...svgSemiFlattenArrays(...args))),
	];
	const setPoints$2 = (element, ...args) => {
		element.setAttribute(str_points, stringifyArgs(...args)[0]);
		return element;
	};
	const addPoint = (element, ...args) => {
		element.setAttribute(str_points, [getPoints(element), stringifyArgs(...args)[0]]
			.filter(a => a !== "")
			.join(" "));
		return element;
	};
	const Args = function (...args) {
		return args.length === 1 && typeof args[0] === str_string
			? [args[0]]
			: stringifyArgs(...args);
	};
	const polyDefs = {
		polyline: {
			args: Args,
			methods: {
				setPoints: setPoints$2,
				addPoint,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
		polygon: {
			args: Args,
			methods: {
				setPoints: setPoints$2,
				addPoint,
				...TransformMethods,
				...methods$1,
				...dom,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const arcPath = (x, y, radius, startAngle, endAngle, includeCenter = false) => {
		if (endAngle == null) { return ""; }
		const start = svg_polar_to_cart(startAngle, radius);
		const end = svg_polar_to_cart(endAngle, radius);
		const arcVec = [end[0] - start[0], end[1] - start[1]];
		const py = start[0] * end[1] - start[1] * end[0];
		const px = start[0] * end[0] + start[1] * end[1];
		const arcdir = (Math.atan2(py, px) > 0 ? 0 : 1);
		let d = (includeCenter
			? `M ${x},${y} l ${start[0]},${start[1]} `
			: `M ${x + start[0]},${y + start[1]} `);
		d += ["a ", radius, radius, 0, arcdir, 1, arcVec[0], arcVec[1]].join(" ");
		if (includeCenter) { d += " Z"; }
		return d;
	};

	/* svg (c) Kraft, MIT License */

	const arcArguments = (a, b, c, d, e) => [arcPath(a, b, c, d, e, false)];
	const arcDef = {
		arc: {
			nodeName: str_path,
			attributes: ["d"],
			args: arcArguments,
			methods: {
				setArc: (el, ...args) => el.setAttribute("d", arcArguments(...args)),
				...TransformMethods,
			},
		},
	};

	/* svg (c) Kraft, MIT License */

	const ends = [str_tail, str_head];
	const stringifyPoint = p => p.join(",");
	const pointsToPath = (points) => "M" + points.map(pt => pt.join(",")).join("L") + "Z";
	const makeArrowPaths = function (options) {
		let pts = [[0,1], [2,3]].map(pt => pt.map(i => options.points[i] || 0));
		let vector = svg_sub2(pts[1], pts[0]);
		let midpoint = svg_add2(pts[0], svg_scale2(vector, 0.5));
		const len = svg_magnitude2(vector);
		const minLength = ends
			.map(s => (options[s].visible
				? (1 + options[s].padding) * options[s].height * 2.5
				: 0))
			.reduce((a, b) => a + b, 0);
		if (len < minLength) {
			const minVec = len === 0 ? [minLength, 0] : svg_scale2(vector, minLength / len);
			pts = [svg_sub2, svg_add2].map(f => f(midpoint, svg_scale2(minVec, 0.5)));
			vector = svg_sub2(pts[1], pts[0]);
		}
		let perpendicular = [vector[1], -vector[0]];
		let bezPoint = svg_add2(midpoint, svg_scale2(perpendicular, options.bend));
		const bezs = pts.map(pt => svg_sub2(bezPoint, pt));
		const bezsLen = bezs.map(v => svg_magnitude2(v));
		const bezsNorm = bezs.map((bez, i) => bezsLen[i] === 0
			? bez
			: svg_scale2(bez, 1 / bezsLen[i]));
		const vectors = bezsNorm.map(norm => svg_scale2(norm, -1));
		const normals = vectors.map(vec => [vec[1], -vec[0]]);
		const pad = ends.map((s, i) => options[s].padding
			? options[s].padding
			: (options.padding ? options.padding : 0.0));
		const scales = ends
			.map((s, i) => options[s].height * (options[s].visible ? 1 : 0))
			.map((n, i) => n + pad[i]);
		const arcs = pts.map((pt, i) => svg_add2(pt, svg_scale2(bezsNorm[i], scales[i])));
		vector = svg_sub2(arcs[1], arcs[0]);
		perpendicular = [vector[1], -vector[0]];
		midpoint = svg_add2(arcs[0], svg_scale2(vector, 0.5));
		bezPoint = svg_add2(midpoint, svg_scale2(perpendicular, options.bend));
		const controls = arcs
			.map((arc, i) => svg_add2(arc, svg_scale2(svg_sub2(bezPoint, arc), options.pinch)));
		const polyPoints = ends.map((s, i) => [
			svg_add2(arcs[i], svg_scale2(vectors[i], options[s].height)),
			svg_add2(arcs[i], svg_scale2(normals[i], options[s].width / 2)),
			svg_add2(arcs[i], svg_scale2(normals[i], -options[s].width / 2)),
		]);
		return {
			line: `M${stringifyPoint(arcs[0])}C${stringifyPoint(controls[0])},${stringifyPoint(controls[1])},${stringifyPoint(arcs[1])}`,
			tail: pointsToPath(polyPoints[0]),
			head: pointsToPath(polyPoints[1]),
		};
	};

	/* svg (c) Kraft, MIT License */

	const setArrowheadOptions = (element, options, which) => {
		if (typeof options === str_boolean) {
			element.options[which].visible = options;
		} else if (typeof options === str_object) {
			Object.assign(element.options[which], options);
			if (options.visible == null) {
				element.options[which].visible = true;
			}
		} else if (options == null) {
			element.options[which].visible = true;
		}
	};
	const setArrowStyle = (element, options = {}, which = str_head) => {
		const path = element.getElementsByClassName(`${str_arrow}-${which}`)[0];
		Object.keys(options)
			.map(key => ({ key, fn: path[toCamel(key)] }))
			.filter(el => typeof el.fn === str_function && el.key !== "class")
			.forEach(el => el.fn(options[el.key]));
		Object.keys(options)
			.filter(key => key === "class")
			.forEach(key => path.classList.add(options[key]));
	};
	const redraw = (element) => {
		const paths = makeArrowPaths(element.options);
		Object.keys(paths)
			.map(path => ({
				path,
				element: element.getElementsByClassName(`${str_arrow}-${path}`)[0],
			}))
			.filter(el => el.element)
			.map(el => { el.element.setAttribute("d", paths[el.path]); return el; })
			.filter(el => element.options[el.path])
			.forEach(el => el.element.setAttribute(
				"visibility",
				element.options[el.path].visible
					? "visible"
					: "hidden",
			));
		return element;
	};
	const setPoints$1 = (element, ...args) => {
		element.options.points = makeCoordinates(...svgSemiFlattenArrays(...args)).slice(0, 4);
		return redraw(element);
	};
	const bend$1 = (element, amount) => {
		element.options.bend = amount;
		return redraw(element);
	};
	const pinch$1 = (element, amount) => {
		element.options.pinch = amount;
		return redraw(element);
	};
	const padding = (element, amount) => {
		element.options.padding = amount;
		return redraw(element);
	};
	const head = (element, options) => {
		setArrowheadOptions(element, options, str_head);
		setArrowStyle(element, options, str_head);
		return redraw(element);
	};
	const tail = (element, options) => {
		setArrowheadOptions(element, options, str_tail);
		setArrowStyle(element, options, str_tail);
		return redraw(element);
	};
	const getLine = element => element.getElementsByClassName(`${str_arrow}-line`)[0];
	const getHead = element => element.getElementsByClassName(`${str_arrow}-${str_head}`)[0];
	const getTail = element => element.getElementsByClassName(`${str_arrow}-${str_tail}`)[0];
	const ArrowMethods = {
		setPoints: setPoints$1,
		points: setPoints$1,
		bend: bend$1,
		pinch: pinch$1,
		padding,
		head,
		tail,
		getLine,
		getHead,
		getTail,
		...TransformMethods,
	};

	/* svg (c) Kraft, MIT License */
	const endOptions = () => ({
		visible: false,
		width: 8,
		height: 10,
		padding: 0.0,
	});
	const makeArrowOptions = () => ({
		head: endOptions(),
		tail: endOptions(),
		bend: 0.0,
		padding: 0.0,
		pinch: 0.618,
		points: [],
	});

	/* svg (c) Kraft, MIT License */

	const arrowKeys = Object.keys(makeArrowOptions());
	const matchingOptions = (...args) => {
		for (let a = 0; a < args.length; a += 1) {
			if (typeof args[a] !== str_object) { continue; }
			const keys = Object.keys(args[a]);
			for (let i = 0; i < keys.length; i += 1) {
				if (arrowKeys.includes(keys[i])) {
					return args[a];
				}
			}
		}
		return undefined;
	};
	const init$1 = function (element, ...args) {
		element.classList.add(str_arrow);
		const paths = ["line", str_tail, str_head].map(key => {
			const path = SVGWindow().document.createElementNS(NS, str_path);
			path.className = `${str_arrow}-${key}`;
			element.appendChild(path);
			return path;
		});
		paths[0].setAttribute(str_style, "fill:none;");
		paths[1].setAttribute(str_stroke, str_none);
		paths[2].setAttribute(str_stroke, str_none);
		element.options = makeArrowOptions();
		ArrowMethods.setPoints(element, ...args);
		const options = matchingOptions(...args);
		if (options) {
			Object.keys(options)
				.filter(key => ArrowMethods[key])
				.forEach(key => ArrowMethods[key](element, options[key]));
		}
		return element;
	};

	/* svg (c) Kraft, MIT License */

	const arrowDef = {
		arrow: {
			nodeName: "g",
			attributes: [],
			args: () => [],
			methods: ArrowMethods,
			init: init$1,
		},
	};

	/* svg (c) Kraft, MIT License */

	const makeCurvePath = (endpoints = [], bend = 0, pinch = 0.5) => {
		const tailPt = [endpoints[0] || 0, endpoints[1] || 0];
		const headPt = [endpoints[2] || 0, endpoints[3] || 0];
		const vector = svg_sub2(headPt, tailPt);
		const midpoint = svg_add2(tailPt, svg_scale2(vector, 0.5));
		const perpendicular = [vector[1], -vector[0]];
		const bezPoint = svg_add2(midpoint, svg_scale2(perpendicular, bend));
		const tailControl = svg_add2(tailPt, svg_scale2(svg_sub2(bezPoint, tailPt), pinch));
		const headControl = svg_add2(headPt, svg_scale2(svg_sub2(bezPoint, headPt), pinch));
		return `M${tailPt[0]},${tailPt[1]}C${tailControl[0]},${tailControl[1]} ${headControl[0]},${headControl[1]} ${headPt[0]},${headPt[1]}`;
	};

	/* svg (c) Kraft, MIT License */

	const curveArguments = (...args) => [
		makeCurvePath(makeCoordinates(...args.flat())),
	];

	/* svg (c) Kraft, MIT License */
	const getNumbersFromPathCommand = str => str
		.slice(1)
		.split(/[, ]+/)
		.map(s => parseFloat(s));
	const getCurveTos = d => d
		.match(/[Cc][(0-9), .-]+/)
		.map(curve => getNumbersFromPathCommand(curve));
	const getMoveTos = d => d
		.match(/[Mm][(0-9), .-]+/)
		.map(curve => getNumbersFromPathCommand(curve));
	const getCurveEndpoints = (d) => {
		const move = getMoveTos(d).shift();
		const curve = getCurveTos(d).shift();
		const start = move
			? [move[move.length - 2], move[move.length - 1]]
			: [0, 0];
		const end = curve
			? [curve[curve.length - 2], curve[curve.length - 1]]
			: [0, 0];
		return [...start, ...end];
	};

	/* svg (c) Kraft, MIT License */

	const setPoints = (element, ...args) => {
		const coords = makeCoordinates(...args.flat()).slice(0, 4);
		element.setAttribute("d", makeCurvePath(coords, element._bend, element._pinch));
		return element;
	};
	const bend = (element, amount) => {
		element._bend = amount;
		return setPoints(element, ...getCurveEndpoints(element.getAttribute("d")));
	};
	const pinch = (element, amount) => {
		element._pinch = amount;
		return setPoints(element, ...getCurveEndpoints(element.getAttribute("d")));
	};
	const curve_methods = {
		setPoints,
		bend,
		pinch,
		...TransformMethods,
	};

	/* svg (c) Kraft, MIT License */

	const curveDef = {
		curve: {
			nodeName: str_path,
			attributes: ["d"],
			args: curveArguments,
			methods: curve_methods,
		},
	};

	/* svg (c) Kraft, MIT License */

	const wedgeArguments = (a, b, c, d, e) => [arcPath(a, b, c, d, e, true)];
	const wedgeDef = {
		wedge: {
			nodeName: str_path,
			args: wedgeArguments,
			attributes: ["d"],
			methods: {
				setArc: (el, ...args) => el.setAttribute("d", wedgeArguments(...args)),
				...TransformMethods,
			},
		},
	};

	/* svg (c) Kraft, MIT License */
	const lib = {};

	/* svg (c) Kraft, MIT License */

	const init = (graph, ...args) => {
		const g = SVGWindow().document.createElementNS(NS, "g");
		lib.ear.convert.foldToSvg.render(graph, g, ...args);
		return g;
	};

	/* svg (c) Kraft, MIT License */

	const methods = {
		...TransformMethods,
		...methods$1,
		...dom,
	};

	/* svg (c) Kraft, MIT License */

	const origamiDef = {
		origami: {
			nodeName: "g",
			init,
			args: () => [],
			methods,
		},
	};

	/* svg (c) Kraft, MIT License */

	const extensions = {
		...svgDef,
		...gDef,
		...circleDef,
		...ellipseDef,
		...lineDef,
		...pathDef,
		...rectDef,
		...styleDef,
		...textDef,
		...maskTypes,
		...polyDefs,
		...arcDef,
		...arrowDef,
		...curveDef,
		...wedgeDef,
		...origamiDef,
	};

	/* svg (c) Kraft, MIT License */

	const passthroughArgs = (...args) => args;
	const Constructor = (name, parent, ...initArgs) => {
		const nodeName = extensions[name] && extensions[name].nodeName
			? extensions[name].nodeName
			: name;
		const { init, args, methods } = extensions[name] || {};
		const attributes = nodes_attributes[nodeName] || [];
		const children = nodes_children[nodeName] || [];
		const element = init
			?	init(...initArgs)
			: SVGWindow().document.createElementNS(NS, nodeName);
		if (parent) { parent.appendChild(element); }
		const processArgs = args || passthroughArgs;
		processArgs(...initArgs).forEach((v, i) => {
			element.setAttribute(nodes_attributes[nodeName][i], v);
		});
		if (methods) {
			Object.keys(methods)
				.forEach(methodName => Object.defineProperty(element, methodName, {
					value: function () {
						return methods[methodName](element, ...arguments);
					},
				}));
		}
		attributes.forEach((attribute) => {
			const attrNameCamel = toCamel(attribute);
			if (element[attrNameCamel]) { return; }
			Object.defineProperty(element, attrNameCamel, {
				value: function () {
					element.setAttribute(attribute, ...arguments);
					return element;
				},
			});
		});
		children.forEach((childNode) => {
			if (element[childNode]) { return; }
			const value = function () { return Constructor(childNode, element, ...arguments); };
			Object.defineProperty(element, childNode, { value });
		});
		return element;
	};

	/* svg (c) Kraft, MIT License */

	const SVG = (...args) => {
		const svg = Constructor(str_svg, null, ...args);
		const initialize = () => args
			.filter(arg => typeof arg === str_function)
			.forEach(func => func.call(svg, svg));
		if (SVGWindow().document.readyState === "loading") {
			SVGWindow().document.addEventListener("DOMContentLoaded", initialize);
		} else {
			initialize();
		}
		return svg;
	};
	Object.assign(SVG, {
		NS,
		nodes_attributes,
		nodes_children,
		extensions,
		...colors,
		...general$2,
	});
	nodeNames.forEach(nodeName => {
		SVG[nodeName] = (...args) => Constructor(nodeName, null, ...args);
	});
	Object.defineProperty(SVG, "window", {
		enumerable: false,
		set: setSVGWindow,
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Convert a bounding box type into a viewbox string
	 */
	const boundingBoxToViewBox = (box) => [box.min, box.span]
		.flatMap(p => [p[0], p[1]])
		.join(" ");
	/**
	 * @description Given a FOLD graph, get the 2D viewbox that
	 * encloses all vertices.
	 */
	const getViewBox = (graph) => {
		const box = boundingBox(graph);
		return box === undefined ? "" : boundingBoxToViewBox(box);
	};
	/**
	 * @description Get the Nth percentile edge length of edges from a graph.
	 * This is useful to get a sense for how thick the strokeWidth should be
	 * to make a reasonable rendering.
	 */
	const getNthPercentileEdgeLength = (
		{ vertices_coords, edges_vertices, edges_length },
		n = 0.1,
	) => {
		if (!vertices_coords || !edges_vertices) {
			return undefined;
		}
		if (!edges_length) {
			edges_length = makeEdgesLength({ vertices_coords, edges_vertices });
		}
		const sortedLengths = edges_length
			.slice()
			.sort((a, b) => a - b);
		const index_tenth_percent = Math.max(
			0,
			Math.min(
				Math.floor(sortedLengths.length * n),
				sortedLengths.length - 1,
			),
		);
		return sortedLengths[index_tenth_percent];
	};

	const unitBounds$1 = { min: [0, 0], span: [1, 1] };
	const DEFAULT_STROKE_WIDTH = 1 / 100;

	const getStrokeWidth = (graph, { vmax } = {}) => {
		if (!vmax) {
			const box = boundingBox(graph) || unitBounds$1;
			vmax = Math.max(...box.span);
		}
		const edgeTenthPercent = getNthPercentileEdgeLength(graph, 0.1);
		return edgeTenthPercent
			? edgeTenthPercent * DEFAULT_STROKE_WIDTH * 10
			: vmax * DEFAULT_STROKE_WIDTH;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const drawVertices = (graph, attributes = {}) => {
		const g = SVG.g();
		if (!graph || !graph.vertices_coords) { return g; }
		// radius will be overwritten in "applyTopLevelOptions"
		graph.vertices_coords
			.map(v => SVG.circle(v[0], v[1], 0.01))
			.forEach(v => g.appendChild(v));
		// default style
		g.setAttributeNS(null, "fill", _none);
		// style attributes on group container
		Object.keys(attributes)
			.forEach(attr => g.setAttributeNS(null, attr, attributes[attr]));
		return g;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const GROUP_FOLDED = {};

	const GROUP_FLAT = {
		stroke: _black,
	};

	const STYLE_FOLDED = {};

	const STYLE_FLAT = {
		B: { stroke: "black" },
		b: { stroke: "black" },
		M: { stroke: "crimson" },
		m: { stroke: "crimson" },
		V: { stroke: "royalblue" },
		v: { stroke: "royalblue" },
		F: { stroke: "lightgray" },
		f: { stroke: "lightgray" },
		J: { stroke: "gold" },
		j: { stroke: "gold" },
		C: { stroke: "limegreen" },
		c: { stroke: "limegreen" },
		U: { stroke: "orchid" },
		u: { stroke: "orchid" },
	};

	const setDataValue$1 = (el, key, value) => el.setAttribute(`data-${key}`, value);

	/**
	 * @returns {object} an object with 5 keys, each value is an array
	 * arrays contain the unique indices of each edge from the edges_ arrays sorted by assignment
	 * if no edges_assignment, or only some defined, remaining edges become "unassigned"
	 */
	const edgesAssignmentIndices = (graph) => {
		const assignment_indices = {
			u: [], c: [], j: [], f: [], v: [], m: [], b: [],
		};
		const lowercase_assignment = graph[_edges_assignment]
			.map(a => a.toLowerCase());
		graph[_edges_vertices]
			.map((_, i) => lowercase_assignment[i] || "u")
			.forEach((a, i) => assignment_indices[a].push(i));
		return assignment_indices;
	};

	const edgesCoords = ({ vertices_coords, edges_vertices }) => {
		if (!vertices_coords || !edges_vertices) { return []; }
		return edges_vertices.map(ev => ev.map(v => vertices_coords[v]));
	};
	/**
	 * a segment is a line segment in the form: [[x1, y1], [x2, y2]]
	 */
	const segmentToPath = s => `M${s[0][0]} ${s[0][1]}L${s[1][0]} ${s[1][1]}`;

	const edgesPathData = (graph) => edgesCoords(graph)
		.map(segment => segmentToPath(segment)).join("");

	const edgesPathDataAssign = ({ vertices_coords, edges_vertices, edges_assignment }) => {
		if (!vertices_coords || !edges_vertices) { return {}; }
		if (!edges_assignment) {
			return ({ u: edgesPathData({ vertices_coords, edges_vertices }) });
		}
		// const segments = edgesCoords({ vertices_coords, edges_vertices, edges_assignment });
		const data = edgesAssignmentIndices({ vertices_coords, edges_vertices, edges_assignment });
		// replace each value in data from array of indices [1,2,3] to path string "M2,3L2.."
		Object.keys(data).forEach(key => {
			data[key] = edgesPathData({
				vertices_coords,
				edges_vertices: data[key].map(i => edges_vertices[i]),
			});
		});
		Object.keys(data).forEach(key => {
			if (data[key] === "") { delete data[key]; }
		});
		return data;
	};

	/**
	 * replace edgesPathDataAssign values from path strings "M2,3L.." to <path> elements
	 */
	const edgesPathsAssign = ({ vertices_coords, edges_vertices, edges_assignment }) => {
		const data = edgesPathDataAssign({ vertices_coords, edges_vertices, edges_assignment });
		Object.keys(data).forEach(assignment => {
			const path = SVG.path(data[assignment]);
			addClass(path, edgesAssignmentNames[assignment]);
			// path.setAttributeNS(null, S._class, edgesAssignmentNames[assignment]);
			data[assignment] = path;
		});
		return data;
	};

	const applyEdgesStyle = (el, attributes = {}) => Object.keys(attributes)
		.forEach(key => el.setAttributeNS(null, key, attributes[key]));

	/**
	 * @returns an array of SVG Path elements.
	 * if edges_assignment exists, there will be as many paths as there are types of edges
	 * if no edges_assignment exists, there will be an array of 1 path.
	 */
	const edgesPaths = (graph, attributes = {}) => {
		const group = SVG.g();
		if (!graph) { return group; }
		const isFolded = isFoldedForm(graph);
		const paths = edgesPathsAssign(graph);
		Object.keys(paths).forEach(key => {
			addClass(paths[key], edgesAssignmentNames[key]);
			// paths[key].classList.add(edgesAssignmentNames[key]);
			// paths[key].setAttributeNS(null, S._class, edgesAssignmentNames[key]);
			applyEdgesStyle(paths[key], isFolded ? STYLE_FOLDED[key] : STYLE_FLAT[key]);
			applyEdgesStyle(paths[key], attributes[key]);
			applyEdgesStyle(paths[key], attributes[edgesAssignmentNames[key]]);
			group.appendChild(paths[key]);
			Object.defineProperty(group, edgesAssignmentNames[key], { get: () => paths[key] });
		});
		Object.keys(paths)
			.forEach(assign => setDataValue$1(paths[assign], "assignment", assign));
		Object.keys(paths)
			.forEach(assign => setDataValue$1(paths[assign], "foldAngle", assignmentFlatFoldAngle[assign]));
		applyEdgesStyle(group, isFolded ? GROUP_FOLDED : GROUP_FLAT);
		// todo: everything else that isn't a class name. filter out classes
		// const no_class_attributes = Object.keys(attributes).filter(
		applyEdgesStyle(group, attributes.stroke ? { stroke: attributes.stroke } : {});
		return group;
	};

	const angleToOpacity = (foldAngle) => (Math.abs(foldAngle) / 180);

	const edgesLines$1 = (graph, attributes = {}) => {
		const group = SVG.g();
		if (!graph) { return group; }
		const isFolded = isFoldedForm(graph);
		const edges_assignment = (graph.edges_assignment
			? graph.edges_assignment
			: makeEdgesAssignment(graph))
			.map(assign => assign.toLowerCase());
		const groups_by_key = {};
		["b", "m", "v", "f", "j", "c", "u"].forEach(k => {
			const child_group = SVG.g();
			group.appendChild(child_group);
			addClass(child_group, edgesAssignmentNames[k]);
			// child_group.classList.add(edgesAssignmentNames[k]);
			// child_group.setAttributeNS(null, S._class, edgesAssignmentNames[k]);
			applyEdgesStyle(child_group, isFolded ? STYLE_FOLDED[k] : STYLE_FLAT[k]);
			applyEdgesStyle(child_group, attributes[edgesAssignmentNames[k]]);
			Object.defineProperty(group, edgesAssignmentNames[k], {
				get: () => child_group,
			});
			groups_by_key[k] = child_group;
		});
		const lines = graph.edges_vertices
			.map(ev => ev.map(v => graph.vertices_coords[v]))
			.map(l => SVG.line(l[0][0], l[0][1], l[1][0], l[1][1]));
		if (graph.edges_foldAngle) {
			graph.edges_foldAngle
				.forEach((angle, i) => setDataValue$1(lines[i], "foldAngle", angle));
		}
		if (graph.edges_assignment) {
			graph.edges_assignment
				.forEach((assign, i) => setDataValue$1(lines[i], "assignment", assign));
		}
		if (graph.edges_foldAngle) {
			lines.forEach((line, i) => {
				const angle = graph.edges_foldAngle[i];
				if (angle === 0 || angle === 180 || angle === -180) { return; }
				line.setAttributeNS(null, "opacity", angleToOpacity(angle));
			});
		}
		lines.forEach((line, i) => groups_by_key[edges_assignment[i]]
			.appendChild(line));

		applyEdgesStyle(group, isFolded ? GROUP_FOLDED : GROUP_FLAT);
		applyEdgesStyle(group, attributes.stroke ? { stroke: attributes.stroke } : {});

		return group;
	};

	const drawEdges = (graph, attributes) => (
		edgesFoldAngleAreAllFlat(graph)
			? edgesPaths(graph, attributes)
			: edgesLines$1(graph, attributes)
	);

	// const make_edgesAssignmentNames = ({ edges_vertices, edges_assignment }) => {
	// 	if (!edges_vertices) { return []; }
	// 	if (!edges_assignment) { return edges_vertices.map(() => edgesAssignmentNames["u"]); }
	// 	return edges_vertices
	// 		.map((_, i) => edges_assignment[i])
	// 		.map((a) => edgesAssignmentNames[(a ? a : "u")]);
	// };

	// const edgesLines = ({ vertices_coords, edges_vertices, edges_assignment }) => {
	// 	if (!vertices_coords || !edges_vertices) { return []; }
	//   const svg_edges = edgesCoords({ vertices_coords, edges_vertices })
	//     .map(e => libraries.svg.line(e[0][0], e[0][1], e[1][0], e[1][1]));
	//   make_edgesAssignmentNames(graph)
	//     .foreach((a, i) => svg_edges[i][k.setAttributeNS](null, k._class, a));
	//   return svg_edges;
	// };

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description For every face, return a boolean indicating if the face has
	 * been flipped over or not (false=flipped), by using the faces_matrix and
	 * checking the determinant.
	 * @param {number[][]} faces_matrix for every face, a 3x4 transform matrix
	 * @returns {boolean[]} true if a face is counter-clockwise.
	 * @linkcode Origami ./src/graph/facesWinding.js 10
	 */
	const makeFacesWindingFromMatrix = faces_matrix => faces_matrix
		.map(m => m[0] * m[4] - m[1] * m[3])
		.map(c => c >= 0);
	/**
	 * @description For every face, return a boolean indicating if the face has
	 * been flipped over or not (false=flipped), by using a faces_matrix containing
	 * 2D matrices.
	 * @param {number[][]} faces_matrix2 for every face, a 2x3 transform matrix
	 * @returns {boolean[]} true if a face is counter-clockwise.
	 * @linkcode Origami ./src/graph/facesWinding.js 21
	 */
	const makeFacesWindingFromMatrix2 = faces_matrix2 => faces_matrix2
		.map(m => m[0] * m[3] - m[1] * m[2])
		.map(c => c >= 0);
	/**
	 * @description For every face, return a boolean if the face's vertices are
	 * in counter-clockwise winding. For origami models, this translates to
	 * true meaning the face is upright, false meaning the face is flipped over.
	 * @param {FOLD} graph a FOLD graph
	 * @returns {boolean[]} boolean for every face, true if face is counter-clockwise.
	 * @attribution cool trick from https://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order
	 * @linkcode Origami ./src/graph/facesWinding.js 33
	 */
	const makeFacesWinding = ({ vertices_coords, faces_vertices }) => faces_vertices
		.map(vertices => vertices
			.map(v => vertices_coords[v])
			.map((point, i, arr) => [point, arr[(i + 1) % arr.length]])
			.map(pts => (pts[1][0] - pts[0][0]) * (pts[1][1] + pts[0][1]))
			.reduce((a, b) => a + b, 0))
		.map(face => face < 0);

	var facesWinding = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeFacesWinding: makeFacesWinding,
		makeFacesWindingFromMatrix: makeFacesWindingFromMatrix,
		makeFacesWindingFromMatrix2: makeFacesWindingFromMatrix2
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const FACE_STYLE_FOLDED_ORDERED = {
		back: { fill: _white },
		front: { fill: "#ddd" },
	};
	const FACE_STYLE_FOLDED_UNORDERED = {
		back: { opacity: 0.1 },
		front: { opacity: 0.1 },
	};
	const FACE_STYLE_FLAT = {
		// back: { fill: "white", stroke: "none" },
		// front: { fill: "#ddd", stroke: "none" }
	};
	const GROUP_STYLE_FOLDED_ORDERED = {
		stroke: _black,
		"stroke-linejoin": "bevel",
	};
	const GROUP_STYLE_FOLDED_UNORDERED = {
		stroke: _none,
		fill: _black,
		"stroke-linejoin": "bevel",
	};
	const GROUP_STYLE_FLAT = {
		fill: _none,
	};

	const setDataValue = (el, key, value) => el.setAttribute(`data-${key}`, value);

	/**
	 * this ended up being a nice function. i got some things for free.
	 */
	const faces_sorted_by_layer = function (faces_layer, graph) {
		const faceCount = graph.faces_vertices.length || graph.faces_edges.length;
		const missingFaces = Array.from(Array(faceCount))
			.map((_, i) => i)
			.filter(i => faces_layer[i] == null);
		return missingFaces.concat(invertMap(faces_layer));
	};

	const applyFacesStyle = (el, attributes = {}) => Object.keys(attributes)
		.forEach(key => el.setAttributeNS(null, key, attributes[key]));

	/**
	 * @description this method will check for layer order, face windings,
	 * and apply a style to each face accordingly, adds them to the group,
	 * and applies style attributes to the group itself too.
	 */
	const finalize_faces = (graph, svg_faces, group, attributes) => {
		const isFolded = isFoldedForm(graph);
		// currently, layer order is determined by "faces_layer" key, and
		// ensuring that the length matches the number of faces in the graph.
		const orderIsCertain = graph[_faces_layer] != null;
		const classNames = [[_front], [_back]];
		const faces_winding = makeFacesWinding(graph);
		// counter-clockwise faces are "face up", their front facing the camera
		// clockwise faces means "flipped", their back is facing the camera.
		// set these class names, and apply the style as attributes on each face.
		faces_winding.map(w => (w ? classNames[0] : classNames[1]))
			.forEach((className, i) => {
				addClass(svg_faces[i], className);
				setDataValue(svg_faces[i], "side", className);
				// svg_faces[i].classList.add(className);
				// svg_faces[i].setAttributeNS(null, S._class, className);
				applyFacesStyle(svg_faces[i], (isFolded
					? (orderIsCertain
						? FACE_STYLE_FOLDED_ORDERED[className]
						: FACE_STYLE_FOLDED_UNORDERED[className])
					: FACE_STYLE_FLAT[className]));
				applyFacesStyle(svg_faces[i], attributes[className]);
			});
		// if the layer-order exists, sort the faces in order of faces_layer
		const facesInOrder = (orderIsCertain
			? faces_sorted_by_layer(graph[_faces_layer], graph).map(i => svg_faces[i])
			: svg_faces);
		facesInOrder.forEach(face => group.appendChild(face));
		// these custom getters allows you to grab all "front" or "back" faces only.
		Object.defineProperty(group, _front, {
			get: () => svg_faces.filter((_, i) => faces_winding[i]),
		});
		Object.defineProperty(group, _back, {
			get: () => svg_faces.filter((_, i) => !faces_winding[i]),
		});
		// set style attributes to the group itself which contains the faces.
		applyFacesStyle(group, (isFolded
			? (orderIsCertain
				? GROUP_STYLE_FOLDED_ORDERED
				: GROUP_STYLE_FOLDED_UNORDERED)
			: GROUP_STYLE_FLAT));
		return group;
	};
	/**
	 * @description build SVG faces using faces_vertices data. this is
	 * slightly faster than the other method which uses faces_edges.
	 * @returns {SVGElement[]} an SVG <g> group element containing all
	 * of the <polygon> faces as children.
	 */
	const facesVerticesPolygon = (graph, attributes = {}) => {
		const g = SVG.g();
		if (!graph || !graph.vertices_coords || !graph.faces_vertices) { return g; }
		const svg_faces = graph.faces_vertices
			.map(fv => fv.map(v => [0, 1].map(i => graph.vertices_coords[v][i])))
			.map(face => SVG.polygon(face));
		svg_faces.forEach((face, i) => face.setAttributeNS(null, _index, i)); // `${i}`));
		g.setAttributeNS(null, "fill", _white);
		return finalize_faces(graph, svg_faces, g, attributes);
	};
	/**
	 * @description build SVG faces using faces_edges data. this is
	 * slightly slower than the other method which uses faces_vertices.
	 * @returns {SVGElement[]} an SVG <g> group element containing all
	 * of the <polygon> faces as children.
	 */
	const facesEdgesPolygon = function (graph, attributes = {}) {
		const g = SVG.g();
		if (!graph
			|| _faces_edges in graph === false
			|| _edges_vertices in graph === false
			|| _vertices_coords in graph === false) {
			return g;
		}
		const svg_faces = graph[_faces_edges]
			.map(face_edges => face_edges
				.map(edge => graph[_edges_vertices][edge])
				.map((vi, i, arr) => {
					const next = arr[(i + 1) % arr.length];
					return (vi[1] === next[0] || vi[1] === next[1] ? vi[0] : vi[1]);
				// }).map(v => graph[S._vertices_coords][v]))
				}).map(v => [0, 1].map(i => graph[_vertices_coords][v][i])))
			.map(face => SVG.polygon(face));
		svg_faces.forEach((face, i) => face.setAttributeNS(null, _index, i)); // `${i}`));
		g.setAttributeNS(null, "fill", "white");
		return finalize_faces(graph, svg_faces, g, attributes);
	};

	const drawFaces = (graph, options) => {
		if (graph && graph[_faces_vertices]) {
			return facesVerticesPolygon(graph, options);
		}
		if (graph && graph[_faces_edges]) {
			return facesEdgesPolygon(graph, options);
		}
		return SVG.g();
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const FOLDED = {
		// stroke: "none",
		fill: _none,
	};
	const FLAT = {
		stroke: _black,
		fill: _white,
	};

	const applyBoundariesStyle = (el, attributes = {}) => Object.keys(attributes)
		.forEach(key => el.setAttributeNS(null, key, attributes[key]));

	// todo this needs to be able to handle multiple boundaries
	const drawBoundaries = (graph, attributes = {}) => {
		const g = SVG.g();
		if (!graph) { return g; }
		const polygon = boundary(graph).polygon;
		if (!polygon.length) { return g; }
		const svgPolygon = SVG.polygon(polygon);
		addClass(svgPolygon, _boundary);
		g.appendChild(svgPolygon);
		// style attributes on group container
		applyBoundariesStyle(g, isFoldedForm(graph) ? FOLDED : FLAT);
		Object.keys(attributes)
			.forEach(attr => g.setAttributeNS(null, attr, attributes[attr]));
		return g;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	var draw = {
		// draw a graph component
		vertices: drawVertices,
		edges: drawEdges,
		faces: drawFaces,
		boundaries: drawBoundaries,
		// subroutines, multiple paths for each component type
		edgesPaths,
		edgesLines: edgesLines$1,
		facesVerticesPolygon,
		facesEdgesPolygon,
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const DEFAULT_CIRCLE_RADIUS = 1 / 50;
	const unitBounds = { min: [0, 0], span: [1, 1] };
	const groupNames = [_boundaries, _faces, _edges, _vertices];
	/**
	 * @description given a group assumed to contain only circle elements,
	 * set the "r" attribute on all circles.
	 */
	const setR = (group, radius) => {
		for (let i = 0; i < group.childNodes.length; i += 1) {
			group.childNodes[i].setAttributeNS(null, "r", radius);
		}
	};
	/**
	 * @description a subroutine of render(). there are style properties which
	 * are impossible to set universally, because they are dependent upon the input
	 * FOLD object (imagine, FOLD within 1x1 square, and FOLD within 600x600).
	 * this includes:
	 * - "viewBox": calculate the viewBox to fit the 2D bounds of the graph.
	 * - "padding": padding incorporated into the viewBox, as a scale of the vmax.
	 * - "stroke-width": as a scale of the vmax.
	 * - "radius": the radius of the vertices (circles), as a scale of the vmax.
	 */
	const applyTopLevelOptions = (element, groups, graph, options) => {
		const hasVertices = groups[3] && groups[3].childNodes.length;
		if (!(options.strokeWidth || options.viewBox || hasVertices)) { return; }
		const box = boundingBox(graph) || unitBounds;
		const vmax = Math.max(...box.span);
		const svgElement = findElementTypeInParents(element, "svg");
		if (svgElement && options.viewBox) {
			const viewBoxValue = boundingBoxToViewBox(box);
			svgElement.setAttributeNS(null, "viewBox", viewBoxValue);
		}
		if (svgElement && options.padding) {
			const viewBoxString = svgElement.getAttribute("viewBox");
			if (viewBoxString != null) {
				const pad = options.padding * vmax;
				const viewBox = viewBoxString.split(" ").map(n => parseFloat(n));
				const newViewBox = [-pad, -pad, pad * 2, pad * 2]
					.map((nudge, i) => viewBox[i] + nudge)
					.join(" ");
				svgElement.setAttributeNS(null, "viewBox", newViewBox);
			}
		}
		if (options.strokeWidth || options["stroke-width"]) {
			const strokeWidth = options.strokeWidth
				? options.strokeWidth
				: options["stroke-width"];
			const strokeWidthValue = typeof strokeWidth === "number"
				? vmax * strokeWidth
				: getStrokeWidth(graph);
			element.setAttributeNS(null, "stroke-width", strokeWidthValue);
		}
		if (hasVertices) {
			const userRadius = options.vertices && options.vertices.radius != null
				? options.vertices.radius
				: options.radius;
			const radius = typeof userRadius === "string" ? parseFloat(userRadius) : userRadius;
			const r = typeof radius === "number" && !Number.isNaN(radius)
				? vmax * radius
				: vmax * DEFAULT_CIRCLE_RADIUS;
			setR(groups[3], r);
		}
	};
	/**
	 * @description renders a FOLD object into SVG elements, sorted into groups.
	 * @param {object} FOLD object
	 * @param {object} options (optional)
	 * @returns {SVGElement[]} An array of four <g> elements: boundaries, faces,
	 *  edges, vertices, each of the graph components drawn into an SVG group.
	 */
	const DrawGroups = (graph, options = {}) => groupNames
		.map(key => (options[key] === false ? (SVG.g()) : draw[key](graph, options)))
		.map((group, i) => {
			addClass(group, groupNames[i]);
			return group;
		});
	/**
	 * @name render
	 * @memberof graph
	 * @description renders a FOLD object into an SVG, ensuring visibility by
	 * setting the viewBox and the stroke-width attributes on the SVG.
	 * @param {SVGElement} element an already initialized SVG DOM element.
	 * @param {FOLD} graph a FOLD object
	 * @param {object} options an optional options object to style the rendering
	 * @returns {SVGElement} the first SVG parameter object.
	 * @linkcode Origami ./src/svg/index.js 161
	 */
	const render = (graph, element, options = {}) => {
		// if the FOLD graph is a creasePattern, don't draw the faces.
		// todo: this needs to be better mixed in with the DrawGroups.faces which
		// does unnecessary work in the case of creasePattern.
		if (!isFoldedForm(graph)) {
			if (options.faces === undefined) {
				options.faces = false;
			}
		}
		const groups = DrawGroups(graph, options);
		groups.filter(group => group.childNodes.length > 0)
			.forEach(group => element.appendChild(group));
		// apply top level options to the SVG (or group) itself
		applyTopLevelOptions(element, groups, graph, options);
		// add classes from the FOLD graph to the top level element
		addClass(
			element,
			...[graph.file_classes || [], graph.frame_classes || []].flat(),
			// ...["FOLD", graph.file_classes || [], graph.frame_classes || []].flat(),
		);
		// set custom getters on the element to grab the component groups
		// groupNames.filter(key => !element[key]).forEach(key => {
		// 	Object.defineProperty(element, key, {
		// 		get: () => element.getElementsByClassName(key)[0],
		// 	});
		// });
		return element;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description renders a FOLD object as an SVG, ensuring visibility by
	 * setting the viewBox and the stroke-width attributes on the SVG.
	 * @param {FOLD | string} file a FOLD object or a FOLD file as a string
	 * @param {object?} options optional options object to style components
	 * @param {boolean} tell the draw method to resize the viewbox/stroke
	 * @returns {SVGElement} SVG element, containing the rendering of the origami.
	 * @linkcode Origami ./src/svg/index.js 185
	 */
	const foldToSvg = (file, options) => render(
		typeof file === "string" ? JSON.parse(file) : file,
		SVG.svg(),
		{
			viewBox: true,
			strokeWidth: true,
			...options,
		},
	);
	/**
	 * @description subroutines
	 */
	Object.assign(foldToSvg, {
		...draw,
		render,
		getViewBox,
		getStrokeWidth,
		boundingBoxToViewBox,
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	const getMetadata = (graph) => {
		const metadata = [
			"file_title",
			"file_author",
			"file_description",
			"frame_title",
			"frame_author",
			"frame_description",
		];
		return metadata
			.filter(key => graph[key])
			.map(key => `# ${key.split("_")[1]}: ${graph[key]}`)
			.join("\n");
	};
	/**
	 * @description Convert a FOLD object into an OBJ file. For FOLD objects
	 * with many frames, this will only work on one frame at a time.
	 * @param {FOLD|string} file a FOLD object
	 * @param {number} frame_num the frame number inside the FOLD object to be
	 * converted, if frames exist, if not this is ignored.
	 * @returns {string} an OBJ representation of the FOLD object
	 * @linkcode Origami ./src/convert/obj.js 77
	 */
	const foldToObj = (file) => {
		const graph = typeof file === "string" ? JSON.parse(file) : file;
		const metadata = getMetadata(graph);
		const vertices = (graph.vertices_coords || [])
			.map(coords => coords.join(" "))
			.map(str => `v ${str}`)
			.join("\n");
		// obj vertex indices begin from 1 not 0
		const faces = (graph.faces_vertices || [])
			.map(verts => verts.map(v => v + 1).join(" "))
			.map(str => `f ${str}`)
			.join("\n");
		const fileString = [metadata, vertices, faces]
			.filter(s => s !== "")
			.join("\n");
		return `${fileString}\n`;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @name Graph
	 * @description a graph which includes faces, edges, and vertices, and additional
	 * origami-specific information like fold angles of edges and layer order of faces.
	 * @param {FOLD} [graph] an optional FOLD object, otherwise the graph will initialize empty
	 * @linkcode Origami ./src/classes/graph.js 50
	 */
	const Graph = {};
	Graph.prototype = Object.create(Object.prototype);
	Graph.prototype.constructor = Graph;
	/**
	 * methods where "graph" is the first parameter, followed by ...arguments
	 * func(graph, ...args)
	 */
	Object.entries({
		// count,
		clean,
		validate,
		populate,
		planarize,
		subgraph,
		// todo: get boundaries, plural
		boundary,
		boundingBox,
		// addVertices,
		nearest,
		splitEdge,
		splitFace,
		faceSpanningTree: makeFaceSpanningTree,
		invertAssignments,
		svg: foldToSvg,
		obj: foldToObj,
		...explodeMethods,
		...transform$1,
	}).forEach(([key, value]) => {
		Graph.prototype[key] = function () {
			return value(this, ...arguments);
		};
	});
	/**
	 * @returns {this} a deep copy of this object
	 */
	Graph.prototype.clone = function () {
		return Object.assign(Object.create(Object.getPrototypeOf(this)), clone(this));
	};
	/**
	 * this clears all components from the graph, leaving metadata and other
	 * keys untouched.
	 */
	// Graph.prototype.clear = function () {
	// 	foldKeys.graph.forEach(key => delete this[key]);
	// 	foldKeys.orders.forEach(key => delete this[key]);
	// 	// the code above just avoided deleting all "file_" keys,
	// 	// however, file_frames needs to be removed as it contains geometry.
	// 	delete this.file_frames;
	// 	return this;
	// };
	/**
	 * @param {object} is a FOLD object.
	 * @param {options}
	 *   "append" import will first, clear FOLD keys. "append":true prevents this clearing
	 */
	// Graph.prototype.load = function (object, options = {}) {
	//   if (typeof object !== S._object) { return; }
	//   if (options.append !== true) {
	//     keys.forEach(key => delete this[key]);
	//   }
	//   // allow overwriting of file_spec and file_creator if included in import
	//   Object.assign(this, { file_spec, file_creator }, clone(object));
	// };
	/**
	 * @description return a shallow copy of this graph with the vertices folded.
	 * This method works for both 2D and 3D origami.
	 * The angle of the fold is searched for in this order:
	 * - faces_matrix2 if it exists
	 * - edges_foldAngle if it exists
	 * - edges_assignment if it exists
	 * Repeated calls to this method will repeatedly fold the vertices
	 * resulting in a behavior that is surely unintended.
	 */
	Graph.prototype.folded = function () {
		const vertices_coords = this.faces_matrix2
			? multiplyVerticesFacesMatrix2(this, this.faces_matrix2)
			: makeVerticesCoordsFolded(this, ...arguments);
		return {
			...this,
			vertices_coords,
			frame_classes: [_foldedForm],
		};
	};
	/**
	 * @description return a copy of this graph with the vertices folded.
	 * This method will work for 2D only.
	 * The angle of the fold is searched for in this order:
	 * - faces_matrix2 if it exists
	 * - edges_assignment or edges_foldAngle if it exists
	 * If neither exists, this method will assume that ALL edges are flat-folded.
	 */
	Graph.prototype.flatFolded = function () {
		const vertices_coords = this.faces_matrix2
			? multiplyVerticesFacesMatrix2(this, this.faces_matrix2)
			: makeVerticesCoordsFlatFolded(this, ...arguments);
		return {
			...this,
			vertices_coords,
			frame_classes: [_foldedForm],
		};
	};

	const setAssignment = (graph, edges, assignment, foldAngle) => {
		edges.forEach(edge => {
			graph.edges_assignment[edge] = assignment;
			graph.edges_foldAngle[edge] = foldAngle;
		});
		return edges;
	};

	Graph.prototype.setValley = function (edges = [], degrees = 180) {
		return setAssignment(this, edges, "V", Math.abs(degrees));
	};

	Graph.prototype.setMountain = function (edges = [], degrees = -180) {
		return setAssignment(this, edges, "M", -Math.abs(degrees));
	};

	Graph.prototype.setFlat = function (edges = []) {
		return setAssignment(this, edges, "F", 0);
	};

	Graph.prototype.setUnassigned = function (edges = []) {
		return setAssignment(this, edges, "U", 0);
	};

	Graph.prototype.setCut = function (edges = []) {
		return setAssignment(this, edges, "C", 0);
	};

	var graphProto = Graph.prototype;

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */

	const lineLineParameter = (
		lineVector,
		lineOrigin,
		polyVector,
		polyOrigin,
		polyLineFunc = includeS,
		epsilon = EPSILON,
	) => {
		// a normalized determinant gives consistent values across all epsilon ranges
		const det_norm = cross2(normalize2(lineVector), normalize2(polyVector));
		// lines are parallel
		if (Math.abs(det_norm) < epsilon) { return undefined; }
		const determinant0 = cross2(lineVector, polyVector);
		const determinant1 = -determinant0;
		const a2b = subtract2(polyOrigin, lineOrigin);
		const b2a = flip(a2b);
		const t0 = cross2(a2b, polyVector) / determinant0;
		const t1 = cross2(b2a, lineVector) / determinant1;
		if (polyLineFunc(t1, epsilon / magnitude2(polyVector))) {
			return t0;
		}
		return undefined;
	};

	const linePointFromParameter = (vector, origin, t) => (
		add2(origin, scale2(vector, t))
	);

	// get all intersections with polgyon faces using the polyLineFunc:
	// - includeS or excludeS
	// sort them so we can grab the two most opposite intersections
	const getIntersectParameters = (poly, vector, origin, polyLineFunc, epsilon) => poly
		// polygon into array of arrays [vector, origin]
		.map((p, i, arr) => [subtract2(arr[(i + 1) % arr.length], p), p])
		.map(side => lineLineParameter(
			vector,
			origin,
			side[0],
			side[1],
			polyLineFunc,
			epsilon,
		))
		.filter(a => a !== undefined)
		.sort((a, b) => a - b);

	// we have already done the test that numbers is a valid array
	// and the length is >= 2
	const getMinMax = (numbers, func, scaled_epsilon) => {
		let a = 0;
		let b = numbers.length - 1;
		while (a < b) {
			if (func(numbers[a + 1] - numbers[a], scaled_epsilon)) { break; }
			a += 1;
		}
		while (b > a) {
			if (func(numbers[b] - numbers[b - 1], scaled_epsilon)) { break; }
			b -= 1;
		}
		if (a >= b) { return undefined; }
		return [numbers[a], numbers[b]];
	};
	/**
	 * @description find the overlap between one line and one convex polygon and
	 * clip the line into a segment (two endpoints) or return undefined if no overlap.
	 * The input line can be a line, ray, or segment, as determined by "fnLine".
	 * @param {number[][]} poly array of points (which are arrays of numbers)
	 * @param {VecLine} line a line in "vector" "origin" form
	 * @param {function} [fnPoly=include] include or exclude polygon boundary in clip
	 * @param {function} [fnLine=includeL] function to determine line/ray/segment,
	 * and inclusive or exclusive.
	 * @param {number} [epsilon=1e-6] optional epsilon
	 * @linkcode Math ./src/intersect/clip.js 93
	 */
	const clipLineConvexPolygon = (
		poly,
		{ vector, origin },
		fnPoly = include,
		fnLine = includeL,
		epsilon = EPSILON,
	) => {
		const numbers = getIntersectParameters(poly, vector, origin, includeS, epsilon);
		if (numbers.length < 2) { return undefined; }
		const scaled_epsilon = (epsilon * 2) / magnitude2(vector);
		// ends is now an array, length 2, of the min and max parameter on the line
		// this also verifies the two intersections are not the same point
		const ends = getMinMax(numbers, fnPoly, scaled_epsilon);
		if (ends === undefined) { return undefined; }
		// ends_clip is the intersection between 2 domains, the result
		// and the valid inclusive/exclusive function
		// todo: this line hardcodes the parameterization that segments and rays are cropping
		// their lowest point at 0 and highest (if segment) at 1
		const clip_fn = (t) => {
			if (fnLine(t)) { return t; }
			return t < 0.5 ? 0 : 1;
		};
		const ends_clip = ends.map(clip_fn);
		// if endpoints are the same, exit
		if (Math.abs(ends_clip[0] - ends_clip[1]) < (epsilon * 2) / magnitude2(vector)) {
			return undefined;
		}
		// test if the solution is collinear to an edge by getting the segment midpoint
		// then test inclusive or exclusive depending on user parameter
		const mid = linePointFromParameter(vector, origin, (ends_clip[0] + ends_clip[1]) / 2);
		return overlapConvexPolygonPoint(poly, mid, fnPoly, epsilon)
			? ends_clip.map(t => linePointFromParameter(vector, origin, t))
			: undefined;
	};
	/**
	 * @description Clip two 2D polygons and return their union. This works
	 * for non-convex poylgons, but both polygons must have counter-clockwise
	 * winding; will not work even if both are similarly-clockwise.
	 * Sutherland-Hodgman algorithm.
	 * Implementation is from Rosetta Code, refactored to incorporate an epsilon
	 * to specify inclusivity around the edges.
	 * @attribution https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript
	 * @param {number[][]} polygon1 an array of points, where each point
	 * is an array of numbers.
	 * @param {number[][]} polygon2 an array of points, where each point
	 * is an array of numbers.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} a polygon as an array of points.
	 * @linkcode Math ./src/intersect/clip.js 143
	 */
	const clipPolygonPolygon = (polygon1, polygon2, epsilon = EPSILON) => {
		const inside = (p, cp1, cp2) => (
			(cp2[0] - cp1[0]) * (p[1] - cp1[1])) > ((cp2[1] - cp1[1]) * (p[0] - cp1[0]) + epsilon
		);
		const intersection = (cp1, cp2, e, s) => {
			const dc = subtract2(cp1, cp2);
			const dp = subtract2(s, e);
			const n1 = cross2(cp1, cp2);
			const n2 = cross2(s, e);
			const n3 = 1.0 / cross2(dc, dp);
			// return [
			// 	(n1 * dp[0] - n2 * dc[0]) * n3,
			// 	(n1 * dp[1] - n2 * dc[1]) * n3,
			// ];
			return scale2(subtract2(scale2(dp, n1), scale2(dc, n2)), n3);
		};
		let outputList = polygon1;
		let cp1 = polygon2[polygon2.length - 1];
		for (let j = 0; j < polygon2.length; j += 1) {
			const cp2 = polygon2[j];
			const inputList = outputList;
			outputList = [];
			let s = inputList[inputList.length - 1];
			for (let i = 0; i < inputList.length; i += 1) {
				const e = inputList[i];
				if (inside(e, cp1, cp2)) {
					if (!inside(s, cp1, cp2)) {
						outputList.push(intersection(cp1, cp2, e, s));
					}
					outputList.push(e);
				} else if (inside(s, cp1, cp2)) {
					outputList.push(intersection(cp1, cp2, e, s));
				}
				s = e;
			}
			cp1 = cp2;
		}
		return outputList.length === 0 ? undefined : outputList;
	};

	var clip$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		clipLineConvexPolygon: clipLineConvexPolygon,
		clipPolygonPolygon: clipPolygonPolygon
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given a set of collinear segments which came from a line,
	 * reduce the total number of segments by joining segments that share a
	 * point, and leave gaps where no segments touch.
	 * Note: this will modify the "segments" parameter in place (shuffle point order)
	 * @param {number[][][]} segments an array of segments
	 * @param {VecLine} line the line that these segments were made from.
	 * @returns {number[][][]} an array of segments, each an array of two points.
	 */
	const joinCollinearSegments = (segments, { vector, origin }, epsilon) => {
		if (segments.length < 2) { return segments; }
		const segmentsBackwards = segments
			.map(pts => subtract2(pts[1], pts[0]))
			.map(vec => dot2(vec, vector) < epsilon);
		segments
			.map((_, i) => i)
			.filter(i => segmentsBackwards[i])
			.forEach(i => { segments[i] = [segments[i][1], segments[i][0]]; });
		const normalized = normalize2(vector);
		const segmentsScalars = segments
			.map(pts => pts.map(point => dot2(subtract2(point, origin), normalized)))
			.sort((a, b) => a[0] - b[0]);
		const joined = [
			[segmentsScalars[0][0], segmentsScalars[0][1]],
		];
		for (let i = 1; i < segmentsScalars.length; i += 1) {
			const curr = segmentsScalars[i];
			if ((curr[0] - epsilon) < (joined[joined.length - 1][1] + epsilon)) {
				// if neighboring segments overlap, increase the current segment length
				joined[joined.length - 1][1] = Math.max(curr[1], joined[joined.length - 1][1]);
			} else {
				// neighbors do not overlap. start a new segment
				joined.push([curr]);
			}
		}
		// convert scalars back into point form.
		return joined.map(seg => seg.map(s => add2(origin, scale2(normalized, s))));
	};
	/**
	 *
	 */
	const clipAndJoin = (graph, faces, line, func = includeL, epsilon = EPSILON) => {
		const clippings = faces
			.map(f => graph.faces_vertices[f].map(v => graph.vertices_coords[v]))
			.map(poly => clipLineConvexPolygon(poly, line, include, func, epsilon))
			.filter(a => a !== undefined);
		return joinCollinearSegments(clippings, line, epsilon);
	};
	/**
	 * @description
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[][]} segment an array of two 2D points
	 * @returns {number[][][]} an array of segments, each an array of 2D points
	 */
	const clipLine = (graph, line, epsilon = EPSILON) => {
		const faces = getFacesLineOverlap(graph, line, epsilon);
		return clipAndJoin(graph, faces, line, includeL, epsilon);
	};
	/**
	 * @description
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[][]} segment an array of two 2D points
	 * @returns {number[][][]} an array of segments, each an array of 2D points
	 */
	const clipRay = (graph, ray, epsilon = EPSILON) => {
		const faces = getFacesRayOverlap(graph, ray, epsilon);
		return clipAndJoin(graph, faces, ray, includeR, epsilon);
	};
	/**
	 * @description
	 * @param {FOLD} graph a FOLD graph
	 * @param {number[][]} segment an array of two 2D points
	 * @returns {number[][][]} an array of segments, each an array of 2D points
	 */
	const clipSegment = (graph, segment, epsilon = EPSILON) => {
		const vector = subtract2(segment[1], segment[0]);
		const origin = segment[0];
		const faces = getFacesSegmentOverlap(graph, segment, epsilon);
		return clipAndJoin(graph, faces, { vector, origin }, includeS, epsilon);
	};
	/**
	 * @description Clip a line inside the boundaries of a graph, resulting in
	 * one segment or undefined. The line can be a line, ray, or segment.
	 * @param {FOLD} graph a FOLD graph
	 * @param {RayLine|number[][]} line a line or a segment
	 * @returns {number[][]|undefined} a segment, a pair of two points,
	 * or undefined if no intersection
	 * @linkcode Origami ./src/graph/clip.js 20
	 */
	const clip = function (graph, line) {
		const polygon = boundary(graph).vertices.map(v => graph.vertices_coords[v]);
		const vector = line.vector ? line.vector : subtract2(line[1], line[0]);
		const origin = line.origin ? line.origin : line[0];
		const fn_line = (line.domain ? line.domain : includeL);
		return clipLineConvexPolygon(
			polygon,
			{ vector, origin },
			include,
			fn_line,
		);
	};

	// const clip = function (graph, line) {
	// 	const polygon = getBoundary(graph).vertices.map(v => vertices_coords[v]);
	// 	return math.polygon(polygon).clip(line);
	// };

	var clip$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		clip: clip,
		clipLine: clipLine,
		clipRay: clipRay,
		clipSegment: clipSegment
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Find all edges in a graph which lie parallel
	 * and on top of a line (infinite line). Can be 2D or 3D.
	 * @param {FOLD} graph a FOLD object
	 * @param {VecLine} line a line with a vector and origin component
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[]} array of edge indices which are collinear to the line
	 * @linkcode Origami ./src/graph/intersect.js 39
	 * @bigO O(n) where n=edges
	 */
	const getEdgesCollinearToLine = (
		{ vertices_coords, edges_vertices },
		{ vector, origin },
		epsilon = EPSILON,
	) => {
		const normalized = normalize(vector);
		// this method compares the *normalized* line vector against
		// an in-function normalization between the two points.
		const pointIsCollinear = (point) => {
			const vec = normalize(subtract(point, origin));
			const dotprod = Math.abs(dot(vec, normalized));
			return Math.abs(1.0 - dotprod) < epsilon;
		};
		// filter edges by:
		// 1. must be parallel with the line
		// 2. one edge point lies on the line
		const edgesVector = makeEdgesVector({ vertices_coords, edges_vertices });
		return edges_vertices
			.map((_, i) => i)
			.filter(i => parallel(vector, edgesVector[i], epsilon))
			.filter(i => pointIsCollinear(vertices_coords[edges_vertices[i][0]]));
	};
	/**
	 * @description Given an axis-aligned bounding box, get a list of all
	 * edge indices which overlap this bounding box in 2D. This can be used
	 * before computing an intersection of some geometry against all edges.
	 */
	const getEdgesRectOverlap = (
		{ vertices_coords, edges_vertices },
		{ min, max },
		epsilon = EPSILON,
	) => {
		const coords = makeEdgesCoords({ vertices_coords, edges_vertices });
		const boxMin = min.map(n => n - epsilon);
		const boxMax = max.map(n => n + epsilon);
		return edges_vertices
			.map((_, i) => i)
			.filter(e => !(coords[e][0][0] < boxMin[0] && coords[e][1][0] < boxMin[0]))
			.filter(e => !(coords[e][0][0] > boxMax[0] && coords[e][1][0] > boxMax[0]))
			.filter(e => !(coords[e][0][1] < boxMin[1] && coords[e][1][1] < boxMin[1]))
			.filter(e => !(coords[e][0][1] > boxMax[1] && coords[e][1][1] > boxMax[1]));
	};
	/**
	 * @description Find all intersections between a segment and all edges
	 * of a 2D graph. The method is hard-coded to be inclusive, include both
	 * the endpoints of the segment, and the endpoints of each edge.
	 * @param {object} a FOLD graph
	 * @param {number[]} point1, the first point of the segment
	 * @param {number[]} point2, the second point of the segment
	 * @returns {number[]} array with holes where the
	 * index is the edge number and the value is the intersection point
	 * @linkcode Origami ./src/graph/intersect.js 73
	 */
	const getEdgesSegmentIntersection = (graph, point1, point2, epsilon = EPSILON) => {
		const segmentBox = boundingBox$1([point1, point2]);
		const segmentVector = subtract2(point2, point1);
		const segmentLine = { vector: segmentVector, origin: point1 };
		// possible edges which overlap (based on axis aligned bounding box overlap)
		const edges = getEdgesRectOverlap(graph, segmentBox, epsilon);
		const intersections = [];
		// for the remaining edges, convert each into line parameterization,
		// run the intersection method and in the case of a result, set the array.
		edges.forEach(e => {
			const edgeCoords = graph.edges_vertices[e].map(v => graph.vertices_coords[v]);
			const edgeVector = subtract2(edgeCoords[1], edgeCoords[0]);
			const edgeLine = { vector: edgeVector, origin: edgeCoords[0] };
			const intersect = intersectLineLine(segmentLine, edgeLine, includeS, includeS, epsilon);
			if (!intersect) { return; }
			intersections[e] = intersect;
		});
		return intersections;
	};

	var intersectEdges = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getEdgesCollinearToLine: getEdgesCollinearToLine,
		getEdgesRectOverlap: getEdgesRectOverlap,
		getEdgesSegmentIntersection: getEdgesSegmentIntersection
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description add vertices to a graph by adding their vertices_coords only. This
	 * will also compare against every existing vertex, only adding non-duplicate
	 * vertices, as determined by an epsilon.
	 * @param {FOLD} graph a FOLD graph, modified in place.
	 * @param {number[][]} vertices_coords array of points to be added to the graph
	 * @param {number} [epsilon=1e-6] optional epsilon to merge similar vertices
	 * @returns {number[]} index of vertex in new vertices_coords array.
	 * the size of this array matches array size of source vertices.
	 * duplicate (non-added) vertices returns their pre-existing counterpart's index.
	 * @linkcode Origami ./src/graph/add/addVertices.js 16
	 */
	const addVertices = (graph, vertices_coords, epsilon = EPSILON) => {
		if (!graph.vertices_coords) { graph.vertices_coords = []; }
		// the user messed up the input and only provided one vertex
		// it's easy to fix for them
		if (typeof vertices_coords[0] === "number") { vertices_coords = [vertices_coords]; }
		// make an array that matches the new vertices_coords where each entry is either
		// - undefined, if the vertex is unique
		// - number, index of duplicate vertex in source graph, if duplicate exists
		const vertices_equivalent_vertices = vertices_coords
			.map(vertex => graph.vertices_coords
				.map(v => distance(v, vertex) < epsilon)
				.map((on_vertex, i) => (on_vertex ? i : undefined))
				.filter(a => a !== undefined)
				.shift());
		// to be used in the return data array
		let index = graph.vertices_coords.length;
		// add the unique vertices to the destination graph
		const unique_vertices = vertices_coords
			.filter((vert, i) => vertices_equivalent_vertices[i] === undefined);
		graph.vertices_coords.push(...unique_vertices);
		// return the indices of the added vertices in the destination graph
		return vertices_equivalent_vertices
			.map(el => (el === undefined ? index++ : el));
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a list of vertices in a graph which:
	 * - these vertices have alreaddy been added to the graph
	 * - this list of vertices has already been sorted along the vector
	 * create a set of edges in the graph that connect these vertices, with
	 * one important detail: don't add edges which already exist in the graph.
	 *
	 * appending: edges_vertices, edges_assignment ("U"), edges_foldAngle (0).
	 * rebuilding: vertices_vertices, vertices_edges.
	 * ignoring face data. faces will be walked and rebuilt later.
	 */
	const add_segment_edges = (graph, segment_vertices, pre_edge_map) => {
		// without looking at the graph, connect all the segment vertices
		// fenceposted to create a list of N-1 edges.
		const unfiltered_segment_edges_vertices = Array
			.from(Array(segment_vertices.length - 1))
			.map((_, i) => [segment_vertices[i], segment_vertices[i + 1]]);
		// check the list of segments against the edge_map and mark
		// each segment which already exists as "false".
		const seg_not_exist_yet = unfiltered_segment_edges_vertices
			.map(verts => verts.join(" "))
			.map(str => pre_edge_map[str] === undefined);
		// now, build the actual edges which will be added to the graph
		// by filtering out the edges which already exist
		const segment_edges_vertices = unfiltered_segment_edges_vertices
			.filter((_, i) => seg_not_exist_yet[i]);
		// these are the indices of the new segments.
		const segment_edges = Array
			.from(Array(segment_edges_vertices.length))
			.map((_, i) => graph.edges_vertices.length + i);
		// add new edges to the graph, these edges compose the new segment.
		// add edges_vertices.
		segment_edges.forEach((e, i) => {
			graph.edges_vertices[e] = segment_edges_vertices[i];
		});
		// only update these arrays if they exist.
		if (graph.edges_assignment) {
			segment_edges.forEach(e => { graph.edges_assignment[e] = "U"; });
		}
		if (graph.edges_foldAngle) {
			segment_edges.forEach(e => { graph.edges_foldAngle[e] = 0; });
		}
		// build vertices_vertices
		// for each vertex (n), get the previous (n-1) and the next (n+1)
		// by default, the endpoints will not have neighbor vertices on either side,
		// and most importantly, use the "seg_not_exist_yet" from earlier to
		// check if an edge already existed, and prevent joining vertices across
		// these already existing edges.
		for (let i = 0; i < segment_vertices.length; i += 1) {
			const vertex = segment_vertices[i];
			const prev = seg_not_exist_yet[i - 1] ? segment_vertices[i - 1] : undefined;
			const next = seg_not_exist_yet[i] ? segment_vertices[i + 1] : undefined;
			const new_adjacent_vertices = [prev, next].filter(a => a !== undefined);
			// for the two vertices that are the segment's endpoints, if they are
			// not collinear vertices, they will not yet have a vertices_vertices.
			const previous_vertices_vertices = graph.vertices_vertices[vertex]
				? graph.vertices_vertices[vertex] : [];
			const unsorted_vertices_vertices = previous_vertices_vertices
				.concat(new_adjacent_vertices);
			graph.vertices_vertices[vertex] = sortVerticesCounterClockwise(
				graph,
				unsorted_vertices_vertices,
				segment_vertices[i],
			);
		}
		// build vertices_edges from vertices_vertices
		const edge_map = makeVerticesToEdgeBidirectional(graph);
		for (let i = 0; i < segment_vertices.length; i += 1) {
			const vertex = segment_vertices[i];
			graph.vertices_edges[vertex] = graph.vertices_vertices[vertex]
				.map(v => edge_map[`${vertex} ${v}`]);
		}
		// build vertices_sectors from vertices_vertices
		segment_vertices
			.map(center => (graph.vertices_vertices[center].length === 1
				? [TWO_PI]
				: counterClockwiseSectors2(graph.vertices_vertices[center]
					.map(v => subtract2(
						graph.vertices_coords[v],
						graph.vertices_coords[center],
					)))))
			.forEach((sectors, i) => {
				graph.vertices_sectors[segment_vertices[i]] = sectors;
			});
		return segment_edges;
	};
	/**
	 * @description Add a segment to a planar graph and maintain planarity.
	 * If endpoints lie within an epsilon to existing vertices, they will be used.
	 * If edges are crossed by the new edge, these edges will be segmented and
	 * new vertices will be added. Finally, all intersected faces will be rebuilt.
	 * If the graph contains the arrays edges_assignment or edges_foldAngle,
	 * the corresponding new edge indices will be appended with "U" and 0.
	 * @param {FOLD} graph a planar FOLD graph, modified in place.
	 * @param {number[]} point1 a 2D point as an array of numbers
	 * @param {number[]} point2 a 2D point as an array of numbers
	 * @param {number} [epsilon=1e-6] optional epsilon for merging vertices
	 * @returns {number[]} the indices of the new edge(s) composing the segment.
	 * @linkcode Origami ./src/graph/add/addPlanarSegment.js 129
	 */
	const addPlanarSegment = (graph, point1, point2, epsilon = EPSILON) => {
		// vertices_sectors not a part of the spec, might not be included.
		// this is needed for when we walk faces. we need to be able to
		// identify the one face that winds around the outside enclosing Infinity.
		if (!graph.vertices_sectors) {
			graph.vertices_sectors = makeVerticesSectors(graph);
		}
		// flatten input points to the Z=0 plane
		const segment = [point1, point2].map(p => [p[0], p[1]]);
		const segment_vector = subtract2(segment[1], segment[0]);
		// not sure this is wanted. project all vertices onto the XY plane.
		// graph.vertices_coords = graph.vertices_coords
		//   .map(coord => coord.slice(0, 2));
		// get all edges which intersect the segment.
		const intersections = getEdgesSegmentIntersection(
			graph,
			segment[0],
			segment[1],
			epsilon,
		);
		// get the indices of the edges, sorted.
		// (they are already sorted in getEdgesSegmentIntersection)
		const intersected_edges = intersections.map((_, e) => e).filter(includeL);
		// using edges_faces, get all faces which have an edge intersected.
		const faces_map = {};
		intersected_edges
			.forEach(e => graph.edges_faces[e]
				.forEach(f => { faces_map[f] = true; }));
		const intersected_faces = Object.keys(faces_map)
			.map(s => parseInt(s, 10))
			.sort((a, b) => a - b);
		// split all intersected edges into two edges, in reverse order
		// so that the "remove()" call only ever removes the last from the
		// set of edges. each splitEdge call also rebuilds all graph data,
		// vertices, faces, adjacent of each, etc..
		const splitEdge_results = intersected_edges
			.reverse()
			.map(edge => splitEdge(graph, edge, intersections[edge], epsilon));
		const splitEdge_vertices = splitEdge_results.map(el => el.vertex);
		// do we need this? changelog for edges? maybe it will be useful someday.
		// todo, should this list be reversed?
		// if the segment crosses at the intersection of some edges,
		// this algorithm produces maps with a bunch of undefineds.
		// const splitEdge_maps = splitEdge_results.map(el => el.edges.map);
		// console.log("splitEdge_maps", splitEdge_maps);
		// const splitEdge_map = splitEdge_maps
		//   .splice(1)
		//   .reduce((a, b) => mergeNextmaps(a, b), splitEdge_maps[0]);
		// now that all edges have been split their new vertices have been
		// added to the graph, add the original segment's two endpoints.
		// we waited until here because this method will search all existing
		// vertices, and avoid adding a duplicate, which will happen in the
		// case of an endpoint lies collinear along a split edge.
		const endpoint_vertices = addVertices(graph, segment, epsilon);
		// use a hash as an intermediary, make sure new vertices are unique.
		// duplicate vertices will occur in the case of a collinear endpoint.
		const new_vertex_hash = {};
		splitEdge_vertices.forEach(v => { new_vertex_hash[v] = true; });
		endpoint_vertices.forEach(v => { new_vertex_hash[v] = true; });
		const new_vertices = Object.keys(new_vertex_hash).map(n => parseInt(n, 10));
		// these vertices are sorted in the direction of the segment
		const segment_vertices = sortVerticesAlongVector(graph, new_vertices, segment_vector);

		const edge_map = makeVerticesToEdgeBidirectional(graph);
		// this method returns the indices of the edges that compose the segment.
		// this array is this method's return value.
		const segment_edges = add_segment_edges(graph, segment_vertices, edge_map);
		// update the edge_map with the new segment edges. this is needed for
		// after we walk faces, the faces_edges data comes in the form of
		// vertex pairs, and we need to be able to look up these new edges.
		segment_edges.forEach(e => {
			const v = graph.edges_vertices[e];
			edge_map[`${v[0]} ${v[1]}`] = e;
			edge_map[`${v[1]} ${v[0]}`] = e;
		});
		// in preparation to rebuild faces, we need a set of edges (as a
		// pair of vertices) to begin a counter-clockwise walk. it's
		// insufficient to simply start the walks from all of the new segment's
		// edges, as it would fail this case: the segment splits a face and
		// ends collinear, so that no part of the segment exists INSIDE the face
		// and the face will never be walked.
		// __________
		// [        ]   segment
		// [  face  O-------------
		// [        ]
		// ----------
		// therefore, we will use all of the vertices_vertices from the
		// segment's vertices. this seems to cover all cases.
		// additionally, we don't have to worry about repeating faces, the
		// method has a protection against that ("walked_edges").
		const face_walk_start_pairs = segment_vertices
			.map(v => graph.vertices_vertices[v]
				.map(adj_v => [[adj_v, v], [v, adj_v]]))
			.reduce((a, b) => a.concat(b), [])
			.reduce((a, b) => a.concat(b), []);
		// graph.vertices_sectors = makeVerticesSectors(graph);
		// memo to prevent duplicate faces. this one object should be
		// applied globally to all calls to the method.
		const walked_edges = {};
		// build faces by begin walking from the set of vertex pairs.
		// this includes the one boundary face in the wrong winding direction
		const all_walked_faces = face_walk_start_pairs
			.map(pair => counterClockwiseWalk(graph, pair[0], pair[1], walked_edges))
			.filter(a => a !== undefined);
		// filter out the one boundary face with wrong winding (if it exists)
		const walked_faces = filterWalkedBoundaryFace(all_walked_faces);
		// const walked_faces = all_walked_faces;
		// this method could be called before or after the walk. but
		// for simplicity we're calling it before adding the new faces.
		removeGeometryIndices(graph, "faces", intersected_faces);
		// todo: this assumes faces_vertices exists.
		const new_faces = walked_faces
			.map((_, i) => graph.faces_vertices.length + i);
		// add each array, only if they exist.
		if (graph.faces_vertices) {
			new_faces.forEach((f, i) => {
				graph.faces_vertices[f] = walked_faces[i].vertices;
			});
		}
		// edges are in vertex pairs. these need to be converted to edges
		if (graph.faces_edges) {
			new_faces.forEach((f, i) => {
				graph.faces_edges[f] = walked_faces[i].edges
					.map(pair => edge_map[pair]);
			});
		}
		// tbh, this array is not typically used.
		if (graph.faces_angles) {
			new_faces.forEach((f, i) => {
				graph.faces_angles[f] = walked_faces[i].faces_angles;
			});
		}
		// update all the arrays which reference face arrays, this includes
		// vertices_faces, edges_faces, faces_faces (all that end with _faces)
		if (graph.vertices_faces) {
			graph.vertices_faces = makeVerticesFaces(graph);
		}
		if (graph.edges_faces) {
			graph.edges_faces = makeEdgesFacesUnsorted(graph);
		}
		if (graph.faces_faces) {
			graph.faces_faces = makeFacesFaces(graph);
		}
		// todo, get rid of this after testing.
		if (graph.vertices_coords.length !== graph.vertices_vertices.length
			|| graph.vertices_coords.length !== graph.vertices_edges.length
			|| graph.vertices_coords.length !== graph.vertices_faces.length) {
			console.warn("vertices mismatch", JSON.parse(JSON.stringify(graph)));
		}
		if (graph.edges_vertices.length !== graph.edges_faces.length
			|| graph.edges_vertices.length !== graph.edges_assignment.length) {
			console.warn("edges mismatch", JSON.parse(JSON.stringify(graph)));
		}
		if (graph.faces_vertices.length !== graph.faces_edges.length
			|| graph.faces_vertices.length !== graph.faces_faces.length) {
			console.warn("faces mismatch", JSON.parse(JSON.stringify(graph)));
		}
		// console.log("intersected_edges", intersected_edges);
		// console.log("intersected_faces", intersected_faces);
		// console.log("splitEdge_results", splitEdge_results);
		// console.log("splitEdge_map", splitEdge_map);
		// console.log("splitEdge_vertices", splitEdge_vertices);
		// console.log("vertices_vertices", splitEdge_vertices
		//   .map(v => graph.vertices_vertices[v]));
		// console.log("endpoint_vertices", endpoint_vertices);
		// console.log("new_vertices", new_vertices);
		// console.log("segment_vertices", segment_vertices);
		// console.log("segment_vertex_pairs", segment_vertex_pairs);
		// console.log("walked_faces", walked_faces);
		// console.log("new_check", new_check);
		return segment_edges;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given two (soon to be) formerly adjacent vertices,
	 * remove mention of the other from each's vertices_vertices.
	 */
	const update_vertices_vertices = ({ vertices_vertices }, vertices) => {
		const other = [vertices[1], vertices[0]];
		vertices
			.map((v, i) => vertices_vertices[v].indexOf(other[i]))
			.forEach((index, i) => vertices_vertices[vertices[i]].splice(index, 1));
	};

	const update_vertices_edges = ({ vertices_edges }, edge, vertices) => {
		vertices
			.map((v, i) => vertices_edges[v].indexOf(edge))
			.forEach((index, i) => vertices_edges[vertices[i]].splice(index, 1));
	};
	/**
	 * @param {object} a FOLD graph
	 * @param {number[]} two face indices in an array.
	 */
	const join_faces = (graph, faces, edge, vertices) => {
		// const other = [faces[1], faces[0]];
		// the index of the edge in the face's faces_edges array.
		const faces_edge_index = faces
			.map(f => graph.faces_edges[f].indexOf(edge));
		// the index of the FIRST vertex in the face's faces_vertices array.
		// this means that the two vertex indices are at i, and i+1.
		const faces_vertices_index = [];
		faces.forEach((face, f) => graph.faces_vertices[face]
			.forEach((v, i, arr) => {
				const next = arr[(i + 1) % arr.length];
				if ((v === vertices[0] && next === vertices[1])
					|| (v === vertices[1] && next === vertices[0])) {
					faces_vertices_index[f] = i;
				}
			}));
		if (faces_vertices_index[0] === undefined || faces_vertices_index[1] === undefined) { console.warn("removePlanarEdge error joining faces"); }

		// get the length of each face, before and after changes
		const edges_len_before = faces
			.map(f => graph.faces_edges[f].length);
		const vertices_len_before = faces
			.map(f => graph.faces_vertices[f].length);
		const edges_len_after = edges_len_before.map(len => len - 1);
		const vertices_len_after = vertices_len_before.map(len => len - 1);

		// get the first index after the remove indices for each array
		const faces_edge_keep = faces_edge_index
			.map((e, i) => (e + 1) % edges_len_before[i]);
		const faces_vertex_keep = faces_vertices_index
			.map((v, i) => (v + 1) % vertices_len_before[i]);

		const new_faces_edges = faces
			.map((face, f) => Array.from(Array(edges_len_after[f]))
				.map((_, i) => (faces_edge_keep[f] + i) % edges_len_before[f])
				.map(index => graph.faces_edges[face][index]));
		const new_faces_vertices = faces
			.map((face, f) => Array.from(Array(vertices_len_after[f]))
				.map((_, i) => (faces_vertex_keep[f] + i) % vertices_len_before[f])
				.map(index => graph.faces_vertices[face][index]));

		// todo this unaligns faces_faces with faces_vertices/faces_edges
		const new_faces_faces = faces
			.map(f => graph.faces_faces[f])
			.reduce((a, b) => a.concat(b), [])
			.filter(f => f !== faces[0] && f !== faces[1]);

		return {
			vertices: new_faces_vertices[0].concat(new_faces_vertices[1]),
			edges: new_faces_edges[0].concat(new_faces_edges[1]),
			faces: new_faces_faces,
		};
	};
	/**
	 * @description remove an edge from a planar graph, rebuild affected faces,
	 * remove any newly isolated vertices.
	 * @param {object} graph a FOLD graph
	 * @param {number} edge the index of the edge to be removed
	 * @returns {undefined}
	 * @linkcode Origami ./src/graph/remove/removePlanarEdge.js 93
	 */
	const removePlanarEdge = (graph, edge) => {
		// the edge's vertices, sorted large to small.
		// if they are isolated, we want to remove them.
		const vertices = [...graph.edges_vertices[edge]]
			.sort((a, b) => b - a);
		const faces = [...graph.edges_faces[edge]];
		// console.log("removing edge", edge, "with", faces.length, "adjacent faces",
		// faces, "and", vertices.length, "adjacent vertices", vertices);
		update_vertices_vertices(graph, vertices);
		update_vertices_edges(graph, edge, vertices);
		// is the vertex isolated? if so, mark it for removal
		// either 0, 1, or 2 vertices are able to be removed.
		// wait until the end to remove these.
		const vertices_should_remove = vertices
			.map(v => graph.vertices_vertices[v].length === 0);
		const remove_vertices = vertices
			.filter((vertex, i) => vertices_should_remove[i]);
		// only if the edge has two adjacent faces, and those faces are unique,
		// construct a new face by joining the two faces together at the edge.
		if (faces.length === 2 && faces[0] !== faces[1]) {
			// the index of the new face, the three faces (new and 2 old) are
			// going to temporarily coexist in the graph, before the 2 are removed.
			const new_face = graph.faces_vertices.length;
			// generate the new face's faces_vertices, faces_edges, faces_faces
			const new_face_data = join_faces(graph, faces, edge, vertices);
			graph.faces_vertices.push(new_face_data.vertices);
			graph.faces_edges.push(new_face_data.edges);
			graph.faces_faces.push(new_face_data.faces);
			// todo, check if other faces_ arrays exist. they are out of sync.
			// update all graphs which point to faces:
			// vertices_faces, edges_faces, faces_faces
			graph.vertices_faces.forEach((arr, i) => {
				// in the case of one vertex touching both faces, remove both
				// occurences of the old faces, but only add 1 occurence of the new.
				let already_added = false;
				arr.forEach((face, j) => {
					if (face === faces[0] || face === faces[1]) {
						graph.vertices_faces[i][j] = new_face;
						const params = already_added ? [i, 1] : [i, 1, new_face];
						arr.splice(...params);
						already_added = true;
					}
				});
			});
			graph.edges_faces.forEach((arr, i) => arr.forEach((face, j) => {
				if (face === faces[0] || face === faces[1]) {
					graph.edges_faces[i][j] = new_face;
				}
			}));
			graph.faces_faces.forEach((arr, i) => arr.forEach((face, j) => {
				if (face === faces[0] || face === faces[1]) {
					graph.faces_faces[i][j] = new_face;
				}
			}));
			graph.faces_vertices.forEach(fv => fv.forEach(f => {
				if (f === undefined) {
					console.log("FOUND ONE before remove", graph.faces_vertices);
				}
			}));
			// again, only if the edge separated two unique faces, then
			// remove the old faces
			removeGeometryIndices(graph, "faces", faces);
		}
		// this edge is a part of a face where the edge pokes in, winds back
		// out, definitely not convex.
		// from the faces_vertices, remove any isolated vertices.
		// from the faces_edges, remove the edge.
		// then this creates a situation where two of the same vertex might be
		// repeated. filter out so that the vertices are unique only.
		if (faces.length === 2 && faces[0] === faces[1] && remove_vertices.length) {
			const face = faces[0]; // the non-convex face which needs correcting.
			graph.faces_vertices[face] = graph.faces_vertices[face]
				.filter(v => !remove_vertices.includes(v))
				.filter((v, i, arr) => v !== arr[(i + 1) % arr.length]);
			graph.faces_edges[face] = graph.faces_edges[face]
				.filter(e => e !== edge);
		}
		// remove edge, shrink edges_vertices, edges_faces, ... by 1
		// this also replaces any edge occurence in _edge arrays including:
		// vertices_edges, faces_edges.
		removeGeometryIndices(graph, "edges", [edge]);
		removeGeometryIndices(graph, "vertices", remove_vertices);
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Check if a point is collinear and between two other points.
	 * @param {number[]} p0 a segment point
	 * @param {number[]} p1 the point to test collinearity
	 * @param {number[]} p2 a segment point
	 * @param {boolean} [inclusive=false] if the point is the same as the endpoints
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean} true if the point lies collinear and between the other two points.
	 * @linkcode Math ./src/geometry/lines.js 29
	 */
	const collinearBetween = (p0, p1, p2, inclusive = false, epsilon = EPSILON) => {
		const similar = [p0, p2]
			.map(p => epsilonEqualVectors(p1, p))
			.reduce((a, b) => a || b, false);
		if (similar) { return inclusive; }
		const vectors = [[p0, p1], [p1, p2]]
			.map(segment => subtract(segment[1], segment[0]))
			.map(vector => normalize(vector));
		return epsilonEqual(1.0, dot(...vectors), epsilon);
	};
	/**
	 * @description linear interpolate between two lines
	 * @param {VecLine} a a line with a "vector" and "origin" component
	 * @param {VecLine} b a line with a "vector" and "origin" component
	 * @param {number} t one scalar between 0 and 1 (not clamped)
	 * @returns {number[]} one vector, dimensions matching first parameter
	 * @linkcode Math ./src/geometry/lines.js 47
	 */
	const lerpLines = (a, b, t) => {
		const vector = lerp(a.vector, b.vector, t);
		const origin = lerp(a.origin, b.origin, t);
		return { vector, origin };
	};
	// export const pleat = (a, b, count) => Array
	// 	.from(Array(count - 1))
	// 	.map((_, i) => (i + 1) / count)
	// 	.map(t => lerpLines(a, b, t));
	/**
	 * @description Between two lines, make a repeating sequence of
	 * evenly-spaced lines to simulate a series of pleats.
	 * @param {VecLine} a a line with a "vector" and "origin" component
	 * @param {VecLine} b a line with a "vector" and "origin" component
	 * @param {number} count the number of faces, the number of lines will be n-1.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {VecLine[]} an array of lines, objects with "vector" and "origin"
	 * @linkcode Math ./src/geometry/lines.js 65
	 */
	const pleat = (a, b, count, epsilon = EPSILON) => {
		const dotProd = dot(a.vector, b.vector);
		const determinant = cross2(a.vector, b.vector);
		const numerator = cross2(subtract2(b.origin, a.origin), b.vector);
		const t = numerator / determinant;
		const normalized = [a.vector, b.vector].map(vec => normalize(vec));
		// two sets of pleats will be generated, between either pairs
		// of interior angles, unless the lines are parallel.
		const sides = determinant > -epsilon
			? [[a.vector, b.vector], [flip(b.vector), a.vector]]
			: [[b.vector, a.vector], [flip(a.vector), b.vector]];
		const pleatVectors = sides
			.map(pair => counterClockwiseSubsect2(pair[0], pair[1], count));
		const isParallel = Math.abs(cross2(...normalized)) < epsilon;
		// there is an intersection as long as the lines are not parallel
		const intersection = isParallel
			? undefined
			: add2(a.origin, scale2(a.vector, t));
		// the origin of the lines will be either the intersection,
		// or in the case of parallel, a lerp between the two line origins.
		const iter = Array.from(Array(count - 1));
		const origins = isParallel
			? iter.map((_, i) => lerp(a.origin, b.origin, (i + 1) / count))
			: iter.map(() => intersection);
		const solution = pleatVectors
			.map(side => side.map((vector, i) => ({
				vector,
				origin: [...origins[i]],
			})));
		if (isParallel) { solution[(dotProd > -epsilon ? 1 : 0)] = []; }
		return solution;
	};
	/**
	 * @description given two lines, find two lines which bisect the given lines,
	 * if the given lines have an intersection, or return one
	 * line if they are parallel.
	 * @param {VecLine} a a line with a "vector" and "origin" component
	 * @param {VecLine} b a line with a "vector" and "origin" component
	 * @param {number} [epsilon=1e-6] an optional epsilon for testing parallel-ness.
	 * @returns {VecLine[]} an array of lines, objects with "vector" and "origin"
	 * @linkcode Math ./src/geometry/lines.js 107
	 */
	const bisectLines2 = (a, b, epsilon = EPSILON) => {
		const solution = pleat(a, b, 2, epsilon).map(arr => arr[0]);
		solution.forEach((val, i) => {
			if (val === undefined) { delete solution[i]; }
		});
		return solution;
	};

	var line = /*#__PURE__*/Object.freeze({
		__proto__: null,
		bisectLines2: bisectLines2,
		collinearBetween: collinearBetween,
		lerpLines: lerpLines,
		pleat: pleat
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const getEdgeBetweenVertices = ({ vertices_edges }, a, b) => {
		const set = new Set(vertices_edges[a]);
		return vertices_edges[b].filter(edge => set.has(edge)).shift();
	};
	/**
	 * @description Given one vertex, and a list of edges which contain this vertex,
	 * get one vertex for every edge which is not the input parameter vertex.
	 * @param {FOLD} graph a FOLD graph with edges_vertices
	 * @param {number} vertex one vertex index
	 * @param {number[]} edges a list of edge indices
	 * @returns {number[]} for every edge, one vertex that is the opposite vertex
	 */
	const getOtherVerticesInEdges = ({ edges_vertices }, vertex, edges) => edges
		.map(edge => (edges_vertices[edge][0] === vertex
			? edges_vertices[edge][1]
			: edges_vertices[edge][0]));

	var edgesGeneral = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getEdgeBetweenVertices: getEdgeBetweenVertices,
		getOtherVerticesInEdges: getOtherVerticesInEdges
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description determine if a vertex exists between two and only two edges, and
	 * those edges are both parallel and on opposite ends of the vertex. In a lot of
	 * cases, this vertex can be removed and the graph would function the same.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} vertex an index of a vertex in the graph
	 * @returns {boolean} true if the vertex is collinear and can be removed.
	 * @linkcode Origami ./src/graph/verticesCollinear.js 19
	 * @bigO O(1) if vertices_edges exists, if not, O(n) where n=edges
	 */
	const isVertexCollinear = ({
		vertices_coords, vertices_edges, edges_vertices,
	}, vertex, epsilon = EPSILON) => {
		if (!vertices_coords || !edges_vertices) { return false; }
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		const edges = vertices_edges[vertex];
		if (edges === undefined || edges.length !== 2) { return false; }
		// don't just check if they are parallel, use the direction of the vertex
		// to make sure the center vertex is inbetween, instead of the odd
		// case where the two edges are on top of one another with
		// a leaf-like vertex.
		const vertices = getOtherVerticesInEdges({ edges_vertices }, vertex, edges);
		const points = [vertices[0], vertex, vertices[1]]
			.map(v => vertices_coords[v]);
		return collinearBetween(...points, false, epsilon);
	};

	var verticesCollinear = /*#__PURE__*/Object.freeze({
		__proto__: null,
		isVertexCollinear: isVertexCollinear
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a degree-2 vertex, remove this vertex, merge the adjacent
	 * edges into one, and rebuild the faces on either side.
	 * @param {object} graph a FOLD graph
	 * @param {number} edge the index of the edge to be removed
	 * @returns {undefined}
	 * @linkcode Origami ./src/graph/remove/removePlanarVertex.js 13
	 */
	const removePlanarVertex = (graph, vertex) => {
		const edges = graph.vertices_edges[vertex];
		const faces = uniqueSortedNumbers(graph.vertices_faces[vertex]
			.filter(a => a != null));
		if (edges.length !== 2 || faces.length > 2) {
			console.warn("cannot remove non 2-degree vertex yet (e,f)", edges, faces);
			return;
		}
		const vertices = getOtherVerticesInEdges(graph, vertex, edges);
		const vertices_reverse = vertices.slice().reverse();
		// sort edges so the smallest index is first
		// edges[0] is the keep edge. edges[1] will be the removed edge.
		edges.sort((a, b) => a - b);
		// vertices_edges
		// replace the index of the removed edge with the keep edge.
		// one of them will already be linked to the keep edge. skip it.
		vertices.forEach(v => {
			const index = graph.vertices_edges[v].indexOf(edges[1]);
			if (index === -1) { return; }
			graph.vertices_edges[v][index] = edges[0];
		});
		// vertices_vertices
		// find the index of the removed vertex,
		// replace it with the opposite vertex.
		vertices.forEach((v, i) => {
			const index = graph.vertices_vertices[v].indexOf(vertex);
			if (index === -1) {
				console.warn("removePlanarVertex unknown vertex issue");
				return;
			}
			graph.vertices_vertices[v][index] = vertices_reverse[i];
		});
		// edges_vertices
		graph.edges_vertices[edges[0]] = [...vertices];
		// faces_vertices
		faces.forEach(face => {
			const index = graph.faces_vertices[face].indexOf(vertex);
			if (index === -1) {
				console.warn("removePlanarVertex unknown face_vertex issue");
				return;
			}
			graph.faces_vertices[face].splice(index, 1);
		});
		// faces_edges
		faces.forEach(face => {
			const index = graph.faces_edges[face].indexOf(edges[1]);
			if (index === -1) {
				console.warn("removePlanarVertex unknown face_edge issue");
				return;
			}
			graph.faces_edges[face].splice(index, 1);
		});
		// no changes to: vertices_faces, edges_faces, faces_faces,
		// edges_assignment/foldAngle
		removeGeometryIndices(graph, "vertices", [vertex]);
		removeGeometryIndices(graph, "edges", [edges[1]]);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a list of numbers this method will sort them by
	 *  even and odd indices and sum the two categories, returning two sums.
	 * @param {number[]} numbers one list of numbers
	 * @returns {number[]} one array of two sums, even and odd indices
	 * @linkcode Origami ./src/singleVertex/kawasakiMath.js 13
	 */
	const alternatingSum = (numbers) => [0, 1]
		.map(even_odd => numbers
			.filter((_, i) => i % 2 === even_odd)
			.reduce((a, b) => a + b, 0));
	/**
	 * @description alternatingSum, filter odd and even into two categories, then
	 *  then set them to be the deviation from the average of the sum.
	 * @param {number[]} sectors one list of numbers
	 * @returns {number[]} one array of two numbers. if both alternating sets sum
	 *  to the same, the result will be [0, 0]. if the first set is 2 more than the
	 *  second, the result will be [1, -1]. (not [2, 0] or something with a 2 in it)
	 * @linkcode Origami ./src/singleVertex/kawasakiMath.js 26
	 */
	const alternatingSumDifference = (sectors) => {
		const halfsum = sectors.reduce((a, b) => a + b, 0) / 2;
		return alternatingSum(sectors).map(s => s - halfsum);
	};

	// export const kawasaki_from_even_vectors = function (...vectors) {
	//   return alternating_deviation(...interior_angles(...vectors));
	// };
	/**
	 * @description given a set of edges around a single vertex (expressed as an array
	 * of radian angles), find all possible single-ray additions which
	 * when added to the set, the set satisfies Kawasaki's theorem.
	 * @usage this is hard coded to work for flat-plane, where sectors sum to 360deg
	 * @param {number[]} radians the angle of the edges in radians,
	 * like vectors around a vertex. pre-sorted.
	 * @returns {number[]} for every sector either one vector (as an angle in radians)
	 * or undefined if that sector contains no solution.
	 * @linkcode Origami ./src/singleVertex/kawasakiMath.js 45
	 */
	const kawasakiSolutionsRadians = (radians) => radians
		// counter clockwise angle between this index and the next
		.map((v, i, arr) => [v, arr[(i + 1) % arr.length]])
		.map(pair => counterClockwiseAngleRadians(...pair))
		// for every sector, make an array of all the OTHER sectors
		.map((_, i, arr) => arr.slice(i + 1, arr.length).concat(arr.slice(0, i)))
		// for every sector, use the sector score from the OTHERS two to split it
		.map(opposite_sectors => alternatingSum(opposite_sectors).map(s => Math.PI - s))
		// add the deviation to the edge to get the absolute position
		.map((kawasakis, i) => radians[i] + kawasakis[0])
		// sometimes this results in a solution OUTSIDE the sector. ignore these
		.map((angle, i) => (isCounterClockwiseBetween(
			angle,
			radians[i],
			radians[(i + 1) % radians.length],
		)
			? angle
			: undefined));
	// or should we remove the indices so the array reports [ empty x2, ...]
	/**
	 * @description given a set of edges around a single vertex (expressed as an array
	 * of vectors), find all possible single-ray additions which
	 * when added to the set, the set satisfies Kawasaki's theorem.
	 * @usage this is hard coded to work for flat-plane, where sectors sum to 360deg
	 * @param {number[][]} vectors array of vectors, the edges around a single vertex. pre-sorted.
	 * @returns {number[][]} for every sector either one vector
	 * or undefined if that sector contains no solution.
	 * @linkcode Origami ./src/singleVertex/kawasakiMath.js 74
	 */
	const kawasakiSolutionsVectors = (vectors) => {
		const vectors_radians = vectors.map(v => Math.atan2(v[1], v[0]));
		return kawasakiSolutionsRadians(vectors_radians)
			.map(a => (a === undefined
				? undefined
				: [Math.cos(a), Math.sin(a)]));
	};

	var kawasakiMath = /*#__PURE__*/Object.freeze({
		__proto__: null,
		alternatingSum: alternatingSum,
		alternatingSumDifference: alternatingSumDifference,
		kawasakiSolutionsRadians: kawasakiSolutionsRadians,
		kawasakiSolutionsVectors: kawasakiSolutionsVectors
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const flat_assignment = {
		B: true, b: true, F: true, f: true, U: true, u: true,
	};
	/**
	 * @description get all vertices indices which are adjacent to edges
	 * with no mountain/valleys, only containing either flat, unassigned,
	 * or boundary.
	 */
	const vertices_flat = ({ vertices_edges, edges_assignment }) => vertices_edges
		.map(edges => edges
			.map(e => flat_assignment[edges_assignment[e]])
			.reduce((a, b) => a && b, true))
		.map((valid, i) => (valid ? i : undefined))
		.filter(a => a !== undefined);

	const folded_assignments = {
		M: true, m: true, V: true, v: true,
	};
	const maekawa_signs = {
		M: -1, m: -1, V: 1, v: 1,
	};
	/**
	 * @description using edges_assignment, check if Maekawa's theorem is satisfied
	 * for all vertices, and if not, return the vertices which violate the theorem.
	 * todo: this assumes that valley/mountain folds are flat folded.
	 * @param {FOLD} graph a FOLD object
	 * @returns {number[]} indices of vertices which violate the theorem. an empty array has no errors.
	 * @linkcode Origami ./src/singleVertex/validate.js 41
	 */
	const validateMaekawa = ({ edges_vertices, vertices_edges, edges_assignment }) => {
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		const is_valid = vertices_edges
			.map(edges => edges
				.map(e => maekawa_signs[edges_assignment[e]])
				.filter(a => a !== undefined)
				.reduce((a, b) => a + b, 0))
			.map(sum => sum === 2 || sum === -2);
		// overwrite any false values to true for all boundary vertices
		boundaryVertices({ edges_vertices, edges_assignment })
			.forEach(v => { is_valid[v] = true; });
		vertices_flat({ vertices_edges, edges_assignment })
			.forEach(v => { is_valid[v] = true; });
		return is_valid
			.map((valid, v) => (!valid ? v : undefined))
			.filter(a => a !== undefined);
	};
	/**
	 * @description using the vertices of the edges, check if Kawasaki's theorem is satisfied
	 * for all vertices, and if not, return the vertices which violate the theorem.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[]} indices of vertices which violate the theorem. an empty array has no errors.
	 * @linkcode Origami ./src/singleVertex/validate.js 68
	 */
	const validateKawasaki = ({
		vertices_coords,
		vertices_vertices,
		vertices_edges,
		edges_vertices,
		edges_assignment,
		edges_vector,
	}, epsilon = EPSILON) => {
		if (!vertices_vertices) {
			vertices_vertices = makeVerticesVertices({ vertices_coords, vertices_edges, edges_vertices });
		}
		const is_valid = makeVerticesVerticesVector({
			vertices_coords, vertices_vertices, edges_vertices, edges_vector,
		})
			.map((vectors, v) => vectors
				.filter((_, i) => folded_assignments[edges_assignment[vertices_edges[v][i]]]))
			.map(vectors => (vectors.length > 1
				? counterClockwiseSectors2(vectors)
				: [0, 0]))
			.map(sectors => alternatingSum(sectors))
			.map(pair => Math.abs(pair[0] - pair[1]) < epsilon);

		// overwrite any false values to true for all boundary vertices
		boundaryVertices({ edges_vertices, edges_assignment })
			.forEach(v => { is_valid[v] = true; });
		vertices_flat({ vertices_edges, edges_assignment })
			.forEach(v => { is_valid[v] = true; });
		return is_valid
			.map((valid, v) => (!valid ? v : undefined))
			.filter(a => a !== undefined);
	};

	var validateSingleVertex = /*#__PURE__*/Object.freeze({
		__proto__: null,
		validateKawasaki: validateKawasaki,
		validateMaekawa: validateMaekawa
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * Crease Pattern - a flat-array, index-based graph with faces, edges, and vertices
	 * that exist in 2D space, edges resolved so there are no edge crossings.
	 * The naming scheme for keys follows the FOLD format.
	 */
	const CP = {};
	CP.prototype = Object.create(graphProto);
	CP.prototype.constructor = CP;

	const makeEdgesReturnObject = function (edges) {
		edges.valley = (degrees) => this.setValley(edges, degrees);
		edges.mountain = (degrees) => this.setMountain(edges, degrees);
		edges.flat = () => this.setFlat(edges);
		edges.unassigned = () => this.setUnassigned(edges);
		edges.cut = () => this.setCut(edges);
		return edges;
	};

	const clipLineTypeToCP = (cp, primitive) => {
		const segment = clip(cp, primitive);
		if (!segment) { return undefined; }
		const edges = addPlanarSegment(cp, segment[0], segment[1]);
		// if (!edges) { return undefined; }
		return makeEdgesReturnObject.call(cp, edges);
	};

	CP.prototype.line = function (...args) {
		const primitive = getLine$1(...args);
		if (!primitive) { return undefined; }
		primitive.domain = includeL;
		return clipLineTypeToCP(this, primitive);
	};

	CP.prototype.ray = function (...args) {
		const primitive = getLine$1(...args);
		if (!primitive) { return undefined; }
		primitive.domain = includeR;
		return clipLineTypeToCP(this, primitive);
	};

	CP.prototype.segment = function (...args) {
		const primitive = pointsToLine(...getSegment(...args));
		if (!primitive) { return undefined; }
		primitive.domain = includeS;
		return clipLineTypeToCP(this, primitive);
	};

	CP.prototype.polygon = function (...args) {
		const points = getArrayOfVectors(...args);
		if (!points) { return undefined; }
		const segments = points
			.map((p, i, arr) => [p, arr[(i + 1) % arr.length]])
			.map(seg => pointsToLine(...seg))
			.map(line => ({ ...line, domain: includeS }))
			.map(line => clip(this, line))
			.filter(a => a !== undefined);
		if (!segments) { return undefined; }
		const edges = segments
			.flatMap(segment => addPlanarSegment(this, segment[0], segment[1]));
		return makeEdgesReturnObject.call(this, edges);
	};

	// CP.prototype.polyline = function (...args) {};

	// ["circle", "rect", "polygon"].forEach((fName) => {
	// 	CP.prototype[fName] = function () {
	// 		const primitive = math[fName](...arguments);
	// 		if (!primitive) { return; }
	// 		const segments = primitive.segments(arcResolution)
	// 			.map(segment => math.segment(segment))
	// 			.map(segment => clip(this, segment))
	// 			.filter(a => a !== undefined);
	// 		if (!segments) { return; }
	// 		const vertices = [];
	// 		const edges = [];
	// 		segments.forEach(segment => {
	// 			const verts = addVertices(this, segment);
	// 			vertices.push(...verts);
	// 			edges.push(...addEdges(this, verts));
	// 		});
	// 		const { map } = planarize(this).edges;
	// 		populate(this);
	// 		return makeEdgesReturnObject.call(this, edges.map(e => map[e])
	// 			.reduce((a, b) => a.concat(b), []));
	// 	};
	// });

	CP.prototype.removeEdge = function (edge) {
		const vertices = this.edges_vertices[edge];
		removePlanarEdge(this, edge);
		vertices
			.map(v => isVertexCollinear(this, v))
			.map((collinear, i) => (collinear ? vertices[i] : undefined))
			.filter(a => a !== undefined)
			.sort((a, b) => b - a)
			.forEach(v => removePlanarVertex(this, v));
		return true;
	};

	CP.prototype.validate = function (epsilon) {
		const valid = validate(this, epsilon);
		valid.vertices.kawasaki = validateKawasaki(this, epsilon);
		valid.vertices.maekawa = validateMaekawa(this);
		if (this.edges_foldAngle) {
			valid.edges.not_flat = this.edges_foldAngle
				.map((angle, i) => (edgeFoldAngleIsFlat(angle) ? undefined : i))
				.filter(a => a !== undefined);
		}
		if (valid.summary === "valid") {
			if (valid.vertices.kawasaki.length || valid.vertices.maekawa.length) {
				valid.summary = "invalid";
			} else if (valid.edges.not_flat.length) {
				valid.summary = "not flat";
			}
		}
		return valid;
	};

	CP.prototype.defer = false;

	var cpProto = CP.prototype;

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description this builds a new faces_layer array. it first separates the
	 * folding faces from the non-folding using faces_folding, an array of [t,f].
	 * it flips the folding faces over, appends them to the non-folding ordering,
	 * and (re-indexes/normalizes) all the z-index values to be the minimum
	 * whole number set starting with 0.
	 * @param {number[]} each index is a face, each value is the z-layer order.
	 * @param {boolean[]} each index is a face, T/F will the face be folded over?
	 * @returns {number[]} each index is a face, each value is the z-layer order.
	 */
	const foldFacesLayer = (faces_layer, faces_folding) => {
		const new_faces_layer = [];
		// filter face indices into two arrays, those folding and not folding
		const arr = faces_layer.map((_, i) => i);
		const folding = arr.filter(i => faces_folding[i]);
		const not_folding = arr.filter(i => !faces_folding[i]);
		// sort all the non-folding indices by their current layer, bottom to top,
		// give each face index a new layering index.
		// compress whatever current layer numbers down into [0...n]
		not_folding
			.sort((a, b) => faces_layer[a] - faces_layer[b])
			.forEach((face, i) => { new_faces_layer[face] = i; });
		// sort the folding faces in reverse order (flip them), compress their
		// layers down into [0...n] and and set each face to this layer index
		folding
			.sort((a, b) => faces_layer[b] - faces_layer[a]) // reverse order here
			.forEach((face, i) => { new_faces_layer[face] = not_folding.length + i; });
		return new_faces_layer;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description this determines which side of a line (using cross product)
	 * a face lies in a folded form, except, the face is the face in
	 * the crease pattern and the line (vector origin) is transformed
	 * by the face matrix. because of this, we use face_winding to know
	 * if this face was flipped over, reversing the result.
	 * @note by flipping the < and > in the return, this one change
	 * will modify the entire method to toggle which side of the line
	 * are the faces which will be folded over.
	 */
	const make_face_side = (vector, origin, face_center, face_winding) => {
		const center_vector = subtract2(face_center, origin);
		const determinant = cross2(vector, center_vector);
		return face_winding ? determinant > 0 : determinant < 0;
	};
	/**
	 * for quickly determining which side of a crease a face lies
	 * this uses point average, not centroid, faces must be convex
	 * and again it's not precise, but this doesn't matter because
	 * the faces which intersect the line (and could potentially cause
	 * discrepencies) don't use this method, it's only being used
	 * for faces which lie completely on one side or the other.
	 */
	const make_face_center = (graph, face) => (!graph.faces_vertices[face]
		? [0, 0]
		: graph.faces_vertices[face]
			.map(v => graph.vertices_coords[v])
			.reduce((a, b) => [a[0] + b[0], a[1] + b[1]], [0, 0])
			.map(el => el / graph.faces_vertices[face].length));

	const unfolded_assignment = {
		F: true, f: true, U: true, u: true,
	};
	const opposite_lookup = {
		M: "V", m: "V", V: "M", v: "M",
	};
	/**
	 * @description for a mountain or valley, return the opposite.
	 * in the case of any other crease (boundary, flat, ...) return the input.
	 */
	const get_opposite_assignment = assign => opposite_lookup[assign] || assign;
	/**
	 * @description shallow copy these entries for one face in the graph.
	 * this is intended to capture the values, in the case of the face
	 * being removed from the graph (not deep deleted, just unreferenced).
	 */
	const face_snapshot = (graph, face) => ({
		center: graph.faces_center[face],
		matrix: graph.faces_matrix2[face],
		winding: graph.faces_winding[face],
		crease: graph.faces_crease[face],
		side: graph.faces_side[face],
		layer: graph.faces_layer[face],
	});
	/**
	 * @description make a crease that passes through the entire origami and modify the
	 * faces order to simulate one side of the faces flipped over and set on top.
	 * @param {object} graph a FOLD graph in crease pattern form, will be modified in place
	 * @param {number[]} vector a 2D vector describing the line as an array of numbers
	 * @param {number[]} origin a 2D origin describing the line as an array of numbers
	 * @param {string} assignment (M/V/F) a FOLD spec encoding of the direction of the fold
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a summary of changes to faces/edges.
	 * @algorithm Because we want to return the new modified origami in crease pattern form,
	 * as we iterate through the faces, splitting faces which cross the crease
	 * line, we have to be modifying the crease pattern, as opposed to modifying
	 * a folded form then unfolding the vertices, which would be less precise.
	 * So, we will create copies of the crease line, one per face, transformed
	 * into place by its face's matrix, which superimposes many copies of the
	 * crease line onto the crease pattern, each in place
	 * @linkcode Origami ./src/graph/flatFold/index.js 96
	 */
	const flatFold = (graph, { vector, origin }, assignment = "V", epsilon = EPSILON) => {
		const opposite_assignment = get_opposite_assignment(assignment);
		// make sure the input graph contains the necessary data.
		// this takes care of all standard FOLD-spec arrays.
		// todo: this could be optimized by trusting that the existing arrays
		// are accurate, checking if they exist and skipping them if so.
		populate(graph);
		// additionally, we need to ensure faces layer exists.
		// todo: if it doesn't exist, should we use the solver?
		if (!graph.faces_layer) {
			graph.faces_layer = Array(graph.faces_vertices.length).fill(0);
		}
		// these will be properties on the graph. as we iterate through faces,
		// splitting (removing 1 face, adding 2) inside "splitFace", the remove
		// method will automatically shift indices for arrays starting with "faces_".
		// we will remove these arrays at the end of this method.
		graph.faces_center = graph.faces_vertices
			.map((_, i) => make_face_center(graph, i));
		// faces_matrix is built from the crease pattern, but reflects
		// the faces in their folded state.
		if (!graph.faces_matrix2) {
			graph.faces_matrix2 = makeFacesMatrix2(graph, 0);
		}
		graph.faces_winding = makeFacesWindingFromMatrix2(graph.faces_matrix2);
		graph.faces_crease = graph.faces_matrix2
			.map(invertMatrix2)
			.map(matrix => multiplyMatrix2Line2(matrix, vector, origin));
		graph.faces_side = graph.faces_vertices
			.map((_, i) => make_face_side(
				graph.faces_crease[i].vector,
				graph.faces_crease[i].origin,
				graph.faces_center[i],
				graph.faces_winding[i],
			));
		// before we start splitting faces, we have to handle the case where
		// a flat crease already exists along the fold crease, already splitting
		// two faces (assignment "F" or "U" only), the splitFace method
		// will not catch these. we need to find these edges before we modify
		// the graph, find the face they are attached to and whether the face
		// is flipped, and set the edge to the proper "V" or "M" (and foldAngle).
		const vertices_coords_folded = multiplyVerticesFacesMatrix2(
			graph,
			graph.faces_matrix2,
		);
		// get all (folded) edges which lie parallel and overlap the crease line
		const collinear_edges = getEdgesCollinearToLine({
			vertices_coords: vertices_coords_folded,
			edges_vertices: graph.edges_vertices,
		}, { vector, origin }, epsilon)
			.filter(e => unfolded_assignment[graph.edges_assignment[e]]);
		// get the first valid adjacent face for each edge, get that face's winding,
		// which determines the crease assignment, and assign it to the edge
		collinear_edges
			.map(e => graph.edges_faces[e].find(f => f != null))
			.map(f => graph.faces_winding[f])
			.map(winding => (winding ? assignment : opposite_assignment))
			.forEach((assign, e) => {
				graph.edges_assignment[collinear_edges[e]] = assign;
				graph.edges_foldAngle[collinear_edges[e]] = edgeAssignmentToFoldAngle(
					assign,
				);
			});
		// before we start splitting, capture the state of face 0. we will use
		// it when rebuilding the graph's matrices after all splitting is finished.
		const face0 = face_snapshot(graph, 0);
		// now, iterate through faces (reverse order), rebuilding the custom
		// arrays for the newly added faces when a face is split.
		const split_changes = graph.faces_vertices
			.map((_, i) => i)
			.reverse()
			.map((i) => {
				// this is the face about to be removed. if the face is successfully
				// split the face will be removed but we still need to reference
				// values from it to complete the 2 new faces which replace it.
				const face = face_snapshot(graph, i);
				// split the polygon (if possible), get back a summary of changes.
				const change = splitFace(graph, i, face.crease, epsilon);
				// console.log("split convex polygon change", change);
				if (change === undefined) { return undefined; }
				// const face_winding = folded.faces_winding[i];
				// console.log("face change", face, change);
				// update the assignment of the newly added edge separating the 2 new faces
				graph.edges_assignment[change.edges.new] = face.winding
					? assignment
					: opposite_assignment;
				graph.edges_foldAngle[change.edges.new] = edgeAssignmentToFoldAngle(
					graph.edges_assignment[change.edges.new],
				);
				// these are the two faces that replaced the removed face after the split
				const new_faces = change.faces.map[change.faces.remove];
				new_faces.forEach(f => {
					// no need right now to build faces_winding, faces_matrix, ...
					graph.faces_center[f] = make_face_center(graph, f);
					graph.faces_side[f] = make_face_side(
						face.crease.vector,
						face.crease.origin,
						graph.faces_center[f],
						face.winding,
					);
					graph.faces_layer[f] = face.layer;
				});
				return change;
			})
			.filter(a => a !== undefined);
		// all faces have been split. get a summary of changes to the graph.
		// "faces_map" is actually needed. the others are just included in the return
		const faces_map = mergeNextmaps(...split_changes.map(el => el.faces.map));
		const edges_map = mergeNextmaps(...split_changes.map(el => el.edges.map)
			.filter(a => a !== undefined));
		const faces_remove = split_changes.map(el => el.faces.remove).reverse();
		// const vert_dict = {};
		// split_changes.forEach(el => el.vertices.forEach(v => { vert_dict[v] = true; }));
		// const new_vertices = Object.keys(vert_dict).map(s => parseInt(s));
		// build a new face layer ordering
		graph.faces_layer = foldFacesLayer(
			graph.faces_layer,
			graph.faces_side,
		);
		// build new face matrices for the folded state. use face 0 as reference
		// we need its original matrix, and if face 0 was split we need to know
		// which of its two new faces doesn't move as the new faces matrix
		// calculation requires we provide the one face that doesn't move.
		const face0_was_split = faces_map && faces_map[0] && faces_map[0].length === 2;
		const face0_newIndex = (face0_was_split
			? faces_map[0].filter(f => graph.faces_side[f]).shift()
			: 0);
		// only if face 0 lies on the not-flipped side (sidedness is false),
		// and it wasn't creased-through, can we use its original matrix.
		// if face 0 lies on the flip side (sidedness is true), or it was split,
		// face 0 needs to be multiplied by its crease's reflection matrix, but
		// only for valley or mountain folds, "flat" folds need to copy the matrix
		let face0_preMatrix = face0.matrix;
		// only if the assignment is valley or mountain, do this. otherwise skip
		if (assignment !== opposite_assignment) {
			face0_preMatrix = (!face0_was_split && !graph.faces_side[0]
				? face0.matrix
				: multiplyMatrices2(
					face0.matrix,
					makeMatrix2Reflect(
						face0.crease.vector,
						face0.crease.origin,
					),
				)
			);
		}
		// build our new faces_matrices using face 0 as the starting point,
		// setting face 0 as the identity matrix, then multiply every
		// face's matrix by face 0's actual starting matrix
		graph.faces_matrix2 = makeFacesMatrix2(graph, face0_newIndex)
			.map(matrix => multiplyMatrices2(face0_preMatrix, matrix));
		// these are no longer needed. some of them haven't even been fully rebuilt.
		delete graph.faces_center;
		delete graph.faces_winding;
		delete graph.faces_crease;
		delete graph.faces_side;
		// summary of changes to the graph
		return {
			faces: { map: faces_map, remove: faces_remove },
			edges: { map: edges_map },
			// vertices: { new: new_vertices },
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @name Origami
	 * @description A model of an origami paper with the intended functionality
	 * to be used like an origami paper folding a traditional-style origami model,
	 * where the piece is often in a flat-folded state.
	 * Structurally, this is a FOLD object that manages the data and extends the
	 * spec in a couple ways:
	 * - the vertex data will be stored in unfolded (crease pattern) form,
	 * from which the vertices in the folded form can be calculated
	 * - frame_classes: will contain "foldedForm" and never contain "creasePattern"
	 * - frame_attributes: will contain "2D"
	 * - faces_matrix: every face has a 3x2 orientation matrix which describes
	 * the location of the face's vertices in the foldedForm representation.
	 * - faces_layer: a linear topological sorting of the layers in the +Z direction.
	 *
	 * The resulting data model is backwards compatible with the official FOLD spec.
	 * @prototype Graph
	 * @param {FOLD} [graph] an optional FOLD object
	 * @linkcode Origami ./src/classes/origami.js 13
	 */
	const Origami = {};
	Origami.prototype = Object.create(graphProto);
	Origami.prototype.constructor = Origami;

	Origami.prototype.flatFold = function () {
		flatFold(this, getLine$1(arguments));
		return this;
	};

	var origamiProto = Origami.prototype;

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// values to FOLD file keys maintained by this software
	const file_spec = 1.1;
	const file_creator = "Rabbit Ear";

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const make_rect_vertices_coords = (w, h) => [[0, 0], [w, 0], [w, h], [0, h]];
	/**
	 * @description given an already initialized vertices_coords array,
	 * create a fully-populated graph that sets these vertices to be
	 * the closed boundary of a polygon.
	 */
	const make_closed_polygon = (vertices_coords) => populate({
		vertices_coords,
		edges_vertices: vertices_coords
			.map((_, i, arr) => [i, (i + 1) % arr.length]),
		edges_assignment: Array(vertices_coords.length).fill("B"),
	});

	// const polygon_names = [
	// 	undefined,
	// 	undefined,
	// 	undefined,
	// 	"triangle",
	// 	undefined,
	// 	"pentagon",
	// 	"hexagon",
	// 	"heptagon",
	// 	"octagon",
	// 	"nonagon",
	// 	"decagon",
	// 	"hendecagon",
	// 	"dodecagon"
	// ];
	/**
	 * create an array/object with only the keys and polygon names used below.
	 */
	// polygon_names
	// 	.map((str, i) => str === undefined ? i : undefined)
	// 	.filter(a => a !== undefined)
	// 	.forEach(i => delete polygon_names[i]);
	/**
	 * fill the "Create" object with constructors under polygon-named keys.
	 */
	/**
	 * @description make vertices_coords for a regular polygon,
	 * centered at the origin and with side lengths of 1,
	 * except for square, centered at [0.5, 0.5]
	 * @param {number} number of sides of the desired regular polygon
	 * @returns {number[][]} 2D vertices_coords, vertices of the polygon
	 */
	// polygon_names.forEach((name, i) => {
	// 	Create[name] = () => make_closed_polygon(math
	// 		.makePolygonSideLength(i));
	// });
	/**
	 * special cases
	 *
	 * square and rectangle are axis-aligned with one vertex at (0, 0)
	 * circle asks for # of sides, and also sets radius to be 1,
	 *  instead of side-length to be 1.
	 */
	/**
	 * @description Create a new FOLD object which contains one square face,
	 * including vertices and boundary edges.
	 * @param {number} [scale=1] the length of the sides.
	 * @returns {FOLD} a FOLD object
	 */
	const square = (scale = 1) => (
		make_closed_polygon(make_rect_vertices_coords(scale, scale)));
	/**
	 * @description Create a new FOLD object which contains one rectangular face,
	 * including vertices and boundary edges.
	 * @param {number} [width=1] the width of the rectangle
	 * @param {number} [height=1] the height of the rectangle
	 * @returns {FOLD} a FOLD object
	 */
	const rectangle = (width = 1, height = 1) => (
		make_closed_polygon(make_rect_vertices_coords(width, height)));
	/**
	 * @description Create a new FOLD object with a regular-polygon shaped boundary.
	 * @param {number} [sides=3] the number of sides to the polygon
	 * @param {number} [circumradius=1] the circumradius of the polygon (the
	 * distance from the center to any vertex)
	 * @returns {FOLD} a FOLD object
	 */
	const polygon = (sides = 3, circumradius = 1) => (
		make_closed_polygon(makePolygonCircumradius(sides, circumradius)));
	/**
	 * @description Create a kite base FOLD object in crease pattern form.
	 * @returns {FOLD} a FOLD object
	 */
	const kite = () => populate({
		vertices_coords: [
			[0, 0], [1, 0], [1, Math.SQRT2 - 1], [1, 1], [Math.SQRT2 - 1, 1], [0, 1],
		],
		edges_vertices: [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 0], [0, 2], [0, 4], [0, 3]],
		edges_assignment: Array.from("BBBBBBVVF"),
	});
	/**
	 * @description Create a fish base FOLD object in crease pattern form.
	 * @returns {FOLD} a FOLD object
	 */
	const fish = () => populate({
		vertices_coords: [
			[0, 0], [1, 0], [1, 1], [0, 1], [0.5, 0.5], [1 - Math.SQRT1_2, Math.SQRT1_2],
			[Math.SQRT1_2, 1 - Math.SQRT1_2], [1, 1 - Math.SQRT1_2],
			[1 - Math.SQRT1_2, 1], [Math.SQRT1_2, 0], [0, Math.SQRT1_2],
		],
		edges_vertices: [
			[0, 4], [4, 2], [4, 5], [5, 3], [0, 5], [1, 6], [6, 4], [0, 6],
			[2, 5], [2, 6], [1, 7], [7, 2], [6, 7], [2, 8], [8, 3], [5, 8],
			[0, 9], [9, 1], [6, 9], [3, 10], [10, 0], [5, 10],
		],
		edges_assignment: Array.from("FFFVVVFVVVBBFBBFBBMBBM"),
		faces_vertices: [
			[7, 6, 1], [6, 7, 2], [6, 2, 4], [6, 4, 0], [6, 0, 9], [6, 9, 1],
			[2, 5, 4], [5, 2, 8], [5, 8, 3], [5, 3, 10], [5, 10, 0], [5, 0, 4],
		],
	});

	var bases = /*#__PURE__*/Object.freeze({
		__proto__: null,
		fish: fish,
		kite: kite,
		polygon: polygon,
		rectangle: rectangle,
		square: square
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const graph = (...args) => populate(
		Object.assign(Object.create(graphProto), {
			...args.reduce((a, b) => ({ ...a, ...b }), ({})),
			file_spec,
			file_creator,
		}),
	);

	const cp = (...args) => populate(
		Object.assign(Object.create(cpProto), {
			...(args.length
				? args.reduce((a, b) => ({ ...a, ...b }), ({}))
				: square()),
			file_spec,
			file_creator,
			frame_classes: ["creasePattern"],
		}),
	);

	const origami = (...args) => populate(
		Object.assign(Object.create(origamiProto), {
			...(args.length
				? args.reduce((a, b) => ({ ...a, ...b }), ({}))
				: square()),
			file_spec,
			file_creator,
			frame_classes: ["foldedForm"],
		}),
	);

	graph.prototype = graphProto;
	graph.prototype.constructor = graph;

	cp.prototype = cpProto;
	cp.prototype.constructor = cp;

	origami.prototype = origamiProto;
	origami.prototype.constructor = origami;

	// static constructors for all the origami bases
	Object.keys(bases).forEach(fnName => {
		graph[fnName] = (...args) => graph(bases[fnName](...args));
		cp[fnName] = (...args) => cp(bases[fnName](...args));
		origami[fnName] = (...args) => origami(bases[fnName](...args));
	});

	/**
	 * Rabbit Ear (c) Kraft
	 * this section contains code from Robert Lang's Reference Finder
	 */
	/*           _                       _              _
							(_)                     (_)            (_)
		 ___  _ __ _  __ _  __ _ _ __ ___  _    __ ___  ___  ___  _ __ ___  ___
		/ _ \| '__| |/ _` |/ _` | '_ ` _ \| |  / _` \ \/ / |/ _ \| '_ ` _ \/ __|
	 | (_) | |  | | (_| | (_| | | | | | | | | (_| |>  <| | (_) | | | | | \__ \
		\___/|_|  |_|\__, |\__,_|_| |_| |_|_|  \__,_/_/\_\_|\___/|_| |_| |_|___/
									__/ |
								 |___/
	*/
	const intersectionUD = (line1, line2) => {
		const det = cross2(line1.normal, line2.normal);
		if (Math.abs(det) < EPSILON) { return undefined; }
		const x = line1.distance * line2.normal[1] - line2.distance * line1.normal[1];
		const y = line2.distance * line1.normal[0] - line1.distance * line2.normal[0];
		return [x / det, y / det];
	};
	/**
	 * @description origami axiom 1: form a line that passes between the given points
	 * @param {number[]} point1 one 2D point
	 * @param {number[]} point2 one 2D point
	 * @returns {[UniqueLine]} an array of one solution line in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 38
	 */
	const normalAxiom1 = (point1, point2) => {
		const normal = normalize2(rotate90(subtract2(point2, point1)));
		return [{
			normal,
			distance: dot2(add2(point1, point2), normal) / 2.0,
		}];
	};
	/**
	 * @description origami axiom 2: form a perpendicular bisector between the given points
	 * @param {number[]} point1 one 2D point
	 * @param {number[]} point2 one 2D point
	 * @returns {[UniqueLine]} an array of one solution line in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 52
	 */
	const normalAxiom2 = (point1, point2) => {
		const normal = normalize2(subtract2(point2, point1));
		return [{
			normal,
			distance: dot2(add2(point1, point2), normal) / 2.0,
		}];
	};
	/**
	 * @description origami axiom 3: form two lines that make the two angular bisectors between
	 * two input lines, and in the case of parallel inputs only one solution will be given
	 * @param {UniqueLine} line1 one 2D line in {normal, distance} form
	 * @param {UniqueLine} line2 one 2D line in {normal, distance} form
	 * @returns {[UniqueLine?, UniqueLine?]} an array of solutions in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 67
	 */
	const normalAxiom3 = (line1, line2) => {
		// if no intersect, lines are parallel, only one solution exists
		const intersect = intersectionUD(line1, line2);
		return intersect === undefined
			? [{
				normal: line1.normal,
				distance: (line1.distance + line2.distance * dot2(line1.normal, line2.normal)) / 2,
			}]
			: [add2, subtract2]
				.map(f => normalize2(f(line1.normal, line2.normal)))
				.map(normal => ({ normal, distance: dot2(intersect, normal) }));
	};
	/**
	 * @description origami axiom 4: form a line perpendicular to a given line that
	 * passes through a point.
	 * @param {UniqueLine} line one 2D line in {normal, distance} form
	 * @param {number[]} point one 2D point
	 * @returns {[UniqueLine]} an array of one solution in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 87
	 */
	const normalAxiom4 = (line, point) => {
		const normal = rotate90(line.normal);
		const distance = dot2(point, normal);
		return [{ normal, distance }];
	};
	/**
	 * @description origami axiom 5: form up to two lines that pass through a point that also
	 * brings another point onto a given line
	 * @param {UniqueLine} line one 2D line in {normal, distance} form
	 * @param {number[]} point1 one 2D point, the point that the line(s) pass through
	 * @param {number[]} point2 one 2D point, the point that is being brought onto the line
	 * @returns {[UniqueLine?, UniqueLine?]} an array of solutions in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 101
	 */
	const normalAxiom5 = (line, point1, point2) => {
		const p1base = dot2(point1, line.normal);
		const a = line.distance - p1base;
		const c = distance2(point1, point2);
		if (a > c) { return []; }
		const b = Math.sqrt(c * c - a * a);
		const a_vec = scale2(line.normal, a);
		const base_center = add2(point1, a_vec);
		const base_vector = scale2(rotate90(line.normal), b);
		// if b is near 0 we have one solution, otherwise two
		const mirrors = b < EPSILON
			? [base_center]
			: [add2(base_center, base_vector), subtract2(base_center, base_vector)];
		return mirrors
			.map(pt => normalize2(subtract2(point2, pt)))
			.map(normal => ({ normal, distance: dot2(point1, normal) }));
	};

	// cube root preserve sign
	const cubrt = n => (n < 0
		? -Math.pow(-n, 1 / 3)
		: Math.pow(n, 1 / 3));

	// Robert Lang's cubic solver from Reference Finder
	// https://langorigami.com/article/referencefinder/
	const polynomial = (degree, a, b, c, d) => {
		switch (degree) {
		case 1: return [-d / c];
		case 2: {
			// quadratic
			const discriminant = Math.pow(c, 2.0) - (4.0 * b * d);
			// no solution
			if (discriminant < -EPSILON) { return []; }
			// one solution
			const q1 = -c / (2.0 * b);
			if (discriminant < EPSILON) { return [q1]; }
			// two solutions
			const q2 = Math.sqrt(discriminant) / (2.0 * b);
			return [q1 + q2, q1 - q2];
		}
		case 3: {
			// cubic
			// Cardano's formula. convert to depressed cubic
			const a2 = b / a;
			const a1 = c / a;
			const a0 = d / a;
			const q = (3.0 * a1 - Math.pow(a2, 2.0)) / 9.0;
			const r = (9.0 * a2 * a1 - 27.0 * a0 - 2.0 * Math.pow(a2, 3.0)) / 54.0;
			const d0 = Math.pow(q, 3.0) + Math.pow(r, 2.0);
			const u = -a2 / 3.0;
			// one solution
			if (d0 > 0.0) {
				const sqrt_d0 = Math.sqrt(d0);
				const s = cubrt(r + sqrt_d0);
				const t = cubrt(r - sqrt_d0);
				return [u + s + t];
			}
			// two solutions
			if (Math.abs(d0) < EPSILON) {
				const s = Math.pow(r, 1.0 / 3.0);
				// const S = cubrt(R);
				// instead of checking if S is NaN, check if R was negative
				// if (isNaN(S)) { break; }
				if (r < 0.0) { return []; }
				return [u + 2.0 * s, u - s];
			}
			// three solutions
			const sqrt_d0 = Math.sqrt(-d0);
			const phi = Math.atan2(sqrt_d0, r) / 3.0;
			const r_s = Math.pow((Math.pow(r, 2.0) - d0), 1.0 / 6.0);
			const s_r = r_s * Math.cos(phi);
			const s_i = r_s * Math.sin(phi);
			return [
				u + 2.0 * s_r,
				u - s_r - Math.sqrt(3.0) * s_i,
				u - s_r + Math.sqrt(3.0) * s_i,
			];
		}
		default: return [];
		}
	};
	/**
	 * @description origami axiom 6: form up to three lines that are made by bringing
	 * a point to a line and a second point to a second line.
	 * @param {UniqueLine} line1 one 2D line in {normal, distance} form
	 * @param {UniqueLine} line2 one 2D line in {normal, distance} form
	 * @param {number[]} point1 the point to bring to the first line
	 * @param {number[]} point2 the point to bring to the second line
	 * @returns {[UniqueLine?, UniqueLine?, UniqueLine?]} an array of solutions
	 * in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 192
	 */
	const normalAxiom6 = (line1, line2, point1, point2) => {
		// at least pointA must not be on lineA
		// for some reason this epsilon is much higher than 1e-6
		if (Math.abs(1.0 - (dot2(line1.normal, point1) / line1.distance)) < 0.02) { return []; }
		// line vec is the first line's vector, along the line, not the normal
		const line_vec = rotate90(line1.normal);
		const vec1 = subtract2(
			add2(point1, scale2(line1.normal, line1.distance)),
			scale2(point2, 2.0),
		);
		const vec2 = subtract2(scale2(line1.normal, line1.distance), point1);
		const c1 = dot2(point2, line2.normal) - line2.distance;
		const c2 = 2.0 * dot2(vec2, line_vec);
		const c3 = dot2(vec2, vec2);
		const c4 = dot2(add2(vec1, vec2), line_vec);
		const c5 = dot2(vec1, vec2);
		const c6 = dot2(line_vec, line2.normal);
		const c7 = dot2(vec2, line2.normal);
		const a = c6;
		const b = c1 + c4 * c6 + c7;
		const c = c1 * c2 + c5 * c6 + c4 * c7;
		const d = c1 * c3 + c5 * c7;
		// construct the solution from the root, the solution being the parameter
		// point reflected across the fold line, lying on the parameter line
		let polynomial_degree = 0;
		if (Math.abs(c) > EPSILON) { polynomial_degree = 1; }
		if (Math.abs(b) > EPSILON) { polynomial_degree = 2; }
		if (Math.abs(a) > EPSILON) { polynomial_degree = 3; }
		return polynomial(polynomial_degree, a, b, c, d)
			.map(n => add2(
				scale2(line1.normal, line1.distance),
				scale2(line_vec, n),
			))
			.map(p => ({ p, normal: normalize2(subtract2(p, point1)) }))
			.map(el => ({
				normal: el.normal,
				distance: dot2(el.normal, midpoint2(el.p, point1)),
			}));
	};
	/**
	 * @description origami axiom 7: form a line by bringing a point onto a given line
	 * while being perpendicular to another given line.
	 * @param {UniqueLine} line1 one 2D line in {normal, distance} form,
	 * the line the point will be brought onto.
	 * @param {UniqueLine} line2 one 2D line in {normal, distance} form,
	 * the line which the perpendicular will be based off.
	 * @param {number[]} point the point to bring onto the line
	 * @returns {[UniqueLine?]} an array of one solution in {normal, distance} form
	 * @linkcode Origami ./src/axioms/axiomsNormDist.js 243
	 */
	const normalAxiom7 = (line1, line2, point) => {
		const normal = rotate90(line1.normal);
		const norm_norm = dot2(normal, line2.normal);
		// if norm_norm is close to 0, the two input lines are parallel, no solution
		if (Math.abs(norm_norm) < EPSILON) { return undefined; }
		const a = dot2(point, normal);
		const b = dot2(point, line2.normal);
		const distance = (line2.distance + 2.0 * a * norm_norm - b) / (2.0 * norm_norm);
		return [{ normal, distance }];
	};
	/**
	 * @description Perform one of the seven origami axioms
	 * @param {number} number the axiom number, 1-7
	 * @param {line?} line1 a line parameter, if required by the axiom
	 * @param {line?} line2 a line parameter, if required by the axiom
	 * @param {number[]?} point1 a point parameter, if required by the axiom
	 * @param {number[]?} point2 a point parameter, if required by the axiom
	 * @returns {UniqueLine[]} an array of solution lines in {normal, distance} form
	 * @linkcode Origami ./src/axioms/validate.js 234
	 */
	const normalAxiom = (number, ...args) => [
		null,
		normalAxiom1,
		normalAxiom2,
		normalAxiom3,
		normalAxiom4,
		normalAxiom5,
		normalAxiom6,
		normalAxiom7,
	][number](...args);

	var AxiomsUniqueLine = /*#__PURE__*/Object.freeze({
		__proto__: null,
		normalAxiom: normalAxiom,
		normalAxiom1: normalAxiom1,
		normalAxiom2: normalAxiom2,
		normalAxiom3: normalAxiom3,
		normalAxiom4: normalAxiom4,
		normalAxiom5: normalAxiom5,
		normalAxiom6: normalAxiom6,
		normalAxiom7: normalAxiom7
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/*           _                       _              _
							(_)                     (_)            (_)
		 ___  _ __ _  __ _  __ _ _ __ ___  _    __ ___  ___  ___  _ __ ___  ___
		/ _ \| '__| |/ _` |/ _` | '_ ` _ \| |  / _` \ \/ / |/ _ \| '_ ` _ \/ __|
	 | (_) | |  | | (_| | (_| | | | | | | | | (_| |>  <| | (_) | | | | | \__ \
		\___/|_|  |_|\__, |\__,_|_| |_| |_|_|  \__,_/_/\_\_|\___/|_| |_| |_|___/
									__/ |
								 |___/
	/**
	 * these origami axioms assume 2D geometry in the 2D plane,
	 * where points are parameterized as vectors (Javascript arrays of numbers)
	 * and lines are in vector-origin form (Javascript objects with "origin" and "vector")
	 *   (themselves are Javascript Arrays, same as "points")
	 * where the direction of the vector is along the line, and
	 * is not necessarily normalized.
	 */

	/**
	 * @description origami axiom 1: form a line that passes between the given points
	 * @param {number[]} point1 one 2D point
	 * @param {number[]} point2 one 2D point
	 * @returns {[VecLine]} an array of one solution line in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 45
	 */
	const axiom1 = (point1, point2) => [{
		vector: normalize2(subtract2(...resizeUp(point2, point1))),
		origin: point1,
	}];
	/**
	 * @description origami axiom 2: form a perpendicular bisector between the given points
	 * @param {number[]} point1 one 2D point
	 * @param {number[]} point2 one 2D point
	 * @returns {[VecLine]} an array of one solution line in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 56
	 */
	const axiom2 = (point1, point2) => [{
		vector: normalize2(rotate90(subtract2(
			...resizeUp(point2, point1),
		))),
		origin: midpoint2(point1, point2),
	}];
	// todo: make sure these all get a resizeUp or whatever is necessary
	/**
	 * @description origami axiom 3: form two lines that make the two angular bisectors between
	 * two input lines, and in the case of parallel inputs only one solution will be given
	 * @param {VecLine} line1 one 2D line in {vector, origin} form
	 * @param {VecLine} line2 one 2D line in {vector, origin} form
	 * @returns {[VecLine?, VecLine?]} an array of lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 71
	 */
	const axiom3 = (line1, line2) => bisectLines2(line1, line2);
	/**
	 * @description origami axiom 4: form a line perpendicular to a given line that
	 * passes through a point.
	 * @param {VecLine} line one 2D line in {vector, origin} form
	 * @param {number[]} point one 2D point
	 * @returns {[VecLine]} the line in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 80
	 */
	const axiom4 = (line, point) => [{
		vector: rotate90(normalize2(line.vector)),
		origin: point,
	}];
	/**
	 * @description origami axiom 5: form up to two lines that pass through a point that also
	 * brings another point onto a given line
	 * @param {VecLine} line one 2D line in {vector, origin} form
	 * @param {number[]} point1 one 2D point, the point that the line(s) pass through
	 * @param {number[]} point2 one 2D point, the point that is being brought onto the line
	 * @returns {[VecLine, VecLine?]} an array of lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 93
	 */
	const axiom5 = (line, point1, point2) => (
		intersectCircleLine(
			{ radius: distance2(point1, point2), origin: point1 },
			line,
		) || []).map(sect => ({
		vector: normalize2(rotate90(subtract2(
			...resizeUp(sect, point2),
		))),
		origin: midpoint2(point2, sect),
	}));
	/**
	 * @description origami axiom 6: form up to three lines that are made by bringing
	 * a point to a line and a second point to a second line.
	 * @param {VecLine} line1 one 2D line in {vector, origin} form
	 * @param {VecLine} line2 one 2D line in {vector, origin} form
	 * @param {number[]} point1 the point to bring to the first line
	 * @param {number[]} point2 the point to bring to the second line
	 * @returns {[VecLine?, VecLine?, VecLine?]} an array of lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 113
	 */
	const axiom6 = (line1, line2, point1, point2) => normalAxiom6(
		vecLineToUniqueLine(line1),
		vecLineToUniqueLine(line2),
		point1,
		point2,
	).map(uniqueLineToVecLine);
	// .map(Constructors.line);
	/**
	 * @description origami axiom 7: form a line by bringing a point onto a given line
	 * while being perpendicular to another given line.
	 * @param {VecLine} line1 one 2D line in {vector, origin} form,
	 * the line the point will be brought onto.
	 * @param {VecLine} line2 one 2D line in {vector, origin} form,
	 * the line which the perpendicular will be based off.
	 * @param {number[]} point the point to bring onto the line
	 * @returns {[VecLine?]} the line in {vector, origin} form
	 * or undefined if the given lines are parallel
	 * @linkcode Origami ./src/axioms/axiomsVecOrigin.js 132
	 */
	const axiom7 = (line1, line2, point) => {
		const intersect = intersectLineLine(
			line1,
			{ vector: line2.vector, origin: point },
			includeL,
			includeL,
		);
		return intersect === undefined
			? []
			: [{
			// todo: switch this out, but test it as you do
				vector: normalize2(rotate90(subtract2(
					...resizeUp(intersect, point),
				))),
				// vector: normalize2(rotate90(line2.vector)),
				origin: midpoint2(point, intersect),
			}];
	};
	/**
	 * @description Perform one of the seven origami axioms
	 * @param {number} number the axiom number, 1-7
	 * @param {number[] | VecLine} ...args the axiom input parameters
	 * @returns {VecLine[]} an array of solution lines in {vector, origin} form
	 * @linkcode Origami ./src/axioms/validate.js 234
	 */
	const axiom$1 = (number, ...args) => [
		null, axiom1, axiom2, axiom3, axiom4, axiom5, axiom6, axiom7,
	][number](...args);

	// * @param {line?} line1 a line parameter, if required by the axiom
	// * @param {line?} line2 a line parameter, if required by the axiom
	// * @param {number[]?} point1 a point parameter, if required by the axiom
	// * @param {number[]?} point2 a point parameter, if required by the axiom

	var AxiomsVecLine = /*#__PURE__*/Object.freeze({
		__proto__: null,
		axiom: axiom$1,
		axiom1: axiom1,
		axiom2: axiom2,
		axiom3: axiom3,
		axiom4: axiom4,
		axiom5: axiom5,
		axiom6: axiom6,
		axiom7: axiom7
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const reflectPoint = (foldLine, point) => {
		const matrix = makeMatrix2Reflect(foldLine.vector, foldLine.origin);
		return multiplyMatrix2Vector2(matrix, point);
	};
	/**
	 * @description To validate axiom 1 check if the input points are inside the
	 * boundary polygon, if so, the solution is valid.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {number[]} point1 the point parameter for axiom 1
	 * @param {number[]} point2 the point parameter for axiom 1
	 * @returns {boolean} true if the solution is valid
	 * @linkcode Origami ./src/axioms/validate.js 40
	 */
	const validateAxiom1 = (boundary, solutions, point1, point2) => [point1, point2]
		.map(p => overlapConvexPolygonPoint(boundary, p, include))
		.reduce((a, b) => a && b, true);
	/**
	 * @description To validate axiom 2 check if the input points are inside the
	 * boundary polygon, if so, the solution is valid.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {number[]} point1 the point parameter for axiom 2
	 * @param {number[]} point2 the point parameter for axiom 2
	 * @returns {boolean} true if the solution is valid
	 * @linkcode Origami ./src/axioms/validate.js 51
	 */
	const validateAxiom2 = validateAxiom1;
	/**
	 * @description Validate axiom 3.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {VecLine} line1 the line parameter for axiom 3
	 * @param {VecLine} line2 the line parameter for axiom 3
	 * @returns {boolean[]} array of booleans (true if valid) matching the solutions array
	 * @linkcode Origami ./src/axioms/validate.js 60
	 */
	const validateAxiom3 = (boundary, solutions, line1, line2) => {
		const segments = [line1, line2]
			.map(line => clipLineConvexPolygon(
				boundary,
				line,
				include,
				includeL,
			));
		// if line parameters lie outside polygon, no solution possible
		if (segments[0] === undefined || segments[1] === undefined) {
			return [false, false];
		}
		// test A:
		// make sure the results themselves lie in the polygon
		// exclusive! an exterior line collinear to polygon's point is excluded
		// const results_clip = results
		//   .map(line => line === undefined ? undefined : math
		//     .intersectConvexPolygonLine(
		//       boundary,
		//       line,
		//       includeS,
		//       excludeL));
		const results_clip = solutions.map(line => (line === undefined
			? undefined
			: clipLineConvexPolygon(
				boundary,
				line,
				include,
				includeL,
			)));
		const results_inside = [0, 1].map((i) => results_clip[i] !== undefined);
		// test B:
		// make sure that for each of the results, the result lies between two
		// of the parameters, in other words, reflect the segment 0 both ways
		// (both fold solutions) and make sure there is overlap with segment 1
		const seg0Reflect = solutions.map(foldLine => (foldLine === undefined
			? undefined
			: [
				reflectPoint(foldLine, segments[0][0]),
				reflectPoint(foldLine, segments[0][1]),
			]));
		const reflectMatch = seg0Reflect.map(seg => (seg === undefined
			? false
			: (overlapLinePoint(
				{ vector: subtract(segments[1][1], segments[1][0]), origin: segments[1][0] },
				seg[0],
				includeS,
			)
			|| overlapLinePoint(
				{ vector: subtract(segments[1][1], segments[1][0]), origin: segments[1][0] },
				seg[1],
				includeS,
			)
			|| overlapLinePoint(
				{ vector: subtract(seg[1], seg[0]), origin: seg[0] },
				segments[1][0],
				includeS,
			)
			|| overlapLinePoint(
				{ vector: subtract(seg[1], seg[0]), origin: seg[0] },
				segments[1][1],
				includeS,
			))));
		// valid if A and B
		return [0, 1].map(i => reflectMatch[i] === true && results_inside[i] === true);
	};
	/**
	 * @description To validate axiom 4 check if the input point lies within
	 * the boundary and the intersection between the solution line and the
	 * input line lies within the boundary.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {VecLine} line the line parameter for axiom 4
	 * @param {number[]} point the point parameter for axiom 4
	 * @returns {boolean} true if the solution is valid
	 * @linkcode Origami ./src/axioms/validate.js 135
	 */
	const validateAxiom4 = (boundary, solutions, line, point) => {
		const intersect = intersectLineLine(
			line,
			{ vector: rotate90(line.vector), origin: point },
			includeL,
			includeL,
		);
		return [point, intersect]
			.filter(a => a !== undefined)
			.map(p => overlapConvexPolygonPoint(boundary, p, include))
			.reduce((a, b) => a && b, true);
	};
	/**
	 * @description Validate axiom 5.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {VecLine} line the line parameter for axiom 5
	 * @param {number[]} point1 the point parameter for axiom 5
	 * @param {number[]} point2 the point parameter for axiom 5
	 * @returns {boolean[]} array of booleans (true if valid) matching the solutions array
	 * @linkcode Origami ./src/axioms/validate.js 155
	 */
	const validateAxiom5 = (boundary, solutions, line, point1, point2) => {
		if (solutions.length === 0) { return []; }
		const testParamPoints = [point1, point2]
			.map(point => overlapConvexPolygonPoint(boundary, point, include))
			.reduce((a, b) => a && b, true);
		const testReflections = solutions
			.map(foldLine => reflectPoint(foldLine, point2))
			.map(point => overlapConvexPolygonPoint(boundary, point, include));
		return testReflections.map(ref => ref && testParamPoints);
	};
	/**
	 * @description Validate axiom 6.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {VecLine} line1 the line parameter for axiom 6
	 * @param {VecLine} line2 the line parameter for axiom 6
	 * @param {number[]} point1 the point parameter for axiom 6
	 * @param {number[]} point2 the point parameter for axiom 6
	 * @returns {boolean[]} array of booleans (true if valid) matching the solutions array
	 * @linkcode Origami ./src/axioms/validate.js 173
	 */
	const validateAxiom6 = function (boundary, solutions, line1, line2, point1, point2) {
		if (solutions.length === 0) { return []; }
		const testParamPoints = [point1, point2]
			.map(point => overlapConvexPolygonPoint(boundary, point, include))
			.reduce((a, b) => a && b, true);
		if (!testParamPoints) { return solutions.map(() => false); }
		const testReflect0 = solutions
			.map(foldLine => reflectPoint(foldLine, point1))
			.map(point => overlapConvexPolygonPoint(boundary, point, include));
		const testReflect1 = solutions
			.map(foldLine => reflectPoint(foldLine, point2))
			.map(point => overlapConvexPolygonPoint(boundary, point, include));
		return solutions.map((_, i) => testReflect0[i] && testReflect1[i]);
	};
	/**
	 * @description Validate axiom 7.
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {VecLine} line1 the line parameter for axiom 7
	 * @param {VecLine} line2 the line parameter for axiom 7
	 * @param {number[]} point the point parameter for axiom 7
	 * @returns {boolean} true if the solution is valid
	 * @linkcode Origami ./src/axioms/validate.js 194
	 */
	const validateAxiom7 = (boundary, solutions, line1, line2, point) => {
		// check if the point parameter is inside the polygon
		const paramPointTest = overlapConvexPolygonPoint(
			boundary,
			point,
			include,
		);
		// check if the reflected point on the fold line is inside the polygon
		if (!solutions.length) { return [false]; }
		const reflected = reflectPoint(solutions[0], point);
		const reflectTest = overlapConvexPolygonPoint(boundary, reflected, include);
		// check if the line to fold onto itself is somewhere inside the polygon
		const paramLineTest = (intersectConvexPolygonLine(
			boundary,
			line2,
			includeS,
			includeL,
		) !== undefined);
		// same test we do for axiom 4
		const intersect = intersectLineLine(
			line2,
			solutions[0],
			includeL,
			includeL,
		);
		const intersectInsideTest = intersect
			? overlapConvexPolygonPoint(boundary, intersect, include)
			: false;
		return paramPointTest && reflectTest && paramLineTest && intersectInsideTest;
	};
	/**
	 * @description Validate an axiom, this will run one of
	 * the submethods ("validateAxiom1", "validateAxiom2", ...).
	 * @param {number} number the axiom number, 1-7
	 * @param {number[][]} boundary an array of points, each point is an array of numbers
	 * @param {VecLine[]} solutions an array of solutions in vector-origin form
	 * @param {number[] | VecLine} ...args the input parameters to the axiom method
	 * @returns {boolean|boolean[]} for every solution, true if valid. Axioms 1, 2, 4, 7
	 * return one boolean, 3, 5, 6 return arrays of booleans.
	 * @linkcode Origami ./src/axioms/validate.js 234
	 */
	const validateAxiom = (number, boundary, solutions, ...args) => [null,
		validateAxiom1,
		validateAxiom2,
		validateAxiom3,
		validateAxiom4,
		validateAxiom5,
		validateAxiom6,
		validateAxiom7,
	][number](boundary, solutions, ...args);

	var ValidateAxioms = /*#__PURE__*/Object.freeze({
		__proto__: null,
		validateAxiom: validateAxiom,
		validateAxiom1: validateAxiom1,
		validateAxiom2: validateAxiom2,
		validateAxiom3: validateAxiom3,
		validateAxiom4: validateAxiom4,
		validateAxiom5: validateAxiom5,
		validateAxiom6: validateAxiom6,
		validateAxiom7: validateAxiom7
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const paramsToUniqueLine = (args) => args
		.map(arg => (typeof arg === "object" && arg.vector
			? uniqueLineToVecLine(arg)
			: arg));
	/**
	 * @description Perform one of the seven origami axioms, and provide a boundary so that
	 * only the results possible inside the boundary will be returned.
	 * @param {number} number the axiom number, 1-7. **note, 0 is not an option**
	 * @param {number[][]} boundary the bounding polygon representing the folding material
	 * @param {any[][]} ...args the input parameters to the axiom number, points or lines
	 * @returns {VecLine[]} an array of solutions as lines, or an empty array if no solutions.
	 * @linkcode Origami ./src/axioms/axiomsInBoundary.js 33
	 */
	const axiomWithBoundary = (number, boundary, ...args) => {
		const solutions = axiom$1(number, ...args);
		validateAxiom(number, boundary, solutions, ...args)
			.forEach((valid, i) => (valid ? i : undefined))
			.filter(a => a !== undefined)
			.forEach(i => delete solutions[i]);
		return solutions;
	};
	/**
	 * @description Perform one of the seven origami axioms, and provide a boundary so that
	 * only the results possible inside the boundary will be returned.
	 * @param {number} number the axiom number, 1-7. **note, 0 is not an option**
	 * @param {number[][]} boundary the bounding polygon representing the folding material
	 * @param {any[][]} ...args the input parameters to the axiom number, points or lines
	 * @returns {UniqueLine[]} an array of solutions as lines, or an empty array if no solutions.
	 * @linkcode Origami ./src/axioms/axiomsInBoundary.js 58
	 */
	const normalAxiomWithBoundary = (number, boundary, ...args) => {
		const solutions = normalAxiom(number, ...args).map(uniqueLineToVecLine);
		validateAxiom(number, boundary, solutions, ...paramsToUniqueLine(args))
			.forEach((valid, i) => (valid ? i : undefined))
			.filter(a => a !== undefined)
			.forEach(i => delete solutions[i]);
		return solutions;
	};

	var AxiomsBoundary = /*#__PURE__*/Object.freeze({
		__proto__: null,
		axiomWithBoundary: axiomWithBoundary,
		normalAxiomWithBoundary: normalAxiomWithBoundary
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	var axiom = {
		...AxiomsVecLine,
		...AxiomsUniqueLine,
		...AxiomsBoundary,
		...ValidateAxioms,
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const newFoldFile = () => {
		const graph = {};
		graph.file_spec = file_spec;
		graph.file_creator = file_creator;
		graph.file_classes = ["singleModel"];
		graph.frame_classes = [];
		graph.frame_attributes = [];
		graph.vertices_coords = [];
		graph.faces_vertices = [];
		return graph;
	};

	const updateMetadata = (graph) => {
		if (!graph.edges_foldAngle || !graph.edges_foldAngle.length) { return; }
		let is2D = true;
		for (let i = 0; i < graph.edges_foldAngle.length; i += 1) {
			if (graph.edges_foldAngle[i] !== 0
				&& graph.edges_foldAngle[i] !== -180
				&& graph.edges_foldAngle[i] !== 180) {
				is2D = false;
				break;
			}
		}
		graph.frame_classes.push(is2D ? "creasePattern" : "foldedForm");
		graph.frame_attributes.push(is2D ? "2D" : "3D");
	};

	const pairify = (list) => list.map((val, i, arr) => [val, arr[(i + 1) % arr.length]]);

	const makeEdgesVertices = ({ faces_vertices }) => {
		const edgeExists = {};
		const edges_vertices = [];
		faces_vertices
			.flatMap(pairify)
			.forEach(edge => {
				const keys = [edge.join(" "), `${edge[1]} ${edge[0]}`];
				if (keys[0] in edgeExists || keys[1] in edgeExists) { return; }
				edges_vertices.push(edge);
				edgeExists[keys[0]] = true;
			});
		return edges_vertices;
	};

	const parseFace = (face) => face
		.slice(1)
		.map(str => parseInt(str, 10) - 1);

	const parseVertex = (vertex) => vertex
		.slice(1)
		.map(str => parseFloat(str));
	/**
	 * @description Convert an OBJ mesh file into a FOLD object. The conversion
	 * will create edge definitions and give them assignments and fold angles
	 * depending on the dihedral angles, or boundary edges if only one face is adjacent.
	 * @param {string} file a string containing the contents of an OBJ file,
	 * expected to contain at least vertices and faces. All groups or object
	 * separations are currently ignored, the contents are treated as one object.
	 * @returns {FOLD} a FOLD representation of the OBJ file
	 * @linkcode Origami ./src/convert/obj.js 77
	 */
	const objToFold = (file) => {
		const lines = file.split("\n").map(line => line.trim().split(/\s+/));
		const graph = newFoldFile();
		for (let i = 0; i < lines.length; i += 1) {
			// groups and objects ("g", "o") separation is currently ignored
			switch (lines[i][0].toLowerCase()) {
			case "f": graph.faces_vertices.push(parseFace(lines[i])); break;
			case "v": graph.vertices_coords.push(parseVertex(lines[i])); break;
			}
		}
		graph.faces_normal = makeFacesNormal(graph);
		graph.faces_center = makeFacesConvexCenter(graph);
		graph.edges_vertices = makeEdgesVertices(graph);
		graph.faces_edges = makeFacesEdgesFromVertices(graph);
		// graph.edges_faces = makeEdgesFaces(graph);
		graph.edges_faces = makeEdgesFacesUnsorted(graph);
		graph.edges_foldAngle = makeEdgesFoldAngleFromFaces(graph);
		graph.edges_assignment = makeEdgesAssignment(graph);
		graph.vertices_vertices = makeVerticesVerticesFromFaces(graph);
		// faces_normal and faces_center are not a part of the spec.
		// edges_faces was built unsorted. the sorted method is slower to construct,
		// and unnecessary for our purposes. the user can build this (and the
		// other incomplete fields) if they want them.
		delete graph.faces_normal;
		delete graph.faces_center;
		delete graph.edges_faces;
		updateMetadata(graph);
		return graph;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Resolve all crossing edges, build faces,
	 * walk and discover the boundary.
	 */
	const planarizeGraph = (graph, epsilon) => {
		const planar = { ...graph };
		removeDuplicateVertices(planar, epsilon);
		planarize(planar, epsilon);
		planar.vertices_vertices = makeVerticesVertices(planar);
		const faces = makePlanarFaces(planar);
		planar.faces_vertices = faces.faces_vertices;
		planar.faces_edges = faces.faces_edges;
		return planar;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const shortestEdgeLength = (graph) => {
		const lengths = graph.edges_vertices
			.map(ev => ev.map(v => graph.vertices_coords[v]))
			.map(segment => distance(...segment));
		const minLen = lengths
			.reduce((a, b) => Math.min(a, b), Infinity);
		return minLen === Infinity ? undefined : minLen;
	};

	const makeEpsilon = (graph) => {
		const shortest = shortestEdgeLength(graph);
		if (shortest) { return shortest / 4; }
		const bounds = boundingBox(graph);
		return bounds && bounds.span
			? 1e-3 * Math.max(...bounds.span)
			: 1e-3;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const findEpsilonInObject = (graph, object, key = "epsilon") => {
		if (typeof object === "object" && typeof object[key] === "number") {
			return object[key];
		}
		return typeof object === "number"
			? object
			: makeEpsilon(graph);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a parsed xml object, get the branch which
	 * contains a node which has some node containing the value specified.
	 */
	const getContainingValue = (oripa, value) => (oripa == null
		? null
		: Array.from(oripa.childNodes)
			.filter(el => el.attributes && el.attributes.length)
			.filter(el => Array.from(el.attributes)
				.filter(attr => attr.nodeValue === value)
				.shift() !== undefined)
			.shift());
	/**
	 * @description There are top level nodes which contain metadata,
	 * I'm not sure how many there are, but at least I've seen:
	 * memo, originalAuthorName, title
	 */
	const getMetadataValue = (oripa, value) => {
		const parentNode = getContainingValue(oripa, value);
		const node = parentNode
			? Array.from(parentNode.childNodes).shift()
			: null;
		return node
			? node.textContent
			: undefined;
	};
	/**
	 * @description Get all line elements from the OPX file.
	 */
	const getLines = (oripa) => {
		const linesParent = getContainingValue(oripa, "lines");
		const linesNode = linesParent
			? Array.from(linesParent.childNodes)
				.filter(el => el.getAttribute)
				.filter(el => el.getAttribute("class").split(" ").includes("oripa.OriLineProxy"))
				.shift()
			: undefined;
		return linesNode ? Array.from(linesNode.childNodes) : [];
	};
	/**
	 * @description For each ORIPA line, extract the coordinates
	 * and the assignment type. Return each line as a simple
	 * Javascript object. XML Entries will be missing if
	 * their value is 0, this is taken care of. All values will be
	 * parsed into floats.
	 * @param {object[]} lines the result of calling getLines()
	 */
	const parseLines = (lines) => lines
		.filter(line => line.nodeName === "void")
		.filter(line => line.childNodes)
		.map(line => getContainingValue(line, "oripa.OriLineProxy"))
		.filter(lineData => lineData)
		.map(lineData => ["type", "x0", "x1", "y0", "y1"]
			.map(key => getContainingValue(lineData, key))
			.map(el => (el ? Array.from(el.childNodes) : []))
			.map(children => children
				.filter(child => child.nodeName === "double" || child.nodeName === "int")
				.shift())
			.map(node => (node && node.childNodes[0] ? node.childNodes[0].data : "0"))
			.map(parseFloat));
	/**
	 * @description ORIPA line assignments are numbered.
	 */
	const opxAssignment = ["F", "B", "M", "V", "U"];

	const makeFOLD = (lines) => {
		const fold = {};
		fold.vertices_coords = lines
			.flatMap(line => [[line[1], line[3]], [line[2], line[4]]]);
		fold.edges_vertices = lines.map((_, i) => [i * 2, i * 2 + 1]);
		fold.edges_assignment = lines.map(line => opxAssignment[line[0]]);
		fold.edges_foldAngle = makeEdgesFoldAngle(fold);
		return fold;
	};
	/**
	 * @param {string} file an ORIPA file as a string
	 */
	const opxEdgeGraph = (file) => {
		const parsed = xmlStringToElement(file, "text/xml");
		const oripa = Array.from(parsed.childNodes)
			.filter(el => el.getAttribute)
			.filter(el => el.getAttribute("class").split(" ").includes("oripa.DataSet"))
			.shift();
		return makeFOLD(parseLines(getLines(oripa)));
	};

	const setMetadata = (oripa, fold) => {
		const metadata = {
			file_description: "memo",
			file_author: "originalAuthorName",
			file_title: "title",
		};
		Object.keys(metadata).forEach(key => {
			metadata[key] = getMetadataValue(oripa, metadata[key]);
		});
		Object.keys(metadata)
			.filter(key => metadata[key])
			.forEach(key => { fold[key] = metadata[key]; });
		fold.file_classes = ["singleModel"];
		fold.frame_classes = ["creasePattern"];
	};
	/**
	 * @description Convert an ORIPA file into a FOLD object
	 * @param {string} file an ORIPA file as a string
	 * @param {number | object} options an epsilon or an options object
	 * used to merge nearby vertices
	 * @returns {FOLD} a FOLD representation of the ORIPA file
	 */
	const opxToFold = (file, options) => {
		const parsed = xmlStringToElement(file, "text/xml");
		const children = parsed && parsed.childNodes
			? Array.from(parsed.childNodes)
			: [];
		const oripa = children
			.filter(el => el.getAttribute)
			.filter(el => el.getAttribute("class").split(" ").includes("oripa.DataSet"))
			.shift();
		const graph = makeFOLD(parseLines(getLines(oripa)));
		// analysis on vertices_coords to find an appropriate epsilon
		const epsilon = findEpsilonInObject(graph, options);
		const planarGraph = planarizeGraph(graph, epsilon);
		setMetadata(oripa, planarGraph);
		return planarGraph;
	};

	Object.assign(opxToFold, {
		opxEdgeGraph,
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * How desaturated can a color be but still be considered
	 * a color instead of a grayscale value? please be: 0 < n < Inf.
	 * 1 means nothing is changed. >1 is permissive
	 * and between 0 and 1 is not permissive.
	 */
	const DESATURATION_RATIO = 4;

	const assignmentColor = {
		M: [1, 0, 0], // red
		V: [0, 0, 1], // blue
		J: [1, 1, 0], // yellow
		U: [1, 0, 1], // magenta
		C: [0, 1, 0], // green
		// and "boundary" and "flat" are black and gray
	};
	/**
	 * @description The color scheme that was established in Origami Simulator.
	 * @param {number} red the red channel from 0 to 255
	 * @param {number} green the green channel from 0 to 255
	 * @param {number} blue the blue channel from 0 to 255
	 */
	const rgbToAssignment = (red = 0, green = 0, blue = 0) => {
		const color = scale3([red, green, blue], 1 / 255);
		// the distance to black (0, 0, 0)
		const blackDistance = magnitude3(color);
		// if the distance to black is too small, it's difficult
		// to infer any color information. the color implies "boundary".
		if (blackDistance < 0.05) { return "B"; }
		// the nearest grayscale value
		const grayscale = color.reduce((a, b) => a + b, 0) / 3;
		// the distance from the color to the nearest grayscale value
		const grayDistance = distance3(color, [grayscale, grayscale, grayscale]);
		// the nearest color from "assignmentColor" to this color
		const nearestColor = Object.keys(assignmentColor)
			.map(key => ({ key, dist: distance3(color, assignmentColor[key]) }))
			.sort((a, b) => a.dist - b.dist)
			.shift();
		// the color is allowed to be heavily desaturated, closer to the gray
		// version of itself, and still count as the color instead of the gray.
		if (nearestColor.dist < grayDistance * DESATURATION_RATIO) {
			return nearestColor.key;
		}
		// is it black or gray? more permissivly select gray over black.
		// boundary might also be decided later by planar walk.
		return blackDistance < 0.1 ? "B" : "F";
	};

	var foldColors = /*#__PURE__*/Object.freeze({
		__proto__: null,
		assignmentColor: assignmentColor,
		rgbToAssignment: rgbToAssignment
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const colorToAssignment = (color, customAssignments) => {
		const hex = parseColorToHex(color).toUpperCase();
		return customAssignments && customAssignments[hex]
			? customAssignments[hex]
			: rgbToAssignment(...parseColorToRgb(color));
	};
	/**
	 *
	 */
	const opacityToFoldAngle = (opacity, assignment) => {
		switch (assignment) {
		case "M": case "m": return -180 * opacity;
		case "V": case "v": return 180 * opacity;
		// "F", "B", "U", "C", opacity value doesn't matter.
		default: return 0;
		}
	};
	/**
	 *
	 */
	const getEdgeStroke = (element, attributes) => {
		const computedStroke = RabbitEarWindow().getComputedStyle(element).stroke;
		if (computedStroke !== "" && computedStroke !== "none") {
			return computedStroke;
		}
		if (attributes.stroke !== undefined) {
			return attributes.stroke;
		}
		return undefined;
	};
	/**
	 *
	 */
	const getEdgeOpacity = (element, attributes) => {
		const computedOpacity = RabbitEarWindow().getComputedStyle(element).opacity;
		if (computedOpacity !== "") {
			const floatOpacity = parseFloat(computedOpacity);
			if (!Number.isNaN(floatOpacity)) { return floatOpacity; }
		}
		if (attributes.opacity !== undefined) {
			const floatOpacity = parseFloat(attributes.opacity);
			if (!Number.isNaN(floatOpacity)) { return floatOpacity; }
		}
		return undefined;
	};

	var edgeParsers = /*#__PURE__*/Object.freeze({
		__proto__: null,
		colorToAssignment: colorToAssignment,
		getEdgeOpacity: getEdgeOpacity,
		getEdgeStroke: getEdgeStroke,
		opacityToFoldAngle: opacityToFoldAngle
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// SVG is allowed to leave out coordinates with an implied value of 0
	const getAttributesFloatValue = (element, attributes) => attributes
		.map(attr => element.getAttribute(attr))
		.map(str => (str == null ? 0 : str))
		.map(parseFloat);

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const LineToSegments = (line) => [
		getAttributesFloatValue(line, ["x1", "y1", "x2", "y2"]),
	];

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const RectToSegments = function (rect) {
		const [x, y, w, h] = getAttributesFloatValue(
			rect,
			["x", "y", "width", "height"],
		);
		return [
			[x, y, x + w, y],
			[x + w, y, x + w, y + h],
			[x + w, y + h, x, y + h],
			[x, y + h, x, y],
		];
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const pointsStringToArray = str => {
		const list = str.split(/[\s,]+/).map(parseFloat);
		return Array
			.from(Array(Math.floor(list.length / 2)))
			.map((_, i) => [list[i * 2 + 0], list[i * 2 + 1]]);
	};

	// export const pointStringToArray = function (str) {
	// 	return str.split(/[\s,]+/)
	// 		.filter(s => s !== "")
	// 		.map(p => p.split(",")
	// 			.map(n => parseFloat(n)));
	// };

	const PolygonToSegments = (poly) => (
		pointsStringToArray(poly.getAttribute("points") || "")
			.map((_, i, arr) => [
				arr[i][0],
				arr[i][1],
				arr[(i + 1) % arr.length][0],
				arr[(i + 1) % arr.length][1],
			])
	);

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const PolylineToSegments = function (polyline) {
		const circularPath = PolygonToSegments(polyline);
		circularPath.pop();
		return circularPath;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const straightPathLines = {
		L: true, V: true, H: true, Z: true,
	};

	const PathToSegments = (path) => (
		parsePathCommandsWithEndpoints(path.getAttribute("d") || "")
			.filter(command => straightPathLines[command.command.toUpperCase()])
			.map(el => [el.start, el.end])
			.filter(seg => !epsilonEqualVectors(...seg))
			.map(seg => seg.flat())
	);

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given an svg drawing element, convert
	 * it into an array of line segments {number[][]} where
	 * each segment is an array of 4 values: x1, y1, x2, y2.
	 * @param {Element[]} elements a flat array of svg drawing elements
	 * @returns {object[]} an array of line segement objects, each with
	 * "segment" and "attributes" properties.
	 */
	const parsers = {
		line: LineToSegments,
		rect: RectToSegments,
		polygon: PolygonToSegments,
		polyline: PolylineToSegments,
		path: PathToSegments,
		// circle: CircleToSegments,
		// ellipse: EllipseToSegments,
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const transformSegment = (segment, transform) => {
		const seg = [[segment[0], segment[1]], [segment[2], segment[3]]];
		if (!transform) { return seg; }
		const matrix = transformStringToMatrix(transform);
		return matrix
			? seg.map(p => multiplyMatrix2Vector2(matrix, p))
			: seg;
	};
	/**
	 * @description Get a flat array of all elements in the tree, with all
	 * styles also flattened (nested transformed computed, for example)
	 * convert all elements <path> <rect> etc into arrays of line segments
	 */
	const flatSegments = (svgElement) => flattenDomTreeWithStyle(svgElement)
		.filter(el => parsers[el.element.nodeName])
		.flatMap(el => parsers[el.element.nodeName](el.element)
			.map(segment => transformSegment(segment, el.attributes.transform))
			.map(segment => ({ ...el, segment })));

	const invisibleParent = (child) => {
		if (!RabbitEarWindow().document.body) { return undefined; }

		// create an invisible element, add the svg, then call getComputedStyle
		const parent = RabbitEarWindow().document.createElement("div");

		// visibility:hidden causes the DOM window layout to resize
		parent.setAttribute("display", "none");
		// parent.setAttribute("visibility", "hidden");

		RabbitEarWindow().document.body.appendChild(parent);

		parent.appendChild(child);
		return parent;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description does an Element contain a <style> as a child somewhere?
	 * @returns {boolean}
	 */
	const containsStylesheet = (svgElement) => flattenDomTree(svgElement)
		.map(el => el.nodeName === "style")
		.reduce((a, b) => a || b, false);
	/**
	 * @description Given an SVG element (as a string or Element object),
	 * Extract all straight lines from the SVG, including those inside of
	 * complex path objects. Return the straight lines as a flat array with
	 * additional attribute information.
	 * @param {Element | string} svg an SVG image as a DOM element
	 * or a string.
	 * @returns {object[]} array of objects, one for each straight line segment
	 * with these values:
	 * - .element a pointer to the element that this segment comes from.
	 * - .attributes the attributes of the element as a Javascript object.
	 *    this includes those which were inherited from its parents
	 * - .segment a pair of vertices, the endpoints of the segment.
	 * - .data two "data-" attributes representing assignment and foldAngle.
	 * - .stroke the stroke attribute taken from getComputedStyle if possible.
	 * - .opacity the opacity attribute taken from getComputedStyle if possible.
	 */
	const svgSegments = (svg) => {
		const svgElement = typeof svg === "string"
			? xmlStringToElement(svg, "image/svg+xml")
			: svg;

		if (containsStylesheet(svgElement) && isNode) {
			console.warn(Messages$1.backendStylesheet);
		}
		// ensure the svg is a child of the DOM so we can call getComputedStyle.
		// If the element is already a child of the HTML document, do nothing.
		const parent = getRootParent(svgElement) === RabbitEarWindow().document
			? undefined
			: invisibleParent(svgElement);

		const segments = flatSegments(svgElement);
		segments.map(el => ({
			data: {
				assignment: el.attributes["data-assignment"],
				foldAngle: el.attributes["data-foldAngle"],
			},
			stroke: getEdgeStroke(el.element, el.attributes),
			opacity: getEdgeOpacity(el.element, el.attributes),
		})).forEach((addition, i) => {
			segments[i] = {
				...segments[i],
				...addition,
			};
		});

		// we no longer need computed style, remove invisible svg from DOM.
		if (parent && parent.parentNode) {
			parent.parentNode.removeChild(parent);
		}

		return segments;
	};

	/* Math (c) Kraft, MIT License */
	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Count the number of places deep past the decimal point.
	 * @param {number} num any number
	 * @returns {number} an integer, the number of decimal digits.
	 * @linkcode Math ./src/general/numbers.js 8
	 */
	const countPlaces = function (num) {
		const m = (`${num}`).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
		return Math.max(0, (m[1] ? m[1].length : 0) - (m[2] ? +m[2] : 0));
	};
	/**
	 * @description clean floating point numbers, where 15.0000000000000002 becomes 15,
	 * this method involves encoding and parsing so it is relatively expensive.
	 * @param {number} num the floating point number to clean
	 * @param {number} [places=15] the whole number of decimal places to
	 * keep, beyond this point can be considered to be noise.
	 * @returns {number} the cleaned floating point number
	 */
	const cleanNumber = function (num, places = 15) {
		if (typeof num !== "number") { return num; }
		const crop = parseFloat(num.toFixed(places));
		if (countPlaces(crop) === Math.min(places, countPlaces(num))) {
			return num;
		}
		return crop;
	};

	var number = /*#__PURE__*/Object.freeze({
		__proto__: null,
		cleanNumber: cleanNumber
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 *
	 */
	const getUserAssignmentOptions = (options) => {
		if (!options || !options.assignments) { return undefined; }
		const assignments = {};
		Object.keys(options.assignments).forEach(key => {
			const hex = parseColorToHex(key).toUpperCase();
			assignments[hex] = options.assignments[key];
		});
		return assignments;
	};
	/**
	 *
	 */
	const getEdgeAssignment = (dataAssignment, stroke = "#f0f", customAssignments = undefined) => {
		if (dataAssignment) { return dataAssignment; }
		return colorToAssignment(stroke, customAssignments);
	};
	/**
	 *
	 */
	const getEdgeFoldAngle = (dataFoldAngle, opacity = 1, assignment = undefined) => {
		if (dataFoldAngle) { return parseFloat(dataFoldAngle); }
		return opacityToFoldAngle(opacity, assignment);
	};
	/**
	 *
	 */
	const makeAssignmentFoldAngle = (segments, options) => {
		// if the user provides a dictionary of custom stroke-assignment
		// matches, this takes precidence over the "data-" attribute
		// todo: this can be improved
		const customAssignments = getUserAssignmentOptions(options);
		// if user specified customAssignments, ignore the data- attributes
		// otherwise the user's assignments would be ignored.
		if (customAssignments) {
			segments.forEach(seg => {
				delete seg.data.assignment;
				delete seg.data.foldAngle;
			});
		}
		// convert SVG data into FOLD arrays
		const edges_assignment = segments.map(segment => getEdgeAssignment(
			segment.data.assignment,
			segment.stroke,
			customAssignments,
		));
		const edges_foldAngle = segments.map((segment, i) => getEdgeFoldAngle(
			segment.data.foldAngle,
			segment.opacity,
			edges_assignment[i],
		));
		return {
			edges_assignment,
			edges_foldAngle,
		};
	};
	/**
	 * @description This method will handle all of the SVG parsing
	 * and result in a very simple graph representation basically
	 * only containing line segments and their assignment/foldAngle.
	 * The graph will not be planar (edges will overlap), no faces
	 * will exist, and duplicate vertices will exist and need to
	 * be merged
	 * @param {Element | string} svg an SVG image as a DOM element
	 * or a string.
	 * @returns {FOLD} a FOLD representation of the SVG image, not
	 * yet a planar graph, no faces, and possible edge overlaps.
	 */
	const svgEdgeGraph = (svg, options) => {
		const segments = svgSegments(svg);
		const {
			edges_assignment,
			edges_foldAngle,
		} = makeAssignmentFoldAngle(segments, options);
		// by default the parser will change numbers 15.000000000001 into 15.
		// to turn this off, options.fast = true
		const fixNumber = options && options.fast ? n => n : cleanNumber;
		const vertices_coords = segments
			.flatMap(el => el.segment)
			.map(coord => coord.map(n => fixNumber(n, 12)));
		const edges_vertices = segments.map((_, i) => [i * 2, i * 2 + 1]);
		return {
			vertices_coords,
			edges_vertices,
			edges_assignment,
			edges_foldAngle,
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Convert an SVG to a FOLD object. This only works
	 * with SVGs of crease patterns, this will not work
	 * with an SVG of a folded form.
	 * @param {string | SVGElement} file the SVG element as a
	 * document element node, or as a string
	 * @param {number | object} options an options object or an epsilon number
	 * @returns {FOLD} a FOLD representation of the SVG
	 */
	const svgToFold = (file, options) => {
		const graph = svgEdgeGraph(file, options);
		const epsilon = findEpsilonInObject(graph, options);
		const planarGraph = planarizeGraph(graph, epsilon);
		// optionally, discover the boundary by walking.
		if (typeof options !== "object" || options.boundary !== false) {
			// clear all previous boundary assignments and set them to flat.
			// this is because both flat and boundary were imported as black
			// colors (grayscale), so the assignment should go to the next in line.
			planarGraph.edges_assignment
				.map((_, i) => i)
				.filter(i => planarGraph.edges_assignment[i] === "B"
					|| planarGraph.edges_assignment[i] === "b")
				.forEach(i => { planarGraph.edges_assignment[i] = "F"; });
			const { edges } = planarBoundary(planarGraph);
			edges.forEach(e => { planarGraph.edges_assignment[e] = "B"; });
		}
		return {
			file_spec: 1.1,
			file_creator: "Rabbit Ear",
			frame_classes: ["creasePattern"],
			...planarGraph,
		};
	};

	Object.assign(svgToFold, {
		...edgeParsers,
		svgSegments,
		svgEdgeGraph,
		planarizeGraph,
		makeEpsilon,
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	var convert = {
		objToFold,
		opxToFold,
		svgToFold,
		foldToSvg,
		foldToObj,
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description todo
	 * @param {FOLD} graph a FOLD graph
	 * @param {number} frame which frame number to expose as the sole contents
	 * @returns {FOLD} the requested frame separated out from the rest of
	 * the graph, inheriting any necessary data if needed.
	 */
	const flattenFrame = (graph, frame_num = 1) => {
		if (!graph.file_frames || graph.file_frames.length < frame_num) {
			return graph;
		}
		const dontCopy = [_frame_parent, _frame_inherit];
		const memo = { visited_frames: [] };
		const fileMetadata = {};
		filterKeysWithPrefix(graph, "file")
			.filter(key => key !== "file_frames")
			.forEach(key => { fileMetadata[key] = graph[key]; });

		const recurse = (recurse_graph, frame, orderArray) => {
			if (memo.visited_frames.indexOf(frame) !== -1) {
				throw new Error(Messages$1.graphCycle);
			}
			memo.visited_frames.push(frame);
			orderArray = [frame].concat(orderArray);
			if (frame === 0) { return orderArray; }
			if (recurse_graph.file_frames[frame - 1].frame_inherit
				&& recurse_graph.file_frames[frame - 1].frame_parent != null) {
				return recurse(
					recurse_graph,
					recurse_graph.file_frames[frame - 1].frame_parent,
					orderArray,
				);
			}
			return orderArray;
		};

		return recurse(graph, frame_num, []).map((frame) => {
			if (frame === 0) {
				// for frame 0 (the key frame) don't copy over file_frames array
				const swap = graph.file_frames;
				graph.file_frames = null;
				const copy = clone(graph);
				graph.file_frames = swap;
				delete copy.file_frames;
				dontCopy.forEach(key => delete copy[key]);
				return copy;
			}
			const outerCopy = clone(graph.file_frames[frame - 1]);
			dontCopy.forEach(key => delete outerCopy[key]);
			return outerCopy;
		}).reduce((a, b) => Object.assign(a, b), fileMetadata);
	};

	const mergeFrame = function (graph, frame) {
		const dontCopy = [_frame_parent, _frame_inherit];
		const copy = clone(frame);
		dontCopy.forEach(key => delete copy[key]);
		// don't deep copy file_frames. stash. bring them back.
		const swap = graph.file_frames;
		graph.file_frames = null;
		const fold = clone(graph);
		graph.file_frames = swap;
		delete fold.file_frames;
		// merge 2
		Object.assign(fold, frame);
		return fold;
	};
	/**
	 * @description Get a shallow copy of the top level frame without "file_frames"
	 */
	const getTopLevelFrame = (graph) => {
		const copy = { ...graph };
		delete copy.file_frames;
		return copy;
	};
	/**
	 * @description Get a flat array of all file_frames, where the top-level
	 * is index 0, and the file_frames follow in sequence.
	 */
	const getFramesAsFlatArray = (graph) => {
		if (!graph.file_frames || !graph.file_frames.length) {
			return [graph];
		}
		return [
			getTopLevelFrame(graph),
			...graph.file_frames,
		];
	};
	/**
	 * @description Get all frames inside a FOLD object which contain a
	 * frame_classes class matching the provided className string
	 * @param {FOLD} graph a FOLD object
	 * @param {string} className the name of the class inside frame_classes
	 * @returns {FOLD[]} an array of FOLD object frames.
	 */
	const getFramesByClassName = (graph, className) => (
		getFramesAsFlatArray(graph)
			.map((f, i) => (f.frame_classes && f.frame_classes.includes(className)
				? i
				: undefined))
			.filter(a => a !== undefined)
			.map(i => flattenFrame(graph, i))
	);

	var foldFileFrames = /*#__PURE__*/Object.freeze({
		__proto__: null,
		flattenFrame: flattenFrame,
		getFramesByClassName: getFramesByClassName,
		mergeFrame: mergeFrame
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Join two planar graphs, creating new vertices, edges, faces.
	 */
	// const joinPlanarGraphs = (...graphs) => {
	// export const joinPlanarGraphs = (graph) => {

	// };

	const VEF = Object.keys(singularize);
	/**
	 *
	 */
	const makeVerticesMapAndConsiderDuplicates = (target, source, epsilon = EPSILON) => {
		let index = target.vertices_coords.length;
		return source.vertices_coords
			.map(vertex => target.vertices_coords
				.map(v => distance(v, vertex) < epsilon)
				.map((onVertex, i) => (onVertex ? i : undefined))
				.filter(a => a !== undefined)
				.shift())
			.map(el => (el === undefined ? index++ : el));
	};
	/**
	 *
	 */
	const getEdgesDuplicateFromSourceInTarget = (target, source) => {
		const source_duplicates = {};
		const target_map = {};
		for (let i = 0; i < target.edges_vertices.length; i += 1) {
			// we need to store both, but only need to test one
			target_map[`${target.edges_vertices[i][0]} ${target.edges_vertices[i][1]}`] = i;
			target_map[`${target.edges_vertices[i][1]} ${target.edges_vertices[i][0]}`] = i;
		}
		for (let i = 0; i < source.edges_vertices.length; i += 1) {
			const index = target_map[`${source.edges_vertices[i][0]} ${source.edges_vertices[i][1]}`];
			if (index !== undefined) {
				source_duplicates[i] = index;
			}
		}
		return source_duplicates;
	};
	/**
	 * @description updateSuffixes
	 * @param {object} FOLD graph
	 * @param {string[]} array of strings like "vertices_edges"
	 * @param {string[]} array of any combination of "vertices", "edges", or "faces"
	 * @param {object} object with keys VEF each with an array of index maps
	 */
	const updateSuffixes = (source, suffixes, keys, maps) => keys
		.forEach(geom => suffixes[geom]
			.forEach(key => source[key]
				.forEach((arr, i) => arr
					.forEach((el, j) => { source[key][i][j] = maps[geom][el]; }))));
	/**
	 * @description join graphs
	 */
	// todo, make the second param ...sources
	const joinGraphs = (target, source, epsilon = EPSILON) => {
		// these all relate to the source, not target
		const prefixes = {};
		const suffixes = {};
		const maps = {};
		const dimensions = [target, source]
			.map(g => g.vertices_coords)
			.map(coords => (coords && coords.length ? coords[0].length : 0))
			.reduce((a, b) => Math.max(a, b));
		target.vertices_coords = target.vertices_coords
			.map(coord => resize(dimensions, coord));
		// gather info
		VEF.forEach(key => {
			prefixes[key] = filterKeysWithPrefix(source, `${key}_`);
			suffixes[key] = filterKeysWithSuffix(source, `_${key}`);
		});
		// if source keys don't exist in the target, create empty arrays
		VEF.forEach(geom => prefixes[geom].filter(key => !target[key]).forEach(key => {
			target[key] = [];
		}));
		// vertex map
		maps.vertices = makeVerticesMapAndConsiderDuplicates(target, source, epsilon);
		// correct indices in all vertex suffixes, like "faces_vertices", "edges_vertices"
		updateSuffixes(source, suffixes, ["vertices"], maps);
		// edge map
		const target_edges_count = count.edges(target);
		maps.edges = Array.from(Array(count.edges(source)))
			.map((_, i) => target_edges_count + i);
		const edge_dups = getEdgesDuplicateFromSourceInTarget(target, source);
		Object.keys(edge_dups).forEach(i => { maps.edges[i] = edge_dups[i]; });
		// faces map
		const target_faces_count = count.faces(target);
		maps.faces = Array.from(Array(count.faces(source)))
			.map((_, i) => target_faces_count + i);
		// todo find duplicate faces, correct map
		// correct indices in all edges and faces suffixes
		updateSuffixes(source, suffixes, ["edges", "faces"], maps);
		// copy all geometry arrays from source to target
		VEF.forEach(geom => prefixes[geom].forEach(key => source[key].forEach((el, i) => {
			const new_index = maps[geom][i];
			target[key][new_index] = el;
		})));
		return maps;
	};

	var join = /*#__PURE__*/Object.freeze({
		__proto__: null,
		joinGraphs: joinGraphs
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description This returns a matrix relating every edge to every vertex,
	 * answering the question "does the vertex sit inside the edge's bounding box?"
	 * It doesn't solve if a vertex lies on an edge, only that it *might* lie along an edge.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon to be added as padding to the bounding boxes
	 * @returns {boolean[][]} array matching edges_ length where each value is
	 * an array matching vertices_ length, containing true/false.
	 * @linkcode Origami ./src/graph/span.js 14
	 */
	const getEdgesVerticesOverlappingSpan = (graph, epsilon = EPSILON) => (
		makeEdgesBoundingBox(graph, epsilon)
			.map(min_max => graph.vertices_coords
				.map(vert => (
					vert[0] > min_max.min[0]
					&& vert[1] > min_max.min[1]
					&& vert[0] < min_max.max[0]
					&& vert[1] < min_max.max[1])))
	);
	/**
	 * @description Calculate every edge's rectangular bounding box and compare every box to
	 * every box to determine if boxes overlap. This doesn't claim edges overlap, only that
	 * their bounding boxes do, and that two edges *might* overlap.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon to be added as padding to the bounding boxes
	 * @returns {boolean[][]} NxN 2D array filled with true/false answering
	 * "do edges's bounding boxes overlap?"
	 * Both triangles of the matrix are filled and the main diagonal contains true.
	 * ```text
	 *     0  1  2  3
	 * 0 [ t,  ,  ,  ]
	 * 1 [  , t,  ,  ]
	 * 2 [  ,  , t,  ]
	 * 3 [  ,  ,  , t]
	 * ```
	 * @linkcode Origami ./src/graph/span.js 41
	 */
	const getEdgesEdgesOverlapingSpans = ({
		vertices_coords, edges_vertices, edges_coords,
	}, epsilon = EPSILON) => {
		const min_max = makeEdgesBoundingBox({ vertices_coords, edges_vertices, edges_coords }, epsilon);
		const span_overlaps = edges_vertices.map(() => []);
		// span_overlaps will be false if no overlap possible, true if overlap is possible.
		for (let e0 = 0; e0 < edges_vertices.length - 1; e0 += 1) {
			for (let e1 = e0 + 1; e1 < edges_vertices.length; e1 += 1) {
				// if first max is less than second min, or second max is less than first min,
				// for both X and Y
				const outside_of = (
					(min_max[e0].max[0] < min_max[e1].min[0] || min_max[e1].max[0] < min_max[e0].min[0])
					&& (min_max[e0].max[1] < min_max[e1].min[1] || min_max[e1].max[1] < min_max[e0].min[1]));
				// true if the spans are not touching. flip for overlap
				span_overlaps[e0][e1] = !outside_of;
				span_overlaps[e1][e0] = !outside_of;
			}
		}
		for (let i = 0; i < edges_vertices.length; i += 1) {
			span_overlaps[i][i] = true;
		}
		return span_overlaps;
	};

	var span = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getEdgesEdgesOverlapingSpans: getEdgesEdgesOverlapingSpans,
		getEdgesVerticesOverlappingSpan: getEdgesVerticesOverlappingSpan
	});

	/**
	 * @description Convert the edges of a graph into (infinite) lines, and
	 * prevent duplicate lines, only generate one line for all collinear edges.
	 * "lines" is an array of lines, in no particular order, and "edges_line"
	 * maps each edge (index) to the index in the "lines" array (value).
	 * @param {FOLD} graph a FOLD graph, can be 2D or 3D.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {{ lines: VecLine[], edges_line: number[] }}
	 */
	const getEdgesLine = (graph, epsilon = EPSILON) => {
		if (!graph.vertices_coords
			|| !graph.edges_vertices
			|| !graph.edges_vertices.length) {
			return { edges_line: [], lines: [] };
		}
		const edgesCoords = makeEdgesCoords(graph);
		const edgesVector = makeEdgesVector(graph).map(normalize);
		const edgesLine = edgesVector
			.map((vector, i) => ({ vector, origin: edgesCoords[i][0] }));
		// the point on the line that is nearest to the origin.
		// when we return the list of lines, these will be used for the origins.
		const edgesNearestToOrigin = edgesLine
			.map(line => nearestPointOnLine(line, [0, 0, 0], clampLine, epsilon));
		// shortest distance from each edge's line to the origin.
		const edgesOriginDistances = edgesNearestToOrigin
			.map(point => magnitude(point));
		// cluster edge indices based on a shared distance-to-origin
		const distanceClusters = clusterScalars(edgesOriginDistances, epsilon);
		// further subcluster the previous clusters based on whether the
		// line's vectors are parallel (these inner clusters share the same line)
		const clusterClustersUnindexed = distanceClusters
			.map(cluster => cluster.map(i => edgesVector[i]))
			.map(cluster => clusterParallelVectors(cluster, epsilon));
		// clusterParallelVectors results in zero-indexed indices relating to
		// their inner cluster arrays. remap these back to the global indices.
		const clusterClusters = clusterClustersUnindexed
			.map((clusters, i) => clusters
				.map(cluster => cluster
					.map(index => distanceClusters[i][index])));
		// get a flat array of all unique lines (one per cluster) found.
		const lines = clusterClusters
			.flatMap(clusters => clusters
				.map(cluster => cluster[0])
				.map(i => ({ vector: edgesVector[i], origin: edgesNearestToOrigin[i] })));
		// for each edge, set the index of its line in the "lines" array.
		const edges_line = [];
		let lineIndex = 0;
		clusterClusters.forEach(clusters => clusters.forEach(cluster => {
			cluster.forEach(i => { edges_line[i] = lineIndex; });
			lineIndex += 1;
		}));
		return {
			lines,
			edges_line,
		};
	};

	var edgesLines = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getEdgesLine: getEdgesLine
	});

	const fixLineDirection = ({ normal, distance }) => (distance < 0
		? ({ normal: flip(normal), distance: -distance })
		: ({ normal, distance }));
	/**
	 * @description Discover the lines of symmetry in a 2D FOLD graph.
	 * All possible lines will be returned and sorted to put the best candidate
	 * for a symmtry line first, with an error value, where 0 is perfect symmetry.
	 * This uses edges in the graph to find a line, if an edge doesn't exist
	 * along the line of symmetry, the line will not be found.
	 * @param {FOLD} graph a FOLD object with 2D vertices
	 * @returns {VecLine[]} array of symmetry lines
	 */
	const findSymmetryLines = (graph, epsilon = EPSILON) => {
		const { lines } = getEdgesLine(graph, epsilon);
		const uniqueLines = lines.map(vecLineToUniqueLine).map(fixLineDirection);
		const linesMatrices = lines
			.map(({ vector, origin }) => makeMatrix2Reflect(vector, origin));
		const reflectionsLines = linesMatrices
			.map(matrix => lines
				.map(({ vector, origin }) => multiplyMatrix2Line2(matrix, vector, origin)));
		const reflectionsUniqueLines = reflectionsLines
			.map(group => group.map(line => (line.vector[0] < 0
				? ({ vector: flip(line.vector), origin: line.origin })
				: line)))
			.map(group => group.map(vecLineToUniqueLine).map(fixLineDirection))
			.map(group => group.concat(uniqueLines));
		const groupsClusters = reflectionsUniqueLines
			.map(group => clusterScalars(group.map(el => el.distance)));
		const groupsClusterClustersUnindexed = groupsClusters
			.map((clusters, g) => clusters
				.map(cluster => cluster.map(i => reflectionsUniqueLines[g][i].normal))
				.map(cluster => clusterParallelVectors(cluster, epsilon)));
		const groupsClusterClusters = groupsClusterClustersUnindexed
			.map((group, g) => group
				.flatMap((clusters, c) => clusters
					.map(cluster => cluster
						.map(index => groupsClusters[g][c][index]))));
		const groupsError = groupsClusterClusters
			.map(group => (group.length - lines.length) / lines.length);
		return groupsError
			.map((error, i) => ({ error, i }))
			.map(el => ({ line: lines[el.i], error: el.error }))
			.sort((a, b) => a.error - b.error);
	};
	/**
	 * @description This method calls findSymmetryLines() and returns the
	 * first value only. Use this if you are confident in your expectations.
	 * This uses edges in the graph to find a line, if an edge doesn't exist
	 * along the line of symmetry, the line will not be found.
	 * @param {FOLD} graph a FOLD object with 2D vertices
	 * @returns {VecLine[]} array of symmetry lines
	 */
	const findSymmetryLine = (graph, epsilon = EPSILON) => (
		findSymmetryLines(graph, epsilon)[0]
	);

	// const bucketVertices = ({ vertices_coords }) => {
	// 	const size = boundingBox({ vertices_coords }).span;
	// 	const bucketID = point => point
	// 		.map((p, i) => Math.floor((p / size[i]) * 100));
	// 	const buckets = [];
	// 	vertices_coords
	// 		.map(coord => bucketID(coord))
	// 		.forEach((id, i) => {
	// 			// get a pointer to the inner-most array inside "buckets"
	// 			let bucket = buckets;
	// 			id.forEach(index => {
	// 				if (!bucket[index]) { bucket[index] = []; }
	// 				bucket = bucket[index];
	// 			});
	// 			bucket.push(i);
	// 		});
	// 	return buckets;
	// };
	//
	// export const findSymmetryLines = (graph, epsilon = EPSILON) => {
	// 	const { lines, edges_line } = getEdgesLine(graph, epsilon);
	// 	const linesMatrices = lines
	// 		.map(({ vector, origin }) => makeMatrix2Reflect(vector, origin));
	// 	const linesCoordsSide = lines
	// 		.map(line => graph.vertices_coords
	// 			.map(coord => cross2(subtract2(coord, line.origin), line.vector) < 0));
	// 	// for each line, a copy of the vertices_coords only on one side of the line
	// 	const linesReflections = lines
	// 		.map((_, i) => graph.vertices_coords
	// 			.map((coord, j) => (linesCoordsSide[i][j]
	// 				? coord
	// 				: multiplyMatrix2Vector2(linesMatrices[i], coord))));
	// 	const linesReflBuckets = linesReflections
	// 		.map((coords, i) => coords
	// 			.filter(point => !overlapLinePoint(lines[i], point)))
	// 		.map(vertices_coords => bucketVertices({ vertices_coords }));
	// 	const lengths = linesReflBuckets
	// 		.map(group => group.flatMap(buckets => buckets.map(bucket => bucket.length)))
	// 		.map(group => group.map(len => len % 2));
	// 	// values between 0 and 1. lower is better.
	// 	// 0 means every vertex aligns with another after reflection
	// 	const groupRating = lengths
	// 		.map(group => (group.length === 0 ? Infinity : group.reduce((a, b) => a + b, 0)))
	// 		.map((sum, i) => sum / linesReflections[i].length)
	// 		.map(n => (Number.isNaN(n) ? 1 : n));
	// 	const validLines = groupRating
	// 		.map((rating, i) => ({ rating, i }))
	// 		.filter(el => el.rating < 0.8)
	// 		.sort((a, b) => a.rating - b.rating)
	// 		.map(el => el.i);
	// 	// console.log("linesReflBuckets", linesReflBuckets);
	// 	// console.log("lengths", lengths);
	// 	// console.log("groupRating", groupRating);
	// 	// console.log("validLines", validLines);
	// 	return validLines.map(i => lines[i]);
	// };

	var symmetry = /*#__PURE__*/Object.freeze({
		__proto__: null,
		findSymmetryLine: findSymmetryLine,
		findSymmetryLines: findSymmetryLines
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Convert an array of indices into an array of array of
	 * indices where each inner array forms a triangle fan: [0, 1, 2, 3, 4]
	 * becomes [[0, 1, 2], [1, 2, 3], [1, 3, 4]].
	 * @param {number[]} indices an array of indices
	 * @returns {number[][]} an array of arrays where the inner arrays are
	 * all of length 3.
	 */
	const makeTriangleFan = (indices) => Array.from(Array(indices.length - 2))
		.map((_, i) => [indices[0], indices[i + 1], indices[i + 2]]);
	/**
	 * @description Triangulate a faces_vertices with the capability to handle
	 * only convex faces. This will increase the number of faces.
	 * @param {FOLD} graph a FOLD object.
	 * @returns {number[][]} faces_vertices where all faces have only 3 vertices
	 */
	const triangulateConvexFacesVertices = ({ faces_vertices }) => faces_vertices
		.flatMap(vertices => (vertices.length < 4
			? [vertices]
			: makeTriangleFan(vertices)));
	/**
	 * @description convert an array of any values into an array of arrays
	 * where each of the inner arrays contains 3 elements.
	 * This assumes the length % 3 is 0, if not, the couple remainders
	 * will be chopped off.
	 * @param {any[]} array an array containing any type
	 * @returns {any[][]} array of arrays where each inner array is length 3.
	 */
	const groupByThree = (array) => (array.length === 3 ? [array] : Array
		.from(Array(Math.floor(array.length / 3)))
		.map((_, i) => [i * 3 + 0, i * 3 + 1, i * 3 + 2]
			.map(j => array[j])));
	/**
	 * @description Triangulate a faces_vertices with the capability to handle
	 * both convex and nonconvex. This will increase the number of faces.
	 * You will need to link a reference to the package "Earcut" by Mapbox.
	 * Earcut is a small and capable library with zero dependencies.
	 * https://www.npmjs.com/package/earcut
	 * @param {FOLD} graph a FOLD object.
	 * @returns {number[][]} faces_vertices where all faces have only 3 vertices
	 */
	const triangulateNonConvexFacesVertices = ({ vertices_coords, faces_vertices }, earcut) => {
		if (!vertices_coords || !vertices_coords.length) {
			throw new Error(Messages$1.nonConvexTriangulation);
		}
		const dimension = vertices_coords[0].length;
		return faces_vertices
			.map(fv => fv.flatMap(v => vertices_coords[v]))
			.map(polygon => earcut(polygon, null, dimension))
			// earcut returns vertices [0...n] local to this one polygon
			// convert these indices back to the face's faces_vertices.
			.map((vertices, i) => vertices
				.map(j => faces_vertices[i][j]))
			.flatMap(res => groupByThree(res));
	};
	/**
	 * @description A subroutine for both convex and non-convex triangulation
	 * methods. This will run just after faces_vertices was modified to contain
	 * only triangulated faces. This method rebuild faces_edges and
	 * add new joined edges edges_vertices, assignment, and foldAngle.
	 * @param {FOLD} graph a FOLD object, modified in place
	 * @returns {FOLD} the same FOLD object as the parameter
	 */
	const rebuildWithNewFaces = (graph) => {
		if (!graph.edges_vertices) { graph.edges_vertices = []; }
		const edgeLookup = makeVerticesToEdgeBidirectional(graph);
		let e = graph.edges_vertices.length;
		// as we traverse the new faces_edges, if we encounter a new edge, add
		// it here in the form of a new edges_vertices
		const newEdgesVertices = [];
		graph.faces_edges = graph.faces_vertices
			.map(vertices => vertices
				.map((v, i, arr) => {
					const edge_vertices = [v, arr[(i + 1) % arr.length]];
					const vertexPair = edge_vertices.join(" ");
					if (vertexPair in edgeLookup) { return edgeLookup[vertexPair]; }
					newEdgesVertices.push(edge_vertices);
					edgeLookup[vertexPair] = e;
					edgeLookup[edge_vertices.reverse().join(" ")] = e;
					return e++;
				}));
		const newEdgeCount = newEdgesVertices.length;
		graph.edges_vertices.push(...newEdgesVertices);
		if (graph.edges_assignment) {
			graph.edges_assignment.push(...Array(newEdgeCount).fill("J"));
		}
		if (graph.edges_foldAngle) {
			graph.edges_foldAngle.push(...Array(newEdgeCount).fill(0));
		}
		if (graph.vertices_vertices) { delete graph.vertices_vertices; }
		if (graph.vertices_edges) { delete graph.vertices_edges; }
		if (graph.vertices_faces) { delete graph.vertices_faces; }
		if (graph.edges_faces) { delete graph.edges_faces; }
		if (graph.faces_faces) { delete graph.faces_faces; }
		if (graph.faceOrders) { delete graph.faceOrders; }
		return graph;
	};
	/**
	 * @description Given a faces_vertices, generate a nextmap which
	 * describes how the faces will change after triangulation,
	 * specifically by triangulateConvexFacesVertices or
	 * triangulateNonConvexFacesVertices.
	 */
	const makeTriangulatedFacesNextMap = ({ faces_vertices }) => {
		let count = 0;
		return faces_vertices
			.map(verts => Math.max(3, verts.length))
			.map(length => Array.from(Array(length - 2)).map(() => count++));
	};
	/**
	 * @description Modify a fold graph so that all faces are triangles.
	 * This will increase the number of faces and edges, and give all
	 * new edges a "J" join assignment.
	 * This method is capable of parsing models with convex faces only without
	 * any additional help. If your model contains non-convex faces, this method
	 * can still triangulate your model, however, you will need to link
	 * a reference to the package "Earcut" by Mapbox. Earcut is a small and
	 * capable library with zero dependencies: https://www.npmjs.com/package/earcut
	 * @param {FOLD} graph a FOLD object, modified in place.
	 * @param {object} earcut an optional reference to the Earcut library
	 * by Mapbox, required to operate on a graph with non-convex faces.
	 * @returns {object} a summary of changes to the input parameter.
	 * @todo preserve faceOrders, match preexisting faces against new ones,
	 * this may create too much unnecessary data but at least it will work.
	 */
	const triangulate = (graph, earcut) => {
		if (!graph.faces_vertices) { return {}; }
		const edgeCount = graph.edges_vertices ? graph.edges_vertices.length : 0;
		const nextMap = makeTriangulatedFacesNextMap(graph);
		graph.faces_vertices = earcut
			? triangulateNonConvexFacesVertices(graph, earcut)
			: triangulateConvexFacesVertices(graph);
		// if the graph did not contain edges_vertices after this method, it will
		rebuildWithNewFaces(graph);
		const newEdges = Array
			.from(Array(graph.edges_vertices.length - edgeCount))
			.map((_, i) => edgeCount + i);
		return {
			faces: { map: nextMap },
			edges: { new: newEdges },
		};
	};

	var triangulateMethods = /*#__PURE__*/Object.freeze({
		__proto__: null,
		triangulate: triangulate,
		triangulateConvexFacesVertices: triangulateConvexFacesVertices,
		triangulateNonConvexFacesVertices: triangulateNonConvexFacesVertices
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description the identity matrix for 3x3 matrices
	 * @constant {number[]}
	 * @default
	 * @linkcode Math ./src/algebra/matrix4.js 19
	 */
	const identity4x4 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
	/**
	 * @description test if a 4x4 matrix is the identity matrix within an epsilon
	 * @param {number[]} m a 4x4 matrix
	 * @returns {boolean} true if the matrix is the identity matrix
	 * @linkcode Math ./src/algebra/matrix4.js 26
	 */
	const isIdentity4x4 = m => identity4x4
		.map((n, i) => Math.abs(n - m[i]) < EPSILON)
		.reduce((a, b) => a && b, true);
	/**
	 * @description multiply one 3D vector by a 4x4 matrix
	 * @param {number[]} m one matrix in array form
	 * @param {number[]} vector in array form
	 * @returns {number[]} the transformed vector
	 * @linkcode Math ./src/algebra/matrix4.js 36
	 */
	const multiplyMatrix4Vector3 = (m, vector) => [
		m[0] * vector[0] + m[4] * vector[1] + m[8] * vector[2] + m[12],
		m[1] * vector[0] + m[5] * vector[1] + m[9] * vector[2] + m[13],
		m[2] * vector[0] + m[6] * vector[1] + m[10] * vector[2] + m[14],
	];
	/**
	 * @description multiply one 3D line by a 4x4 matrix
	 * @param {number[]} m one matrix in array form
	 * @param {number[]} vector the vector of the line
	 * @param {number[]} origin the origin of the line
	 * @returns {VecLine} the transformed line in vector-origin form
	 * @linkcode Math ./src/algebra/matrix4.js 49
	 */
	const multiplyMatrix4Line3 = (m, vector, origin) => ({
		vector: [
			m[0] * vector[0] + m[4] * vector[1] + m[8] * vector[2],
			m[1] * vector[0] + m[5] * vector[1] + m[9] * vector[2],
			m[2] * vector[0] + m[6] * vector[1] + m[10] * vector[2],
		],
		origin: [
			m[0] * origin[0] + m[4] * origin[1] + m[8] * origin[2] + m[12],
			m[1] * origin[0] + m[5] * origin[1] + m[9] * origin[2] + m[13],
			m[2] * origin[0] + m[6] * origin[1] + m[10] * origin[2] + m[14],
		],
	});
	/**
	 * @description multiply two 4x4 matrices together
	 * @param {number[]} m1 the first matrix
	 * @param {number[]} m2 the second matrix
	 * @returns {number[]} one matrix, the product of the two
	 * @linkcode Math ./src/algebra/matrix4.js 68
	 */
	const multiplyMatrices4 = (m1, m2) => [
		m1[0] * m2[0] + m1[4] * m2[1] + m1[8] * m2[2] + m1[12] * m2[3],
		m1[1] * m2[0] + m1[5] * m2[1] + m1[9] * m2[2] + m1[13] * m2[3],
		m1[2] * m2[0] + m1[6] * m2[1] + m1[10] * m2[2] + m1[14] * m2[3],
		m1[3] * m2[0] + m1[7] * m2[1] + m1[11] * m2[2] + m1[15] * m2[3],
		m1[0] * m2[4] + m1[4] * m2[5] + m1[8] * m2[6] + m1[12] * m2[7],
		m1[1] * m2[4] + m1[5] * m2[5] + m1[9] * m2[6] + m1[13] * m2[7],
		m1[2] * m2[4] + m1[6] * m2[5] + m1[10] * m2[6] + m1[14] * m2[7],
		m1[3] * m2[4] + m1[7] * m2[5] + m1[11] * m2[6] + m1[15] * m2[7],
		m1[0] * m2[8] + m1[4] * m2[9] + m1[8] * m2[10] + m1[12] * m2[11],
		m1[1] * m2[8] + m1[5] * m2[9] + m1[9] * m2[10] + m1[13] * m2[11],
		m1[2] * m2[8] + m1[6] * m2[9] + m1[10] * m2[10] + m1[14] * m2[11],
		m1[3] * m2[8] + m1[7] * m2[9] + m1[11] * m2[10] + m1[15] * m2[11],
		m1[0] * m2[12] + m1[4] * m2[13] + m1[8] * m2[14] + m1[12] * m2[15],
		m1[1] * m2[12] + m1[5] * m2[13] + m1[9] * m2[14] + m1[13] * m2[15],
		m1[2] * m2[12] + m1[6] * m2[13] + m1[10] * m2[14] + m1[14] * m2[15],
		m1[3] * m2[12] + m1[7] * m2[13] + m1[11] * m2[14] + m1[15] * m2[15],
	];
	/**
	 * @description calculate the determinant of a 4x4 or 3x3 matrix.
	 * in the case of 4x4, the translation component is ignored.
	 * @param {number[]} m one matrix in array form
	 * @returns {number} the determinant of the matrix
	 * @linkcode Math ./src/algebra/matrix4.js 93
	 */
	const determinant4 = (m) => {
		const A2323 = m[10] * m[15] - m[11] * m[14];
		const A1323 = m[9] * m[15] - m[11] * m[13];
		const A1223 = m[9] * m[14] - m[10] * m[13];
		const A0323 = m[8] * m[15] - m[11] * m[12];
		const A0223 = m[8] * m[14] - m[10] * m[12];
		const A0123 = m[8] * m[13] - m[9] * m[12];
		return (
				m[0] * (m[5] * A2323 - m[6] * A1323 + m[7] * A1223)
			- m[1] * (m[4] * A2323 - m[6] * A0323 + m[7] * A0223)
			+ m[2] * (m[4] * A1323 - m[5] * A0323 + m[7] * A0123)
			- m[3] * (m[4] * A1223 - m[5] * A0223 + m[6] * A0123)
		);
	};
	/**
	 * @description invert a 4x4 matrix
	 * @param {number[]} m one matrix in array form
	 * @returns {number[]|undefined} the inverted matrix, or undefined if not possible
	 * @linkcode Math ./src/algebra/matrix4.js 113
	 */
	const invertMatrix4 = (m) => {
		const det = determinant4(m);
		if (Math.abs(det) < 1e-6 || Number.isNaN(det)
			|| !Number.isFinite(m[12]) || !Number.isFinite(m[13]) || !Number.isFinite(m[14])) {
			return undefined;
		}
		const A2323 = m[10] * m[15] - m[11] * m[14];
		const A1323 = m[9] * m[15] - m[11] * m[13];
		const A1223 = m[9] * m[14] - m[10] * m[13];
		const A0323 = m[8] * m[15] - m[11] * m[12];
		const A0223 = m[8] * m[14] - m[10] * m[12];
		const A0123 = m[8] * m[13] - m[9] * m[12];
		const A2313 = m[6] * m[15] - m[7] * m[14];
		const A1313 = m[5] * m[15] - m[7] * m[13];
		const A1213 = m[5] * m[14] - m[6] * m[13];
		const A2312 = m[6] * m[11] - m[7] * m[10];
		const A1312 = m[5] * m[11] - m[7] * m[9];
		const A1212 = m[5] * m[10] - m[6] * m[9];
		const A0313 = m[4] * m[15] - m[7] * m[12];
		const A0213 = m[4] * m[14] - m[6] * m[12];
		const A0312 = m[4] * m[11] - m[7] * m[8];
		const A0212 = m[4] * m[10] - m[6] * m[8];
		const A0113 = m[4] * m[13] - m[5] * m[12];
		const A0112 = m[4] * m[9] - m[5] * m[8];
		const inv = [
			+(m[5] * A2323 - m[6] * A1323 + m[7] * A1223),
			-(m[1] * A2323 - m[2] * A1323 + m[3] * A1223),
			+(m[1] * A2313 - m[2] * A1313 + m[3] * A1213),
			-(m[1] * A2312 - m[2] * A1312 + m[3] * A1212),
			-(m[4] * A2323 - m[6] * A0323 + m[7] * A0223),
			+(m[0] * A2323 - m[2] * A0323 + m[3] * A0223),
			-(m[0] * A2313 - m[2] * A0313 + m[3] * A0213),
			+(m[0] * A2312 - m[2] * A0312 + m[3] * A0212),
			+(m[4] * A1323 - m[5] * A0323 + m[7] * A0123),
			-(m[0] * A1323 - m[1] * A0323 + m[3] * A0123),
			+(m[0] * A1313 - m[1] * A0313 + m[3] * A0113),
			-(m[0] * A1312 - m[1] * A0312 + m[3] * A0112),
			-(m[4] * A1223 - m[5] * A0223 + m[6] * A0123),
			+(m[0] * A1223 - m[1] * A0223 + m[2] * A0123),
			-(m[0] * A1213 - m[1] * A0213 + m[2] * A0113),
			+(m[0] * A1212 - m[1] * A0212 + m[2] * A0112),
		];
		const invDet = 1.0 / det;
		return inv.map(n => n * invDet);
	};
	const identity4x3 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0]);
	/**
	 * @description make a 4x4 matrix representing a translation in 3D
	 * @param {number} [x=0] the x component of the translation
	 * @param {number} [y=0] the y component of the translation
	 * @param {number} [z=0] the z component of the translation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 167
	 */
	const makeMatrix4Translate = (x = 0, y = 0, z = 0) => [...identity4x3, x, y, z, 1];
	// i0 and i1 direct which columns and rows are filled
	// sgn manages right hand rule
	const singleAxisRotate4 = (angle, origin, i0, i1, sgn) => {
		const mat = makeMatrix4Translate(...origin);
		const cos = Math.cos(angle);
		const sin = Math.sin(angle);
		mat[i0 * 4 + i0] = cos;
		mat[i0 * 4 + i1] = (sgn ? +1 : -1) * sin;
		mat[i1 * 4 + i0] = (sgn ? -1 : +1) * sin;
		mat[i1 * 4 + i1] = cos;
		return mat;
	};

	/**
	 * @description make a 4x4 matrix representing a rotation in 3D around the x-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 189
	 */
	const makeMatrix4RotateX = (angle, origin = [0, 0, 0]) => (
		singleAxisRotate4(angle, origin, 1, 2, true));
	/**
	 * @description make a 4x4 matrix representing a rotation in 3D around the y-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 199
	 */
	const makeMatrix4RotateY = (angle, origin = [0, 0, 0]) => (
		singleAxisRotate4(angle, origin, 0, 2, false));
	/**
	 * @description make a 4x4 matrix representing a rotation in 3D around the z-axis
	 * (allowing you to specify the center of rotation if needed).
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 209
	 */
	const makeMatrix4RotateZ = (angle, origin = [0, 0, 0]) => (
		singleAxisRotate4(angle, origin, 0, 1, true));
	/**
	 * @description make a 4x4 matrix representing a rotation in 3D
	 * around a given vector and around a given center of rotation.
	 * @param {number} angle the angle of rotation in radians
	 * @param {number[]} [vector=[0,0,1]] the axis of rotation
	 * @param {number[]} [origin=[0,0,0]] the center of rotation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 220
	 */
	const makeMatrix4Rotate = (angle, vector = [0, 0, 1], origin = [0, 0, 0]) => {
		const pos = [0, 1, 2].map(i => origin[i] || 0);
		const [x, y, z] = resize(3, normalize(vector));
		const c = Math.cos(angle);
		const s = Math.sin(angle);
		const t = 1 - c;
		const trans = makeMatrix4Translate(-pos[0], -pos[1], -pos[2]);
		const trans_inv = makeMatrix4Translate(pos[0], pos[1], pos[2]);
		return multiplyMatrices4(trans_inv, multiplyMatrices4([
			t * x * x + c,     t * y * x + z * s, t * z * x - y * s, 0,
			t * x * y - z * s, t * y * y + c,     t * z * y + x * s, 0,
			t * x * z + y * s, t * y * z - x * s, t * z * z + c, 0,
			0, 0, 0, 1], trans));
	};
	/**
	 * @description make a 4x4 matrix representing a non-uniform scale.
	 * @param {number[]} [scale=[1,1,1]] non-uniform scaling vector
	 * @param {number[]} [origin=[0,0,0]] the center of transformation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 241
	 */
	const makeMatrix4Scale = (scale = [1, 1, 1], origin = [0, 0, 0]) => [
		scale[0], 0, 0, 0,
		0, scale[1], 0, 0,
		0, 0, scale[2], 0,
		scale[0] * -origin[0] + origin[0],
		scale[1] * -origin[1] + origin[1],
		scale[2] * -origin[2] + origin[2],
		1,
	];
	/**
	 * @description make a 4x4 matrix representing a uniform scale.
	 * @param {number} [scale=1] the uniform scale factor
	 * @param {number[]} [origin=[0,0,0]] the center of transformation
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix3.js 236
	 */
	const makeMatrix4UniformScale = (scale = 1, origin = [0, 0, 0]) => (
		makeMatrix4Scale([scale, scale, scale], origin)
	);
	/**
	 * @description make a 4x4 representing a reflection across a line in the XY plane
	 * This is a 2D operation, assumes everything is in the XY plane.
	 * @param {number[]} vector one 2D vector specifying the reflection axis
	 * @param {number[]} [origin=[0,0]] 2D origin specifying a point of reflection
	 * @returns {number[]} one 4x4 matrix
	 * @linkcode Math ./src/algebra/matrix4.js 258
	 */
	const makeMatrix4ReflectZ = (vector, origin = [0, 0]) => {
		const m = makeMatrix2Reflect(vector, origin);
		return [m[0], m[1], 0, 0, m[2], m[3], 0, 0, 0, 0, 1, 0, m[4], m[5], 0, 1];
	};
	/**
	 * @param {number} FOV field of view in radians
	 * @param {number} aspect aspect ratio
	 * @param {number} near z-near
	 * @param {number} far z-far
	 * @returns {number[]} one 4x4 matrix
	 */
	const makePerspectiveMatrix4 = (FOV, aspect, near, far) => {
		const f = Math.tan(Math.PI * 0.5 - 0.5 * FOV);
		const rangeInv = 1.0 / (near - far);
		return [
			f / aspect, 0, 0, 0,
			0, f, 0, 0,
			0, 0, (near + far) * rangeInv, -1,
			0, 0, near * far * rangeInv * 2, 0,
		];
	};
	/**
	 * @param {number} top
	 * @param {number} right
	 * @param {number} bottom
	 * @param {number} left
	 * @param {number} near
	 * @param {number} far
	 * @returns {number[]} one 4x4 matrix
	 */
	const makeOrthographicMatrix4 = (top, right, bottom, left, near, far) => [
		2 / (right - left), 0, 0, 0,
		0, 2 / (top - bottom), 0, 0,
		0, 0, 2 / (near - far), 0,
		(left + right) / (left - right),
		(bottom + top) / (bottom - top),
		(near + far) / (near - far),
		1,
	];
	/**
	 * @param {number[]} position the location of the camera in 3D space
	 * @param {number[]} target the point in space the camera is looking towards
	 * @param {number[]} up the vector pointing up out the top of the camera.
	 * @returns {number[]} one 4x4 matrix
	 */
	const makeLookAtMatrix4 = (position, target, up) => {
		const zAxis = normalize3(subtract3(position, target));
		const xAxis = normalize3(cross3(up, zAxis));
		const yAxis = normalize3(cross3(zAxis, xAxis));
		return [
			xAxis[0], xAxis[1], xAxis[2], 0,
			yAxis[0], yAxis[1], yAxis[2], 0,
			zAxis[0], zAxis[1], zAxis[2], 0,
			position[0], position[1], position[2], 1,
		];
	};

	var matrix4 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		determinant4: determinant4,
		identity4x4: identity4x4,
		invertMatrix4: invertMatrix4,
		isIdentity4x4: isIdentity4x4,
		makeLookAtMatrix4: makeLookAtMatrix4,
		makeMatrix4ReflectZ: makeMatrix4ReflectZ,
		makeMatrix4Rotate: makeMatrix4Rotate,
		makeMatrix4RotateX: makeMatrix4RotateX,
		makeMatrix4RotateY: makeMatrix4RotateY,
		makeMatrix4RotateZ: makeMatrix4RotateZ,
		makeMatrix4Scale: makeMatrix4Scale,
		makeMatrix4Translate: makeMatrix4Translate,
		makeMatrix4UniformScale: makeMatrix4UniformScale,
		makeOrthographicMatrix4: makeOrthographicMatrix4,
		makePerspectiveMatrix4: makePerspectiveMatrix4,
		multiplyMatrices4: multiplyMatrices4,
		multiplyMatrix4Line3: multiplyMatrix4Line3,
		multiplyMatrix4Vector3: multiplyMatrix4Vector3
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Create a quaternion which represents a rotation from
	 * one 3D vector to another. Quaternion encoded as 0:x, 1:y, 2:z, 3:w.
	 * @param {number[]} u a 3D vector
	 * @param {number[]} v a 3D vector
	 * @returns {number[]} a quaternion representing a rotation
	 */
	const quaternionFromTwoVectors = (u, v) => {
		const w = cross3(u, v);
		const q = [w[0], w[1], w[2], dot(u, v)];
		q[3] += magnitude(q);
		return normalize(q);
	};
	/**
	 * @description Create a 4x4 matrix from a quaternion,
	 * the quaternion encoded as 0:x, 1:y, 2:z, 3:w.
	 * @param {number[]} quaternion a quaternion
	 * @returns {number[]} a 4x4 matrix (array of 16 numbers)
	 */
	const matrix4FromQuaternion = (quaternion) => multiplyMatrices4([
		quaternion[3], quaternion[2], -quaternion[1], quaternion[0],
		-quaternion[2], quaternion[3], quaternion[0], quaternion[1],
		quaternion[1], -quaternion[0], quaternion[3], quaternion[2],
		-quaternion[0], -quaternion[1], -quaternion[2], quaternion[3],
	], [
		quaternion[3], quaternion[2], -quaternion[1], -quaternion[0],
		-quaternion[2], quaternion[3], quaternion[0], -quaternion[1],
		quaternion[1], -quaternion[0], quaternion[3], -quaternion[2],
		quaternion[0], quaternion[1], quaternion[2], quaternion[3],
	]);

	var quaternion = /*#__PURE__*/Object.freeze({
		__proto__: null,
		matrix4FromQuaternion: matrix4FromQuaternion,
		quaternionFromTwoVectors: quaternionFromTwoVectors
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a self-relational array of arrays, for example,
	 * vertices_vertices, edges_edges, faces_faces, where the values in the
	 * inner arrays relate to the indices of the outer array, create
	 * collection groups where each item is included in a group if it
	 * points to another member in that group.
	 * @param {number[][]} array_array an array of arrays of numbers
	 * @returns {number[][]} groups of the indices where each index appears only once
	 * @linkcode Origami ./src/graph/connectedComponents.js 12
	 */
	const connectedComponents = (array_array) => {
		const groups = [];
		const recurse = (index, current_group) => {
			// do not increment groups if this
			if (groups[index] !== undefined) { return 0; }
			groups[index] = current_group;
			array_array[index].forEach(i => recurse(i, current_group));
			// increment group (the index in "groups") for next round
			return 1;
		};
		for (let row = 0, group = 0; row < array_array.length; row += 1) {
			if (!(row in array_array)) { continue; }
			group += recurse(row, group);
		}
		return groups;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Cluster the faces of a graph into groups of face indices where
	 * all faces in the same group lie in the same plane in 3D (but are not
	 * required to overlap).
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} an array of cluster objects where each cluster contains:
	 * a normal vector, a list of face indices, and a matching list indicating
	 * if the face shares the normal vector or the face is flipped 180 degrees.
	 */
	const coplanarFacesGroups = ({
		vertices_coords, faces_vertices,
	}, epsilon = EPSILON) => {
		// face normals will be always 3D
		const faces_normal = makeFacesNormal({ vertices_coords, faces_vertices });
		// for every face, get the indices of all faces with matching normals
		const facesNormalMatch = faces_vertices.map(() => []);
		// todo: n^2. this should be able to be improved. possibly by sorting
		// their dot products, then walking the sorted array, but we have to watch
		// out for degenerate cases and a circular array.
		for (let a = 0; a < faces_vertices.length - 1; a += 1) {
			for (let b = a + 1; b < faces_vertices.length; b += 1) {
				if (a === b) { continue; }
				if (parallelNormalized(faces_normal[a], faces_normal[b], epsilon)) {
					facesNormalMatch[a].push(b);
					facesNormalMatch[b].push(a);
				}
			}
		}
		// create disjoint sets of faces which all share the same normal
		const facesNormalMatchCluster = connectedComponents(facesNormalMatch);
		const normalClustersFaces = invertMap(facesNormalMatchCluster)
			.map(el => (typeof el === "number" ? [el] : el));
		// for each cluster, choose one normal, this normal is now associated with the cluster.
		const normalClustersNormal = normalClustersFaces
			.map(faces => faces_normal[faces[0]]);
		// a face can be a part of a group if the normal is aligned, or 180 flipped.
		// true: aligned. false: flipped
		const faces_clusterAligned = [];
		normalClustersFaces.forEach((faces, i) => faces.forEach(f => {
			faces_clusterAligned[f] = dot3(faces_normal[f], normalClustersNormal[i]) > 0;
		}));
		// using each cluster's shared normal, find the plane (dot prod)
		// for each face. make facesOneVertex always 3D.
		const facesOneVertex = faces_vertices
			.map(fv => vertices_coords[fv[0]])
			.map(point => resize(3, point));
		const normalClustersFacesDot = normalClustersFaces
			.map((faces, i) => faces
				.map(f => dot3(normalClustersNormal[i], facesOneVertex[f])));
		// for every cluster of a shared normal, further divide into clusters where
		// each inner cluster contains faces which share the same plane
		const clustersClusters = normalClustersFacesDot
			.map((dots, i) => clusterScalars(dots)
				.map(cluster => cluster.map(index => normalClustersFaces[i][index])));
		// flatten the data one level.
		// there is no need to return these as nested clusters.
		// before flattening, create a matching array of normals.
		const clustersNormal = clustersClusters
			.flatMap((cluster, i) => cluster
				.map(() => [...normalClustersNormal[i]]));
		const clusters = clustersClusters.flat();
		// get the point in the plane closest to the origin
		const clustersOrigin = clusters
			.map(faces => faces[0])
			.map(face => facesOneVertex[face])
			.map((point, i) => dot3(clustersNormal[i], point))
			.map((mag, i) => scale3(clustersNormal[i], mag));
		// make a plane with the origin and normal
		const clustersPlane = clusters.map((_, i) => ({
			normal: clustersNormal[i],
			origin: clustersOrigin[i],
		}));
		return clusters.map((faces, i) => ({
			faces,
			facesAligned: faces.map(f => faces_clusterAligned[f]),
			plane: clustersPlane[i],
		}));
	};
	/**
	 *
	 */
	const makeFacesPolygon2D = (graph, coplanarFaces, transforms, epsilon) => {
		// make sure we are using 3D points for this next part
		const vertices_coords3D = graph.vertices_coords
			.map(coord => resize(3, coord));
		// polygon-polygon intersection requires faces be the same winding.
		// if the normal is flipped from the group normal, reverse the winding
		const planarSets_polygons3D = coplanarFaces
			.map(cluster => cluster.faces
				.map((f, i) => (cluster.facesAligned[i]
					? graph.faces_vertices[f]
					: graph.faces_vertices[f].slice().reverse()))
				.map(verts => verts.map(v => vertices_coords3D[v]))
				.map(polygon => makePolygonNonCollinear(polygon, epsilon)));
		// rotate the polygon into the XY plane (though it will still be
		// translated in the +/- Z axis), so we just remove the Z value.
		const faces_polygon = [];
		const planarSets_polygons2D = planarSets_polygons3D
			.map((cluster, i) => cluster
				.map(points => points
					.map(point => multiplyMatrix4Vector3(transforms[i], point))
					.map(point => [point[0], point[1]])));
		coplanarFaces
			.map(cluster => cluster.faces)
			.forEach((faces, i) => faces
				.forEach((face, j) => {
					faces_polygon[face] = planarSets_polygons2D[i][j];
				}));
		return faces_polygon;
	};
	/**
	 * @description Cluster the faces of a graph into groups of face indices
	 * where all faces in the same group both lie in the same plane and
	 * overlap or are edge-connected to at least one face in the group.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a large object containing:
	 * - sets_plane: the plane defining each set
	 * - sets_transformXY: the transform that takes each set's plane into the XY
	 * - faces_set: for every face, which set does it belong to
	 * - faces_winding: for every face, is it counterclockwise in the plane
	 * - faces_facesOverlap: for every face, what are the other faces
	 * which overlap this face.
	 */
	const coplanarOverlappingFacesGroups = ({
		vertices_coords, faces_vertices, faces_faces,
	}, epsilon = EPSILON) => {
		if (!faces_faces) {
			faces_faces = makeFacesFaces({ faces_vertices });
		}
		// get our initial groups of faces which share a common plane in 3D
		const coplanarFaces = coplanarFacesGroups(
			{ vertices_coords, faces_vertices },
			epsilon,
		);
		// each group will have a plane normal. within this plane, faces can be
		// upright or flipped over. set faces_winding (true: counter-clockwise).
		// "faces_winding" can be one flat array containing all faces as faces
		// will only ever be in one group, they will only have one "flipped" state.
		const faces_winding = [];
		coplanarFaces.forEach(cluster => cluster.facesAligned
			.forEach((aligned, j) => { faces_winding[cluster.faces[j]] = aligned; }));
		// all polygon sets will be planar to each other, however the polygon-polygon
		// intersection algorithm is 2D only, so we just need to create a transform for
		// each cluster which rotates the plane in common with all faces into the XY plane.
		const targetVector = [0, 0, 1];
		const transforms = coplanarFaces
			.map(cluster => cluster.plane.normal)
			.map(normal => {
				// if dot is -1, the points are already in XY plane and the normal is inverted.
				// the quaternion will be undefined, so we need a special case because
				// we still need the points to undergo a 180 degree flip over
				const d = dot(normal, targetVector);
				return (Math.abs(d + 1) < 1e-2)
					? makeMatrix4Rotate(Math.PI, [1, 0, 0])
					: matrix4FromQuaternion(quaternionFromTwoVectors(normal, targetVector));
			});
		const faces_polygon = makeFacesPolygon2D(
			{ vertices_coords, faces_vertices },
			coplanarFaces,
			transforms,
			epsilon,
		);
		// for each group, create a faces_faces which only includes
		// those faces inside each group producing an array with holes
		const planarSets_faces_faces = coplanarFaces
			.map(el => el.faces)
			.map(faces => selfRelationalArraySubset(faces_faces, faces));
		// for each planar group, make another group subset and
		const planarSets_faces_set = planarSets_faces_faces
			.map(f_f => connectedComponents(f_f));
		// merge groups (within a common plane) if an overlap exists
		// between any two faces in either group.
		const planarSets_sets_faces = planarSets_faces_set
			.map(faces => invertMap(faces)
				.map(res => (res.constructor === Array ? res : [res])));
		// merge groups if they are overlapping
		const planarSets_disjointSetsOtherFaces = planarSets_faces_set
			.map(faces_group => {
				const faces = faces_group.map((_, i) => i);
				return faces_group.map(groupIndex => faces
					.filter(face => faces_group[face] !== groupIndex));
			});
		//
		const faces_facesOverlap = faces_vertices.map(() => []);
		planarSets_disjointSetsOtherFaces
			.forEach(planarSet => planarSet.forEach((otherFaces, face) => {
				for (let f = 0; f < otherFaces.length; f += 1) {
					const otherFace = otherFaces[f];
					const polygons = [face, otherFace]
						.map(i => faces_polygon[i]);
					const overlap = overlapConvexPolygons(...polygons, epsilon);
					if (overlap) {
						faces_facesOverlap[face][otherFace] = true;
						faces_facesOverlap[otherFace][face] = true;
					}
				}
			}));
		//
		const planarSets_overlapping_faces_faces = planarSets_disjointSetsOtherFaces
			.map(group => group.map((faces, f) => faces.filter(face => faces_facesOverlap[f][face])));
		//
		const planarSets_overlapping_sets_sets = [];
		planarSets_overlapping_faces_faces
			.forEach((overlapFaces_faces, s) => {
				planarSets_overlapping_sets_sets[s] = [];
				overlapFaces_faces.forEach((values, key) => {
					const thisSet = planarSets_faces_set[s][key];
					const otherSets = values.map(f => planarSets_faces_set[s][f]);
					if (!planarSets_overlapping_sets_sets[s][thisSet]) {
						planarSets_overlapping_sets_sets[s][thisSet] = new Set();
					}
					otherSets.forEach(v => {
						if (!planarSets_overlapping_sets_sets[s][v]) {
							planarSets_overlapping_sets_sets[s][v] = new Set();
						}
					});
					otherSets.forEach(v => {
						planarSets_overlapping_sets_sets[s][thisSet].add(v);
						planarSets_overlapping_sets_sets[s][v].add(thisSet);
					});
				});
			});
		//
		planarSets_overlapping_sets_sets
			.forEach((sets, i) => sets
				.forEach((set, j) => {
					planarSets_overlapping_sets_sets[i][j] = [...set];
				}));
		//
		const planarSets_disjointSetsSets = planarSets_overlapping_sets_sets
			.map(set_set => invertMap(connectedComponents(set_set))
				.map(sets => (sets.constructor === Array ? sets : [sets])));
		// originalSet refers to "coplanarFaces", the result from
		// coplanarFacesGroups(). this relates a new set (index) to the
		// coplanarFaces set that it came from (value).
		const newSets_originalSet = planarSets_disjointSetsSets
			.flatMap((arrays, i) => arrays.map(() => i));
		//
		const planarSets_faces = coplanarFaces
			.map((el, i) => planarSets_disjointSetsSets[i]
				.map(set => set.flatMap(s => planarSets_sets_faces[i][s])));
		//
		const coplanarOverlappingFaces = planarSets_faces
			.flatMap((set, s) => set
				.map(faces => ({
					faces,
					facesAligned: faces.map(f => faces_winding[f]),
					plane: coplanarFaces[s].plane,
				})));
		// return values
		const sets_plane = newSets_originalSet.map(i => coplanarFaces[i].plane);
		const sets_transformXY = newSets_originalSet.map(i => transforms[i]);
		const sets_faces = coplanarOverlappingFaces.map(sets => sets.faces);
		const faces_set = invertMap(sets_faces);
		// console.log("planarSets_polygons3D", planarSets_polygons3D);
		// console.log("planarSets_polygons2D", planarSets_polygons2D);
		// console.log("faces_polygon", faces_polygon);
		// console.log("coplanarFaces", coplanarFaces);
		// console.log("sets_faces", sets_faces);
		// console.log("faces_set", faces_set);
		// console.log("planarSets_faces_faces", planarSets_faces_faces);
		// console.log("planarSets_faces_set", planarSets_faces_set);
		// console.log("planarSets_sets_faces", planarSets_sets_faces);
		// console.log("planarSets_disjointSetsOtherFaces", planarSets_disjointSetsOtherFaces);
		// console.log("faces_facesOverlap", faces_facesOverlap);
		// console.log("planarSets_overlapping_faces_faces", planarSets_overlapping_faces_faces);
		// console.log("planarSets_overlapping_sets_sets", planarSets_overlapping_sets_sets);
		// console.log("planarSets_disjointSetsSets", planarSets_disjointSetsSets);
		// console.log("planarSets_faces", planarSets_faces);
		// console.log("coplanarOverlappingFaces", coplanarOverlappingFaces);
		// console.log("newSets_originalSet", newSets_originalSet);
		return {
			sets_faces,
			sets_plane,
			sets_transformXY,
			faces_set,
			faces_winding,
			// faces_facesOverlap: faces_facesOverlapAll
			// // faces_facesOverlap: faces_facesOverlap
			// 	.map(overlap => overlap
			// 		.map((_, i) => i)
			// 		.filter(a => a !== undefined)),
		};
	};

	var facesCoplanar = /*#__PURE__*/Object.freeze({
		__proto__: null,
		coplanarFacesGroups: coplanarFacesGroups,
		coplanarOverlappingFacesGroups: coplanarOverlappingFacesGroups
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Return an ExF matrix (number of: E=edges, F=faces), relating every edge
	 * to every face. Value will contain true if the edge and face overlap each other, excluding
	 * the space around the edge's endpoints, and the edges of the face.
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean[][]} matrix relating edges to faces, answering, do they overlap?
	 * @linkcode Origami ./src/graph/overlap.js 32
	 */
	const getEdgesFacesOverlap = ({
		vertices_coords, edges_vertices, edges_vector, edges_faces, faces_vertices,
	}, epsilon) => {
		if (!edges_vector) {
			edges_vector = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		const faces_winding = makeFacesWinding({ vertices_coords, faces_vertices });
		// use graph vertices_coords for edges vertices
		const edges_origin = edges_vertices.map(verts => vertices_coords[verts[0]]);
		// const edges_similar = makeEdgesEdgesSimilar({ vertices_coords, edges_vertices });
		const edges_coords = edges_vertices
			.map(verts => verts.map(v => vertices_coords[v]));
		const faces_coords = faces_vertices
			.map(verts => verts.map(v => vertices_coords[v]));
		faces_winding.forEach((winding, i) => {
			if (!winding) {
				faces_coords[i].reverse();
			}
		});

		// the result object
		const matrix = edges_vertices
			.map(() => faces_vertices
				.map(() => undefined));
		// edges which define a face are already known to not-overlap
		edges_faces.forEach((faces, e) => faces
			.forEach(f => { matrix[e][f] = false; }));

		// quick bounding box test to eliminate non-overlapping axis-aligned areas
		// todo improve n^2
		const edges_bounds = makeEdgesBoundingBox({ edges_coords });
		const faces_bounds = faces_coords
			.map(coords => boundingBox$1(coords));
		edges_bounds.forEach((edge_bounds, e) => faces_bounds.forEach((face_bounds, f) => {
			if (matrix[e][f] === false) { return; }
			if (!overlapBoundingBoxes(face_bounds, edge_bounds)) {
				matrix[e][f] = false;
			}
		}));

		edges_coords.forEach((edge_coords, e) => faces_coords.forEach((face_coords, f) => {
			if (matrix[e][f] !== undefined) { return; }
			const point_in_poly = edges_coords[e]
				.map(point => overlapConvexPolygonPoint(
					faces_coords[f],
					point,
					exclude,
					epsilon,
				)).reduce((a, b) => a || b, false);
			if (point_in_poly) { matrix[e][f] = true; return; }
			const edge_intersect = intersectConvexPolygonLine(
				faces_coords[f],
				{ vector: edges_vector[e], origin: edges_origin[e] },
				excludeS,
				excludeS,
				epsilon,
			);
			if (edge_intersect) { matrix[e][f] = true; return; }
			matrix[e][f] = false;
		}));

		// faster code. todo: switch this out for the block just above here
		// but refactor so that we use forEach instead of for()
		// const finished_edges = {};
		// for (let e = 0; e < matrix.length; e += 1) {
		// 	if (finished_edges[e]) { continue; }
		// 	for (let f = 0; f < matrix[e].length; f += 1) {
		// 		if (matrix[e][f] !== undefined) { continue; }
		// 		const point_in_poly = edges_coords[e]
		// 			.map(point => overlapConvexPolygonPoint(
		// 				faces_coords[f],
		// 				point,
		// 				exclude,
		// 				epsilon,
		// 			)).reduce((a, b) => a || b, false);
		// 		if (point_in_poly) { matrix[e][f] = true; continue; }
		// 		const edge_intersect = intersectConvexPolygonLine(
		// 			faces_coords[f],
		// 			{ vector: edges_vector[e], origin: edges_origin[e] },
		// 			excludeS,
		// 			excludeS,
		// 			epsilon,
		// 		);
		// 		if (edge_intersect) { matrix[e][f] = true; continue; }
		// 		matrix[e][f] = false;
		// 	}
		// 	edges_similar[e].forEach(adjacent_edge => {
		// 		matrix[adjacent_edge] = matrix[e].slice();
		// 		finished_edges[adjacent_edge] = true;
		// 	});
		// }

		// old code
		// matrix.forEach((row, e) => row.forEach((val, f) => {
		// 	if (val === false) { return; }
		// 	// both segment endpoints, true if either one of them is inside the face.
		// 	const point_in_poly = edges_coords[e]
		// 		.map(point => overlapConvexPolygonPoint(
		// 			faces_coords[f],
		// 			point,
		// 			exclude,
		// 			epsilon,
		// 		)).reduce((a, b) => a || b, false);
		// 	if (point_in_poly) { matrix[e][f] = true; return; }
		// 	const edge_intersect = intersectConvexPolygonLine(
		// 		faces_coords[f],
		// 		{ vector: edges_vector[e], origin: edges_origin[e] },
		// 		excludeS,
		// 		excludeS,
		// 		epsilon,
		// 	);
		// 	if (edge_intersect) { matrix[e][f] = true; return; }
		// 	matrix[e][f] = false;
		// }));
		return matrix;
	};

	var intersectEdgesFaces = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getEdgesFacesOverlap: getEdgesFacesOverlap
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Compare every face to every face to answer: do the two faces overlap?
	 * Return the result in the form of a matrix, an array of arrays of booleans,
	 * where both halves of the matrix are filled, matrix[i][j] === matrix[j][i].
	 * @param {FOLD} graph a FOLD object
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {boolean[][]} face-face matrix answering: do they overlap?
	 * @linkcode Origami ./src/graph/overlap.js 177
	 */
	const getFacesFacesOverlap = ({
		vertices_coords, faces_vertices,
	}, epsilon = EPSILON) => {
		// faces have no collinear vertices
		const facesPolygon = makeFacesPolygon({ vertices_coords, faces_vertices });
		const facesBounds = facesPolygon.map(polygon => boundingBox$1(polygon));
		const intersections = [];
		// as we progress through the line sweep, maintain a list (hash table)
		// of the set of faces which are currently overlapping this sweep line.
		const setOfFaces = [];
		sweepFaces({ vertices_coords, faces_vertices }, 0, epsilon)
			.forEach(event => {
				event.start.forEach(e => { setOfFaces[e] = true; });
				setOfFaces
					.forEach((_, f1) => event.start
						.forEach(f2 => {
							if (f1 === f2) { return; }
							// first, faster bounding box overlap. then actual overlap function
							if (!overlapBoundingBoxes(facesBounds[f1], facesBounds[f2])
								|| !overlapConvexPolygons(facesPolygon[f1], facesPolygon[f2], epsilon)) {
								return;
							}
							if (!intersections[f1]) { intersections[f1] = []; }
							if (!intersections[f2]) { intersections[f2] = []; }
							intersections[f1][f2] = true;
							intersections[f2][f1] = true;
						}));
				event.end.forEach(e => delete setOfFaces[e]);
			});
		return intersections.map(faces => Object.keys(faces).map(n => parseInt(n, 10)));
	};

	var intersectFacesFaces = /*#__PURE__*/Object.freeze({
		__proto__: null,
		getFacesFacesOverlap: getFacesFacesOverlap
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// notes: i really can't make this function excellent if we have to
	// deal with non-convex faces. there is no line-polygon intersection
	// which handles all the edge cases of a non-convex polygon, the more
	// i think about it i think of a new edge case, like a single edge
	// that sticks inwards (which happens a lot).
	//
	// no, I think that if i'm going to re-write this method and it's going
	// to be better than the previous, i need to impose the limiation that
	// an interior segment should be extended on both ends until it
	// intersects with the next nearest edge in the graph, ensuring that
	// all resulting faces are closed off and convex.
	//
	// oh wait. in fact, this is a great use of a "J" join edge.
	// the segment can be extended, but the line can be separated by a vertex,
	// on one side is the user's assignment, and on the other is a "J" edge.

	/**
	 * @description the segment has already been clipped, it lies entirely inside
	 * this face's boundary (todo: so long as it's convex), this method will
	 * clean everything up, rebuild the data.
	 */
	const addSegmentInsideFace = (graph, face, segment, epsilon = EPSILON) => {
		graph.faces_vertices[face]
			.map(v => graph.vertices_coords[v])
			.map(point => segment.map(p => epsilonEqualVectors(point, p, epsilon)));
		graph.faces_vertices[face]
			.map(v => graph.vertices_coords[v])
			.map((v, i, arr) => [v, arr[(i + 1) % arr.length]])
			.map(seg => pointsToLine(...seg))
			.map(line => segment
				.map(point => overlapLinePoint(line, point, excludeS, epsilon)));
	};
	/**
	 *
	 */
	const makeFacesSegment = (graph, segment, epsilon = EPSILON) => {
		const vector = subtract2(segment[1], segment[0]);
		const origin = segment[0];
		// const line = { vector, origin };
		const faces = getFacesSegmentOverlap(graph, segment, epsilon);
		const clippings = faces
			.map(f => graph.faces_vertices[f].map(v => graph.vertices_coords[v]))
			.map(poly => clipLineConvexPolygon(poly, { vector, origin }, include, includeS, epsilon));
		// solutions as an array with faces_ as the indices
		const facesSegment = [];
		faces.forEach((f, i) => {
			if (clippings[i]) {
				facesSegment[f] = clippings[i];
			}
		});
		return facesSegment;
	};
	/**
	 * @description Add a segment into a planar graph and maintain planarity.
	 * @param {FOLD} graph a FOLD graph, modified in place
	 * @param {number[][]} segment an array of 2D points, where each point
	 * is an array of two numbers.
	 * @returns {object} summary of changes to the graph
	 */
	const addPlanarSegmentNew = (graph, segment, epsilon = EPSILON) => {
		// split the segment against every edge
		const facesSegment = makeFacesSegment(graph, segment, epsilon);
		console.log("facesSegment", facesSegment);
		const result = facesSegment
			.map((seg, face) => addSegmentInsideFace(graph, face, seg, epsilon));
		return result;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// import addVertices_splitEdges from "./add/addVertices_splitEdges.js";
	// not included because the Graph object places them in the same location
	// import * as foldBases from "../fold/bases.js";

	var graphMethods = {
		count,
		countImplied,
		validate,
		clean,
		populate,
		remove: removeGeometryIndices,
		replace: replaceGeometryIndices,
		removePlanarVertex,
		removePlanarEdge,
		// addVertices,
		// addEdges,
		splitEdge,
		splitFace,
		flatFold,
		addPlanarSegment,
		addPlanarSegmentNew,
		planarize,
		connectedComponents,
		clone,
		...foldColors,
		...foldFileFrames,
		...foldKeyMethods,
		...foldSpecMethods,
		...boundary$1,
		...clip$1,
		...explodeMethods,
		...join,
		...make,
		...maps,
		...nearestMethods,
		...normals,
		...span,
		...subgraphMethods,
		...sweep$1,
		...symmetry,
		...transform$1,
		...triangulateMethods,
		...walk,
		...arrays,
		...verticesClusters,
		...verticesCollinear,
		...verticesDuplicate,
		...verticesFolded,
		...verticesIsolated,
		...verticesSort,
		...edgesCircular,
		...edgesDuplicate,
		...edgesGeneral,
		...edgesLines,
		...facesCoplanar,
		...facesMatrix,
		...facesSpanningTree,
		...facesWinding,
		...intersectEdges,
		...intersectEdgesEdges,
		...intersectEdgesFaces,
		...intersectFaces,
		...intersectFacesFaces,
		...intersectVerticesEdges,
	};

	/* Math (c) Kraft, MIT License */
	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Infer the type of an object.
	 * @param {any} any object
	 * @returns {string} the type name
	 * @linkcode Math ./src/general/typeOf.js 8
	 */
	const typeOf = (obj) => {
		if (typeof obj !== "object") { return typeof obj; }
		if (obj.radius !== undefined) { return "circle"; }
		if (obj.min && obj.max && obj.span) { return "box"; }
		// if (obj.width !== undefined) { return "rect"; }
		if (typeof obj[0] === "number") { return "vector"; }
		if (obj.vector !== undefined && obj.origin !== undefined) { return "line"; }
		if (obj[0] !== undefined && obj[0].length && typeof obj[0][0] === "number") {
			return obj.length === 2 ? "segment" : "polygon";
		}
		return "object";
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */

	const general$1 = {
		...constant,
		..._function,
		...get,
		...convert$2,
		...array,
		...number,
		...search,
		...sort,
		typeof: typeOf,
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */

	const algebra = {
		...vector,
		...matrix2,
		...matrix3,
		...matrix4,
		...quaternion,
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description mirror an array and join it at the end, except
	 * do not duplicate the final element, it should only appear once.
	 */
	const mirrorArray = (arr) => arr.concat(arr.slice(0, -1).reverse());
	/**
	 * @description Convex hull from a set of 2D points, choose whether
	 * to include or exclude points which lie collinear inside one of
	 * the boundary lines. modified Graham scan algorithm.
	 * @param {number[][]} points array of points, each point an array of numbers
	 * @param {boolean} [includeCollinear=false] true will include
	 * points collinear along the boundary
	 * @param {number} [epsilon=1e-6] undefined behavior when larger than 0.01
	 * @returns {number[]} not the points, but the indices
	 * of points in your "points" array
	 * @linkcode Math ./src/geometry/convexHull.js 22
	 */
	const convexHull = (points = [], includeCollinear = false, epsilon = EPSILON) => {
		if (points.length < 2) { return []; }
		// if includeCollinear is true, we need to walk collinear points,
		// problem is we don't know if we should be going towards or away from
		// the origin point, so to work around that, make a mirror of all collinear
		// vertices so that it walks both directions, ie: 1,6,5,13,5,6,1.
		// half of them will be ignored due to being rejected from the
		// threePointTurnDirection call, and the correct half will be saved.
		const order = radialSortPointIndices2(points, epsilon)
			.map(arr => (arr.length === 1 ? arr : mirrorArray(arr)))
			.flat();
		order.push(order[0]);
		const stack = [order[0]];
		let i = 1;
		// threePointTurnDirection returns -1,0,1, with 0 as the collinear case.
		// setup our operation for each case, depending on includeCollinear
		const funcs = {
			"-1": () => stack.pop(),
			1: (next) => { stack.push(next); i += 1; },
			undefined: () => { i += 1; },
		};
		funcs[0] = includeCollinear ? funcs["1"] : funcs["-1"];
		while (i < order.length) {
			if (stack.length < 2) {
				stack.push(order[i]);
				i += 1;
				continue;
			}
			const prev = stack[stack.length - 2];
			const curr = stack[stack.length - 1];
			const next = order[i];
			const turn = threePointTurnDirection(...[prev, curr, next].map(j => points[j]), epsilon);
			funcs[turn](next);
		}
		stack.pop();
		return stack;
	};

	var convexHull$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		convexHull: convexHull
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description this recursive algorithm works outwards-to-inwards, each repeat
	 * decreases the size of the polygon by one point/side. (removes 2, adds 1)
	 * and repeating the algorithm on the smaller polygon.
	 *
	 * @param {number[][]} array of point objects (arrays of numbers, [x, y]). the
	 *   counter-clockwise sorted points of the polygon. as we recurse this list shrinks
	 *   by removing the points that are "finished".
	 *
	 * @returns {object[]} array of line segments as objects with keys:
	 *   "points": array of 2 points in array form [ [x, y], [x, y] ]
	 *   "type": "skeleton" or "kawasaki", the latter being the projected perpendicular
	 *   dropped edges down to the sides of the polygon.
	 */
	const recurseSkeleton = (points, lines, bisectors) => {
		// every point has an interior angle bisector vector, this ray is
		// tested for intersections with its neighbors on both sides.
		// "intersects" is fencepost mapped (i) to "points" (i, i+1)
		// because one point/ray intersects with both points on either side,
		// so in reverse, every point (i) relates to intersection (i-1, i)
		const intersects = points
			// .map((p, i) => math.ray(bisectors[i], p))
			// .map((ray, i, arr) => ray.intersect(arr[(i + 1) % arr.length]));
			.map((origin, i) => ({ vector: bisectors[i], origin }))
			.map((ray, i, arr) => intersectLineLine(
				ray,
				arr[(i + 1) % arr.length],
				excludeR,
				excludeR,
			));
		// project each intersection point down perpendicular to the edge of the polygon
		// const projections = lines.map((line, i) => line.nearestPoint(intersects[i]));
		const projections = lines.map((line, i) => (
			nearestPointOnLine(line, intersects[i], a => a)
		));
		// when we reach only 3 points remaining, we are at the end. we can return early
		// and skip unnecessary calculations, all 3 projection lengths will be the same.
		if (points.length === 3) {
			return points.map(p => ({ type: "skeleton", points: [p, intersects[0]] }))
				.concat([{ type: "perpendicular", points: [projections[0], intersects[0]] }]);
		}
		// measure the lengths of the projected lines, these will be used to identify
		// the smallest length, or the point we want to operate on this round.
		const projectionLengths = intersects
			.map((intersect, i) => distance(intersect, projections[i]));
		let shortest = 0;
		projectionLengths.forEach((len, i) => {
			if (len < projectionLengths[shortest]) { shortest = i; }
		});
		// we have the shortest length, we now have the solution for this round
		// (all that remains is to prepare the arguments for the next recursive call)
		const solutions = [
			{
				type: "skeleton",
				points: [points[shortest], intersects[shortest]],
			},
			{
				type: "skeleton",
				points: [points[(shortest + 1) % points.length], intersects[shortest]],
			},
			// perpendicular projection
			// we could expand this algorithm here to include all three instead of just one.
			// two more of the entries in "intersects" will have the same length as shortest
			{ type: "perpendicular", points: [projections[shortest], intersects[shortest]] },
			// ...projections.map(p => ({ type: "perpendicular", points: [p, intersects[shortest]] }))
		];
		// our new smaller polygon, missing two points now, but gaining one more (the intersection)
		// this is to calculate the new angle bisector at this new point.
		// we are now operating on the inside of the polygon, the lines that will be built from
		// this bisection will become interior skeleton lines.
		// first, flip the first vector so that both of the vectors originate at the
		// center point, and extend towards the neighbors.
		const newVector = clockwiseBisect2(
			flip(lines[(shortest + lines.length - 1) % lines.length].vector),
			lines[(shortest + 1) % lines.length].vector,
		);
		// delete 2 entries from "points" and "bisectors" and add each array's new element.
		// delete 1 entry from lines.
		const shortest_is_last_index = shortest === points.length - 1;
		points.splice(shortest, 2, intersects[shortest]);
		lines.splice(shortest, 1);
		bisectors.splice(shortest, 2, newVector);
		if (shortest_is_last_index) {
			// in the case the index was at the end of the array,
			// we tried to remove two elements but only removed one because
			// it was the last element. remove the first element too.
			points.splice(0, 1);
			bisectors.splice(0, 1);
			// also, the fencepost mapping of the lines array is off by one,
			// move the first element to the end of the array.
			lines.push(lines.shift());
		}
		return solutions.concat(recurseSkeleton(points, lines, bisectors));
	};
	/**
	 * @description create a straight skeleton inside of a convex polygon
	 * @param {number[][]} points counter-clockwise polygon as an array of points
	 * (which are arrays of numbers)
	 * @returns {object[]} list of objects containing "points" {number[][]}: two points
	 * defining a line segment, and "type" {string}: either "skeleton" or "perpendicular"
	 *
	 * make sure:
	 *  - your polygon is convex (todo: make this algorithm work with non-convex)
	 *  - your polygon points are sorted counter-clockwise
	 * @linkcode Math ./src/geometry/straightSkeleton.js 119
	 */
	const straightSkeleton = (points) => {
		// first time running this function, create the 2nd and 3rd parameters
		// convert the edges of the polygons into lines
		const lines = points
			.map((p, i, arr) => [p, arr[(i + 1) % arr.length]])
			// .map(side => math.line.fromPoints(...side));
			.map(side => ({ vector: subtract(side[1], side[0]), origin: side[0] }));
		// get the interior angle bisectors for every corner of the polygon
		// index map match to "points"
		const bisectors = points
			// each element into 3 (previous, current, next)
			.map((_, i, ar) => [(i - 1 + ar.length) % ar.length, i, (i + 1) % ar.length]
				.map(j => ar[j]))
			// make 2 vectors, from current point to previous/next neighbors
			.map(p => [subtract(p[0], p[1]), subtract(p[2], p[1])])
			// it is a little counter-intuitive but the interior angle between three
			// consecutive points in a counter-clockwise wound polygon is measured
			// in the clockwise direction
			.map(v => clockwiseBisect2(...v));
		// points is modified in place. create a copy
		// const points_clone = JSON.parse(JSON.stringify(points));
		// console.log("ss points", points_clone, points);
		return recurseSkeleton([...points], lines, bisectors);
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */

	const geometry = {
		...convexHull$1,
		...line,
		...nearest$1,
		...polygon$1,
		...radial,
		straightSkeleton,
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description does one bounding box (outer) completely enclose
	 * another bounding box (inner)?
	 * @param {Box} outer an n-dimensional bounding box
	 * @param {Box} inner an n-dimensional bounding box
	 * @param {number} [epsilon=1e-6] an optional epsilon to pad the area
	 * around the outer bounding box; a negative number will make
	 * the boundary exclusive.
	 * @returns {boolean} is the "inner" polygon completely inside the "outer"
	 * @linkcode Math ./src/intersect/encloses.js 16
	 */
	const enclosingBoundingBoxes = (outer, inner, epsilon = EPSILON) => {
		const dimensions = Math.min(outer.min.length, inner.min.length);
		for (let d = 0; d < dimensions; d += 1) {
			// if one minimum is above the other's maximum, or visa versa
			if (inner.min[d] < outer.min[d] - epsilon
				|| inner.max[d] > outer.max[d] + epsilon) {
				return false;
			}
		}
		return true;
	};
	/**
	 * @description does one polygon (outer) completely enclose another polygon (inner),
	 * currently, this only works for convex polygons.
	 * @param {number[][]} outer a 2D convex polygon
	 * @param {number[][]} inner a 2D convex polygon
	 * @param {function} [fnInclusive] by default, the boundary is considered inclusive
	 * @returns {boolean} is the "inner" polygon completely inside the "outer"
	 *
	 * @todo: should one function be include and the other exclude?
	 * @linkcode Math ./src/intersect/encloses.js 38
	 */
	const enclosingPolygonPolygon = (outer, inner, fnInclusive = include) => {
		// these points should be *not inside* (false)
		const outerGoesInside = outer
			.map(p => overlapConvexPolygonPoint(inner, p, fnInclusive))
			.reduce((a, b) => a || b, false);
		// these points should be *inside* (true)
		const innerGoesOutside = inner
			.map(p => overlapConvexPolygonPoint(inner, p, fnInclusive))
			.reduce((a, b) => a && b, true);
		return (!outerGoesInside && innerGoesOutside);
	};

	var encloses = /*#__PURE__*/Object.freeze({
		__proto__: null,
		enclosingBoundingBoxes: enclosingBoundingBoxes,
		enclosingPolygonPolygon: enclosingPolygonPolygon
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	/**
	 * @description Split a convex polygon by a line and rebuild each
	 * half into two convex polygons.
	 * @param {number[][]} poly an array of points
	 * @param {VecLine} line a line in "vector" "origin" form.
	 * @returns {number[][][]} an array of one or two polygons,
	 * each polygon is an array of points,
	 * each point is an array of numbers.
	 * @linkcode Math ./src/intersect/split.js 20
	 */
	const splitConvexPolygon = (poly, line) => {
		// todo: should this return undefined if no intersection?
		//       or the original poly?

		//    point: intersection [x,y] point or null if no intersection
		// at_index: where in the polygon this occurs
		const vertices_intersections = poly.map((v, i) => {
			const intersection = overlapLinePoint(line, v, includeL);
			return { point: intersection ? v : null, at_index: i };
		}).filter(el => el.point != null);
		const edges_intersections = poly
			.map((v, i, arr) => ({
				vector: subtract(v, arr[(i + 1) % arr.length]),
				origin: arr[(i + 1) % arr.length],
			}))
			.map((polyLine, i) => ({
				point: intersectLineLine(line, polyLine, excludeL, excludeS),
				at_index: i,
			}))
			.filter(el => el.point != null);
		// three cases: intersection at 2 edges, 2 points, 1 edge and 1 point
		if (edges_intersections.length === 2) {
			const sorted_edges = edges_intersections.slice()
				.sort((a, b) => a.at_index - b.at_index);

			const face_a = poly
				.slice(sorted_edges[1].at_index + 1)
				.concat(poly.slice(0, sorted_edges[0].at_index + 1));
			face_a.push(sorted_edges[0].point);
			face_a.push(sorted_edges[1].point);

			const face_b = poly
				.slice(sorted_edges[0].at_index + 1, sorted_edges[1].at_index + 1);
			face_b.push(sorted_edges[1].point);
			face_b.push(sorted_edges[0].point);
			return [face_a, face_b];
		}
		if (edges_intersections.length === 1 && vertices_intersections.length === 1) {
			vertices_intersections[0].type = "v";
			edges_intersections[0].type = "e";
			const sorted_geom = vertices_intersections.concat(edges_intersections)
				.sort((a, b) => a.at_index - b.at_index);

			const face_a = poly.slice(sorted_geom[1].at_index + 1)
				.concat(poly.slice(0, sorted_geom[0].at_index + 1));
			if (sorted_geom[0].type === "e") { face_a.push(sorted_geom[0].point); }
			face_a.push(sorted_geom[1].point); // todo: if there's a bug, it's here. switch this

			const face_b = poly
				.slice(sorted_geom[0].at_index + 1, sorted_geom[1].at_index + 1);
			if (sorted_geom[1].type === "e") { face_b.push(sorted_geom[1].point); }
			face_b.push(sorted_geom[0].point); // todo: if there's a bug, it's here. switch this
			return [face_a, face_b];
		}
		if (vertices_intersections.length === 2) {
			const sorted_vertices = vertices_intersections.slice()
				.sort((a, b) => a.at_index - b.at_index);
			const face_a = poly
				.slice(sorted_vertices[1].at_index)
				.concat(poly.slice(0, sorted_vertices[0].at_index + 1));
			const face_b = poly
				.slice(sorted_vertices[0].at_index, sorted_vertices[1].at_index + 1);
			return [face_a, face_b];
		}
		return [poly.slice()];
	};

	var split = /*#__PURE__*/Object.freeze({
		__proto__: null,
		splitConvexPolygon: splitConvexPolygon
	});

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */

	const capitalize = s => s.charAt(0).toUpperCase() + s.slice(1);

	const defaultDomain = {
		polygon: includeS,
		circle: include,
		line: includeL,
		ray: includeR,
		segment: includeS,
	};

	const intersect = (a, b, epsilon = EPSILON) => {
		// method names are: (a) capitalized, and
		// (b) "Polygon" appears as "ConvexPolygon"
		const nameType = s => (s === "polygon" ? "ConvexPolygon" : capitalize(s));
		// get the type of each parameter
		const types = [a, b].map(typeOf);
		// all methods names follow the format "intersect" + type1 + type2.
		// try both iterations because things like intersectCircleLine is a
		// valid method, but intersectLineCircle does not exist.
		const methods = [types, types.slice().reverse()]
			.map(pair => pair.map(nameType).join(""))
			.map(str => intersect$1[`intersect${str}`]);
		// build the corresponding list of parameters
		const doms = [a.domain, b.domain]
			.map((d, i) => d || defaultDomain[types[i]]);
		const parameters = [[a, b, ...doms], [b, a, ...doms.slice().reverse()]];
		// run one of these two methods, if one exists.
		const match = methods
			.map((fn, i) => ({ fn, params: parameters[i] }))
			.filter(el => el.fn)
			.shift();
		return match ? match.fn(...match.params, epsilon) : undefined;
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */

	const intersectMethods = {
		...encloses,
		...overlap,
		...intersect$1,
		...clip$2,
		...split,
		intersect: intersect,
	};

	/* Math (c) Kraft, MIT License */

	/**
	 * Math (c) Kraft
	 */
	// import primitives from "./primitives/index.js";

	/**
	 * @typedef VecLine
	 * @type {{ vector: number[], origin: number[] }}
	 * @description a line defined by a vector and a point along the line,
	 * capable of representing a line in any dimension.
	 * @property {number[]} vector - a vector describing the direction of the line
	 * @property {number[]} origin - a point which the line passes through
	 */
	/**
	 * @typedef UniqueLine
	 * @type {{ normal: number[], distance: number }}
	 * @description a 2D line defined by a unit normal vector and a value that
	 * describes the shortest distance from the origin to a point on the line.
	 * @property {number[]} normal - a unit vector that is normal to the line
	 * @property {number} distance - the shortest distance
	 * from the line to the origin
	 */

	/**
	 * @typedef Box
	 * @type {{ min: number[], max: number[], span?: number[] }}
	 * @description an axis-aligned bounding box, capable of representing
	 * a bounding box with any number of dimensions.
	 * @property {number[]} min - the point representing the absolute minimum
	 * for all axes.
	 * @property {number[]} max - the point representing the absolute maximum
	 * for all axes.
	 */

	/**
	 * @typedef Circle
	 * @type {{ radius: number, origin: number[] }}
	 * @description a circle primitive in 2D
	 * @property {number} radius - the radius of the circle
	 * @property {number[]} origin - the center of the circle as an array of numbers
	 */

	/**
	 * @description A small math library with a focus on linear algebra,
	 * computational geometry, and computing the intersection of shapes.
	 */
	const math = {
		...general$1,
		...algebra,
		...geometry,
		...intersectMethods,
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	const get_unassigned_indices = (edges_assignment) => edges_assignment
		.map((_, i) => i)
		.filter(i => edges_assignment[i] === "U" || edges_assignment[i] === "u");

	// sectors and assignments are fenceposted.
	// sectors[i] is bounded by assignment[i] assignment[i + 1]
	/**
	 * @description given a set of assignments (M/V/F/B/U characters), which contains
	 * some U (unassigned), find all permutations of mountain valley to replace all U.
	 * This function solves only one single vertex, the assignments are sorted radially
	 * around the vertex. This validates according to Maekawa's theorem only.
	 * @param {string[]} vertices_edges_assignments array of single character
	 * FOLD spec edges assignments.
	 * @returns {string[][]} array of arrays of strings, all permutations where "U"
	 * assignments have been replaced with "V" or "M".
	 * @linkcode Origami ./src/singleVertex/maekawaAssignments.js 19
	 */
	const maekawaAssignments = (vertices_edges_assignments) => {
		const unassigneds = get_unassigned_indices(vertices_edges_assignments);
		const permuts = Array.from(Array(2 ** unassigneds.length))
			.map((_, i) => i.toString(2))
			.map(l => Array(unassigneds.length - l.length + 1).join("0") + l)
			.map(str => Array.from(str).map(l => (l === "0" ? "V" : "M")));
		const all = permuts.map(perm => {
			const array = vertices_edges_assignments.slice();
			unassigneds.forEach((index, i) => { array[index] = perm[i]; });
			return array;
		});
		if (vertices_edges_assignments.includes("B")
			|| vertices_edges_assignments.includes("b")) {
			return all;
		}
		const count_m = all.map(a => a.filter(l => l === "M" || l === "m").length);
		const count_v = all.map(a => a.filter(l => l === "V" || l === "v").length);
		return all.filter((_, i) => Math.abs(count_m[i] - count_v[i]) === 2);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	const odd_assignment = (assignments) => {
		let ms = 0;
		let vs = 0;
		for (let i = 0; i < assignments.length; i += 1) {
			if (assignments[i] === "M" || assignments[i] === "m") { ms += 1; }
			if (assignments[i] === "V" || assignments[i] === "v") { vs += 1; }
		}
		for (let i = 0; i < assignments.length; i += 1) {
			if (ms > vs && (assignments[i] === "V" || assignments[i] === "v")) { return i; }
			if (vs > ms && (assignments[i] === "M" || assignments[i] === "m")) { return i; }
		}
		return undefined;
	};
	/**
	 * @description fold a degree-4 single vertex in 3D.
	 * @usage this only works for degree-4 vertices
	 * @param {number[]} sectors an array of sector angles, sorted, around the single vertex.
	 * @param {string[]} assignments an array of FOLD spec characters, "M" or "V".
	 * @param {number} t the fold amount between 0 and 1.
	 * @returns {number[]} four fold angles as numbers in an array.
	 * @linkcode Origami ./src/singleVertex/foldAngles4.js 24
	 */
	const foldAngles4 = (sectors, assignments, t = 0) => {
		const odd = odd_assignment(assignments);
		if (odd === undefined) { return; }
		const a = sectors[(odd + 1) % sectors.length];
		const b = sectors[(odd + 2) % sectors.length];

		// const pab = (odd + 2) % sectors.length;
		// const pbc = (odd + 3) % sectors.length;
		const pbc = Math.PI * t;

		const cosE = -Math.cos(a) * Math.cos(b) + Math.sin(a) * Math.sin(b) * Math.cos(Math.PI - pbc);
		const res = Math.cos(Math.PI - pbc)
			- ((Math.sin(Math.PI - pbc) ** 2) * Math.sin(a) * Math.sin(b))
			/ (1 - cosE);

		const pab = -Math.acos(res) + Math.PI;
		return (odd % 2 === 0
			? [pab, pbc, pab, pbc].map((n, i) => (odd === i ? -n : n))
			: [pbc, pab, pbc, pab].map((n, i) => (odd === i ? -n : n)));
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// todo: this is doing too much work in preparation
	/**
	 * @description given a single vertex in a graph which does not yet satisfy Kawasaki's theorem,
	 * find all possible single-ray additions which when added to the set, the set
	 * satisfies Kawasaki's theorem.
	 * @usage this is hard coded to work for flat-plane, where sectors sum to 360deg
	 * @param {object} graph a FOLD object
	 * @param {number} vertex the index of the vertex
	 * @returns {number[][]} for every sector either one vector or
	 * undefined if that sector contains no solution.
	 * @linkcode Origami ./src/singleVertex/kawasakiGraph.js 21
	 */
	const kawasakiSolutions = ({ vertices_coords, vertices_edges, edges_vertices, edges_vectors }, vertex) => {
		// to calculate Kawasaki's theorem, we need the 3 edges
		// as vectors, and we need them sorted radially.
		if (!edges_vectors) {
			edges_vectors = makeEdgesVector({ vertices_coords, edges_vertices });
		}
		if (!vertices_edges) {
			vertices_edges = makeVerticesEdgesUnsorted({ edges_vertices });
		}
		const vectors = vertices_edges[vertex].map(i => edges_vectors[i]);
		const sortedVectors = counterClockwiseOrder2(vectors)
			.map(i => vectors[i]);
		return kawasakiSolutionsVectors(sortedVectors);
	};

	var kawasakiGraph = /*#__PURE__*/Object.freeze({
		__proto__: null,
		kawasakiSolutions: kawasakiSolutions
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description A collection of operations done on single vertices
	 * (one vertex in a graph typically surrounded by edges).
	 */
	var singleVertex = Object.assign(
		Object.create(null),
		{
			maekawaAssignments,
			foldAngles4,
		},
		kawasakiMath,
		kawasakiGraph,
		validateSingleVertex,
	);

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// WebGL boilerplate from https://webglfundamentals.org
	/**
	 * @description Creates and compiles a shader.
	 * @param {!WebGLRenderingContext} gl The WebGL Context.
	 * @param {string} shaderSource The GLSL source code for the shader.
	 * @param {number} shaderType The type of shader, VERTEX_SHADER or
	 *     FRAGMENT_SHADER.
	 * @returns {!WebGLShader} The shader.
	 */
	const compileShader = (gl, shaderSource, shaderType) => {
		const shader = gl.createShader(shaderType);
		gl.shaderSource(shader, shaderSource);
		gl.compileShader(shader);
		if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
			throw new Error(gl.getShaderInfoLog(shader));
		}
		return shader;
	};
	/**
	 * @description Creates a program from 2 shaders.
	 * @param {!WebGLRenderingContext) gl The WebGL context.
	 * @param {!WebGLShader} vertexShader A vertex shader.
	 * @param {!WebGLShader} fragmentShader A fragment shader.
	 * @returns {!WebGLProgram} A program.
	 */
	const createProgramAndAttachShaders = (gl, vertexShader, fragmentShader) => {
		const program = gl.createProgram();
		gl.attachShader(program, vertexShader);
		gl.attachShader(program, fragmentShader);
		gl.linkProgram(program);
		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			// something went wrong with the link
			throw new Error(gl.getProgramInfoLog(program));
		}
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);
		return program;
	};
	/**
	 * Creates a program from 2 script tags.
	 *
	 * @param {!WebGLRenderingContext} gl The WebGL Context.
	 * @param {string} vertexSource vertex shader as raw text
	 * @param {string} fragmentSource fragment shader as raw text
	 * @returns {!WebGLProgram} a WebGL program
	 */
	const createProgram = (gl, vertexSource, fragmentSource) => {
		const vertexShader = compileShader(gl, vertexSource, gl.VERTEX_SHADER);
		const fragmentShader = compileShader(gl, fragmentSource, gl.FRAGMENT_SHADER);
		return createProgramAndAttachShaders(gl, vertexShader, fragmentShader);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const initializeWebGL = (canvasElement, preferredVersion) => {
		const contextName = [null, "webgl", "webgl2"];
		// set the size of the drawingBuffer to include retina display level pixels (if exist),
		// the size can still change after, even with CSS, this only matters for getContext
		const devicePixelRatio = window.devicePixelRatio || 1;
		canvasElement.width = canvasElement.clientWidth * devicePixelRatio;
		canvasElement.height = canvasElement.clientHeight * devicePixelRatio;
		if (preferredVersion) {
			return ({
				gl: canvasElement.getContext(contextName[preferredVersion]),
				version: preferredVersion,
			});
		}
		// no user preference. attempt version 2, if fails, return version 1.
		const gl2 = canvasElement.getContext(contextName[2]);
		if (gl2) { return { gl: gl2, version: 2 }; }
		const gl1 = canvasElement.getContext(contextName[1]);
		if (gl1) { return { gl: gl1, version: 1 }; }
		throw new Error(Messages$1.noWebGL);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Initialize a viewport for a WebGL context
	 * based on the dimensions of the canvas.
	 * @param {object} gl a WebGL instance
	 * @param {object} canvas an HTML canvas
	 */
	const rebuildViewport = (gl, canvas) => {
		if (!gl) { return; }
		const devicePixelRatio = window.devicePixelRatio || 1;
		const size = [canvas.clientWidth, canvas.clientHeight]
			.map(n => n * devicePixelRatio);
		if (canvas.width !== size[0] || canvas.height !== size[1]) {
			canvas.width = size[0];
			canvas.height = size[1];
		}
		gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	};
	/**
	 * @description Create a 4x4 projection matrix for either a
	 * perspective or orthographic view.
	 * @param {object} canvas an HTML canvas
	 * @param {string} perspective "orthographic" or "perspective"
	 * @param {number} fov the field of view (perspective only)
	 */
	const makeProjectionMatrix = (canvas, perspective = "perspective", fov = 45) => {
		if (!canvas) { return identity4x4; }
		const Z_NEAR = 0.1;
		const Z_FAR = 20;
		const ORTHO_FAR = -100;
		const ORTHO_NEAR = 100;
		const bounds = [canvas.clientWidth, canvas.clientHeight];
		const vmin = Math.min(...bounds);
		const padding = [0, 1].map(i => ((bounds[i] - vmin) / vmin) / 2);
		const side = padding.map(p => p + 0.5);
		return perspective === "orthographic"
			? makeOrthographicMatrix4(side[1], side[0], -side[1], -side[0], ORTHO_FAR, ORTHO_NEAR)
			: makePerspectiveMatrix4(fov * (Math.PI / 180), bounds[0] / bounds[1], Z_NEAR, Z_FAR);
	};
	/**
	 * @description build an aspect-fit model matrix
	 * (possibly an inverse-model matrix)
	 * which brings the vertices inside of a 2x2x2 origin-centered bounding box.
	 * @param {FOLD} graph a FOLD graph
	 */
	const makeModelMatrix = (graph) => {
		if (!graph) { return identity4x4; }
		const bounds = boundingBox(graph);
		if (!bounds) { return identity4x4; }
		const scale = Math.max(...bounds.span); // * Math.SQRT2;
		if (scale === 0) { return identity4x4; }
		const center = resize(3, midpoint(bounds.min, bounds.max));
		const scalePositionMatrix = [scale, 0, 0, 0, 0, scale, 0, 0, 0, 0, scale, 0, ...center, 1];
		return invertMatrix4(scalePositionMatrix) || identity4x4;
	};

	var view = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeModelMatrix: makeModelMatrix,
		makeProjectionMatrix: makeProjectionMatrix,
		rebuildViewport: rebuildViewport
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// the uniform is an object and the object should be structured like this:
	// {
	// 	u_modelView: {
	// 		func: "uniformMatrix4fv",
	// 		value: [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],
	// 	},
	// 	u_opacity: {
	// 		func: "uniform1f",
	// 		value: opacity,
	// 	},
	// }
	const uniformFunc = (gl, i, func, value) => {
		switch (func) {
		case "uniformMatrix4fv": gl[func](i, false, value); break;
		// case "uniform1f":
		// case "uniform2fv":
		// case "uniform3fv":
		default: gl[func](i, value); break;
		}
	};
	/**
	 * @param {object} gl a link to the WebGL instance
	 * @param {number} version 1 or 2, which WebGL version.
	 * @param {object} bundle the result of calling CreasePattern() FoldedForm()...
	 * @param {object} uniforms the result of calling makeUniforms()
	 */
	const drawProgram = (gl, version, bundle, uniforms = {}) => {
		gl.useProgram(bundle.program);
		bundle.flags.forEach(flag => gl.enable(flag));
		// set uniforms
		const uniformCount = gl.getProgramParameter(bundle.program, gl.ACTIVE_UNIFORMS);
		for (let i = 0; i < uniformCount; i += 1) {
			const uniformName = gl.getActiveUniform(bundle.program, i).name;
			const uniform = uniforms[uniformName];
			if (uniform) {
				const index = gl.getUniformLocation(bundle.program, uniformName);
				uniformFunc(gl, index, uniform.func, uniform.value);
			}
		}
		// set vertex arrays
		bundle.vertexArrays.forEach(el => {
			gl.bindBuffer(gl.ARRAY_BUFFER, el.buffer);
			gl.bufferData(gl.ARRAY_BUFFER, el.data, gl.STATIC_DRAW);
			gl.vertexAttribPointer(el.location, el.length, el.type, false, 0, 0);
			gl.enableVertexAttribArray(el.location);
		});
		// gl.linkProgram(bundle.program);
		// draw elements
		// WebGL 2 supports UNSIGNED_INT (Uint32Array)
		// WebGL 1 cannot and must use UNSIGNED_SHORT (Uint16Array)
		bundle.elementArrays.forEach(el => {
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, el.buffer);
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, el.data, gl.STATIC_DRAW);
			gl.drawElements(
				el.mode, // GL.TRIANGLES for example
				el.data.length,
				version === 2 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT,
				el.buffer,
			);
		});
		bundle.flags.forEach(flag => gl.disable(flag));
	};
	/**
	 *
	 */
	const deallocProgram = (gl, bundle) => {
		bundle.vertexArrays.forEach(vert => gl.disableVertexAttribArray(vert.location));
		bundle.vertexArrays.forEach(vert => gl.deleteBuffer(vert.buffer));
		bundle.elementArrays.forEach(elements => gl.deleteBuffer(elements.buffer));
		gl.deleteProgram(bundle.program);
		// gl.deleteTexture(someTexture);
		// gl.deleteRenderbuffer(someRenderbuffer);
		// gl.deleteFramebuffer(someFramebuffer);
	};

	var program = /*#__PURE__*/Object.freeze({
		__proto__: null,
		deallocProgram: deallocProgram,
		drawProgram: drawProgram
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const dark = {
		B: [0.5, 0.5, 0.5],
		b: [0.5, 0.5, 0.5],
		V: [0.2, 0.4, 0.6],
		v: [0.2, 0.4, 0.6],
		M: [0.75, 0.25, 0.15],
		m: [0.75, 0.25, 0.15],
		F: [0.3, 0.3, 0.3],
		f: [0.3, 0.3, 0.3],
		J: [0.3, 0.2, 0.0],
		j: [0.3, 0.2, 0.0],
		C: [0.5, 0.8, 0.1],
		c: [0.5, 0.8, 0.1],
		U: [0.6, 0.25, 0.9],
		u: [0.6, 0.25, 0.9],
	};

	const light = {
		B: [0.0, 0.0, 0.0],
		b: [0.0, 0.0, 0.0],
		V: [0.2, 0.5, 0.8],
		v: [0.2, 0.5, 0.8],
		M: [0.75, 0.25, 0.15],
		m: [0.75, 0.25, 0.15],
		F: [0.75, 0.75, 0.75],
		f: [0.75, 0.75, 0.75],
		J: [1.0, 0.75, 0.25],
		j: [1.0, 0.75, 0.25],
		C: [0.5, 0.8, 0.1],
		c: [0.5, 0.8, 0.1],
		U: [0.6, 0.25, 0.9],
		u: [0.6, 0.25, 0.9],
	};
	/**
	 * @description Convert a color into a WebGL RGB with three
	 * float values between 0 and 1
	 */
	const parseColorToWebGLRgb = (color) => (
		color !== undefined && color.constructor === Array
			? color.slice(0, 3)
			: parseColorToRgb(color).slice(0, 3).map(n => n / 255)
	);

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const makeFacesVertexData = (graph, options = {}) => {
		const vertices_coords = graph.vertices_coords
			.map(coord => [...coord].concat(Array(3 - coord.length).fill(0)));
		const vertices_normal = makeVerticesNormal(graph);
		const vertices_barycentric = vertices_coords
			.map((_, i) => i % 3)
			.map(n => [n === 0 ? 1 : 0, n === 1 ? 1 : 0, n === 2 ? 1 : 0]);
		// const rawEdges = graph.faces_rawEdge.flatMap(n => [n, n, n]);
		const facesEdgesIsJoined = graph.faces_edges
			.map(edges => edges
				.map(e => graph.edges_assignment[e])
				.map(a => a === "J" || a === "j"));
		if (!options.showTrianglulation) {
			for (let i = 0; i < facesEdgesIsJoined.length; i += 1) {
				if (facesEdgesIsJoined[i][0]) {
					vertices_barycentric[i * 3 + 0][2] = vertices_barycentric[i * 3 + 1][2] = 100;
				}
				if (facesEdgesIsJoined[i][1]) {
					vertices_barycentric[i * 3 + 1][0] = vertices_barycentric[i * 3 + 2][0] = 100;
				}
				if (facesEdgesIsJoined[i][2]) {
					vertices_barycentric[i * 3 + 0][1] = vertices_barycentric[i * 3 + 2][1] = 100;
				}
			}
		}
		return {
			vertices_coords,
			vertices_normal,
			vertices_barycentric,
		};
	};

	// thick edges
	const makeThickEdgesVertexData = (graph, options) => {
		if (!graph || !graph.vertices_coords || !graph.edges_vertices) { return []; }
		const assignmentColors = options && options.dark ? dark : light;
		const assignment_color = {
			...assignmentColors,
			...options,
		};
		const vertices_coords3D = graph.vertices_coords
			.map(coord => [...coord].concat(Array(3 - coord.length).fill(0)));
		const vertices_coords = graph.edges_vertices
			.flatMap(edge => edge
				.map(v => vertices_coords3D[v]))
			.flatMap(coord => [coord, coord, coord, coord]);
		const edgesVector = makeEdgesVector(graph);
		const vertices_color = graph.edges_assignment
			? graph.edges_assignment
				.flatMap(a => Array(8).fill(assignment_color[a]))
			: graph.edges_vertices
				.flatMap(() => Array(8).fill(assignment_color.U));
		const verticesEdgesVector = edgesVector
			.flatMap(el => [el, el, el, el, el, el, el, el]);
		const vertices_vector = graph.edges_vertices
			.flatMap(() => [
				[1, 0],
				[0, 1],
				[-1, 0],
				[0, -1],

				[1, 0],
				[0, 1],
				[-1, 0],
				[0, -1],
			]);
		return {
			vertices_coords,
			vertices_color,
			verticesEdgesVector,
			vertices_vector,
		};
	};

	var foldedData = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeFacesVertexData: makeFacesVertexData,
		makeThickEdgesVertexData: makeThickEdgesVertexData
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const makeFoldedVertexArrays = (gl, program, graph, options = {}) => {
		if (!graph || !graph.vertices_coords || !graph.faces_vertices) {
			return [];
		}
		const {
			vertices_coords,
			vertices_normal,
			vertices_barycentric,
		} = makeFacesVertexData(graph, options);
		return [{
			location: gl.getAttribLocation(program, "v_position"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_coords.length ? vertices_coords[0].length : 3,
			data: new Float32Array(vertices_coords.flat()),
		}, {
			location: gl.getAttribLocation(program, "v_normal"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_normal.length ? vertices_normal[0].length : 3,
			data: new Float32Array(vertices_normal.flat()),
		}, {
			location: gl.getAttribLocation(program, "v_barycentric"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: 3,
			data: new Float32Array(vertices_barycentric.flat()),
		},
			// { location: gl.getAttribLocation(program, "v_rawEdge"),
			// 	buffer: gl.createBuffer(),
			// 	type: gl.FLOAT,
			// 	// type: gl.INT,
			// 	// type: gl.UNSIGNED_BYTE,
			// 	length: 1,
			// 	data: new Float32Array(rawEdges.flat()) },
		].filter(el => el.location !== -1);
	};
	/**
	 * WebGL 2 can handle Uint32Array. WebGL 1 cannot and must use 16 bit.
	 */
	const makeFoldedElementArrays = (gl, version = 1, graph = {}) => {
		if (!graph || !graph.vertices_coords || !graph.faces_vertices) { return []; }
		return [{
			mode: gl.TRIANGLES,
			buffer: gl.createBuffer(),
			data: version === 2
				? new Uint32Array(graph.faces_vertices.flat())
				: new Uint16Array(graph.faces_vertices.flat()),
		}];
	};

	// thick edges

	const makeThickEdgesVertexArrays = (gl, program, graph, options = {}) => {
		if (!graph || !graph.vertices_coords || !graph.edges_vertices) {
			return [];
		}
		const {
			vertices_coords,
			vertices_color,
			verticesEdgesVector,
			vertices_vector,
		} = makeThickEdgesVertexData(graph, options.assignment_color);
		return [{
			location: gl.getAttribLocation(program, "v_position"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_coords.length ? vertices_coords[0].length : 3,
			data: new Float32Array(vertices_coords.flat()),
		}, {
			location: gl.getAttribLocation(program, "v_color"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_color.length ? vertices_color[0].length : 3,
			data: new Float32Array(vertices_color.flat()),
		}, {
			location: gl.getAttribLocation(program, "edge_vector"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: verticesEdgesVector.length ? verticesEdgesVector[0].length : 3,
			data: new Float32Array(verticesEdgesVector.flat()),
		}, {
			location: gl.getAttribLocation(program, "vertex_vector"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_vector.length ? vertices_vector[0].length : 3,
			data: new Float32Array(vertices_vector.flat()),
		}].filter(el => el.location !== -1);
	};

	const makeThickEdgesElementArrays = (gl, version = 1, graph = {}) => {
		if (!graph || !graph.edges_vertices) { return []; }
		const edgesTriangles = graph.edges_vertices
			.map((_, i) => i * 8)
			.flatMap(i => [
				i + 0, i + 1, i + 4,
				i + 4, i + 1, i + 5,
				i + 1, i + 2, i + 5,
				i + 5, i + 2, i + 6,
				i + 2, i + 3, i + 6,
				i + 6, i + 3, i + 7,
				i + 3, i + 0, i + 7,
				i + 7, i + 0, i + 4,
			]);
		return [{
			mode: gl.TRIANGLES,
			buffer: gl.createBuffer(),
			data: version === 2
				? new Uint32Array(edgesTriangles)
				: new Uint16Array(edgesTriangles),
		}];
	};

	var foldedArrays = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeFoldedElementArrays: makeFoldedElementArrays,
		makeFoldedVertexArrays: makeFoldedVertexArrays,
		makeThickEdgesElementArrays: makeThickEdgesElementArrays,
		makeThickEdgesVertexArrays: makeThickEdgesVertexArrays
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description find a topological ordering from a set of faceOrders
	 * @param {FOLD} graph a FOLD graph with the keys faceOrders, faces_normal
	 * @param {number[]} faces an optional subset of face indices,
	 * if provided, the order will only be calculated for these faces,
	 * if left out, face orders for all faces will be computed.
	 * @returns {number[]} layers_face, for every layer (key) which face (value) inhabits it.
	 * @linkcode Origami ./src/layer/topological.js 10
	 */
	const topologicalOrder = ({ faceOrders, faces_normal }, faces) => {
		if (!faceOrders) { return []; }
		if (!faces) { faces = faces_normal.map((_, i) => i); }
		const facesHash = {};
		faces.forEach(face => { facesHash[face] = true; });
		faces[0];
		const faces_normal_match = [];
		faces.forEach(face => {
			faces_normal_match[face] = dot(faces_normal[face], faces_normal[faces[0]]) > 0;
		});
		// create an array where every face involved gets an index and an array as its value
		// this array will contain every face that is "below" this face.
		const facesBelow = [];
		// const facesAbove = [];
		faces.forEach(face => { facesBelow[face] = []; });
		// faces.forEach(face => { facesAbove[face] = []; })
		faceOrders.forEach(order => {
			// "faces" is already disjoint. we only need to check one face in order
			if (!facesHash[order[0]]) { return; }
			// this pair states face [0] is above face [1]. according to the +1 -1 order,
			// and whether or not the reference face [1] normal is flipped. (xor either)
			const pair = (order[2] === -1) ^ (!faces_normal_match[order[1]])
				? [order[1], order[0]]
				: [order[0], order[1]];
			facesBelow[pair[0]].push(pair[1]);
			// facesAbove[pair[1]].push(pair[0]);
		});
		const layers_face = []; // this is the topological ordering
		const faces_visited = {};
		const recurse = (face) => {
			faces_visited[face] = true;
			facesBelow[face].forEach(f => {
				if (faces_visited[f]) { return; }
				recurse(f);
			});
			layers_face.push(face);
		};
		faces.forEach(face => {
			if (faces_visited[face]) { return; }
			recurse(face);
		});
		// console.log("faces", faces);
		// console.log("faceOrders", faceOrders);
		// console.log("faces_normal_match", faces_normal_match);
		// console.log("facesBelow", facesBelow);
		// console.log("facesAbove", facesAbove);
		// console.log("layers_face", layers_face);
		return layers_face;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given a graph with a faces_layer, a topological sorting
	 * of faces, for a flat-folded 2D graph, get an array where every face
	 * is given a layer and a vector, which will always be [0, 0, 1].
	 * @param {FOLD} graph a FOLD graph with the parameter faces_layer.
	 * @returns {object[]} an array of objects, one for every face, each
	 * with properties "vector" and "layer".
	 * @linkcode Origami ./src/layer/nudge.js 16
	 */
	const nudgeFacesWithFacesLayer = ({ faces_layer }) => {
		const faces_nudge = [];
		const layers_face = invertMap(faces_layer);
		layers_face.forEach((face, layer) => {
			faces_nudge[face] = {
				vector: [0, 0, 1],
				layer,
			};
		});
		return faces_nudge;
	};
	/**
	 * @description Given a graph which contains a faceOrders, get an array
	 * of information for each face, what is its displacement vector, and
	 * what is its displacement magnitude integer, indicating which layer
	 * this face lies on.
	 * @param {FOLD} graph a FOLD graph with faceOrders.
	 * @returns {object[]} an array of objects, one for every face, each
	 * with properties "vector" and "layer".
	 * @linkcode Origami ./src/layer/nudge.js 37
	 */
	const nudgeFacesWithFaceOrders = ({ vertices_coords, faces_vertices, faceOrders }) => {
		const faces_normal = makeFacesNormal({ vertices_coords, faces_vertices });
		// create a graph where the vertices are the faces, and edges
		// are connections between faces according to faceOrders
		// using this representation, find the disjoint sets of faces,
		// those which are isolated from each other according to layer orders
		const faces_sets = connectedComponents(makeVerticesVerticesUnsorted({
			edges_vertices: faceOrders.map(ord => [ord[0], ord[1]]),
		}));
		const sets_faces = invertMap(faces_sets)
			.map(el => (el.constructor === Array ? el : [el]));
		const sets_layers_face = sets_faces
			.map(faces => topologicalOrder({ faceOrders, faces_normal }, faces));
		const sets_normals = sets_faces.map(faces => faces_normal[faces[0]]);
		const faces_nudge = [];
		sets_layers_face.forEach((set, i) => set.forEach((face, index) => {
			faces_nudge[face] = {
				vector: sets_normals[i],
				layer: index,
			};
		}));
		return faces_nudge;
	};

	var nudge = /*#__PURE__*/Object.freeze({
		__proto__: null,
		nudgeFacesWithFaceOrders: nudgeFacesWithFaceOrders,
		nudgeFacesWithFacesLayer: nudgeFacesWithFacesLayer
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const LAYER_NUDGE = 5e-6;

	const makeExplodedGraph = (graph, layerNudge = LAYER_NUDGE) => {
		const exploded = JSON.parse(JSON.stringify(graph));
		// we render "J" joined edges differently from all others. if edges_assignment
		// doesn't exist, make it with all assignments set to "U".
		// the user will never see this data, it's just for visualization.
		if (!exploded.edges_assignment) {
			const edgeCount = count.edges(graph) || countImplied.edges(graph);
			exploded.edges_assignment = Array(edgeCount).fill("U");
		}
		let faces_nudge = [];
		if (exploded.faceOrders) {
			faces_nudge = nudgeFacesWithFaceOrders(exploded);
		} else if (exploded.faces_layer) {
			faces_nudge = nudgeFacesWithFacesLayer(exploded);
		}
		// triangulate will modify faces and edges.
		// use face information to match data.
		const change = triangulate(exploded);
		// explode will modify edges and vertices.
		// we don't need the return information for anything just yet.
		explode(exploded);
		// Object.assign(change, change2);

		if (change.faces) {
			const backmap = invertMap(change.faces.map);
			backmap.forEach((oldFace, face) => {
				const nudge = faces_nudge[oldFace];
				if (!nudge) { return; }
				exploded.faces_vertices[face].forEach(v => {
					const vec = scale$1(nudge.vector, nudge.layer * layerNudge);
					exploded.vertices_coords[v] = add(
						resize(3, exploded.vertices_coords[v]),
						vec,
					);
				});
			});
		}
		return exploded;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const makeUniforms$1 = (gl, {
		projectionMatrix,
		modelViewMatrix,
		frontColor,
		backColor,
		strokeWidth,
		opacity,
	}) => ({
		u_matrix: {
			func: "uniformMatrix4fv",
			value: multiplyMatrices4(projectionMatrix, modelViewMatrix),
		},
		u_projection: {
			func: "uniformMatrix4fv",
			value: projectionMatrix,
		},
		u_modelView: {
			func: "uniformMatrix4fv",
			value: modelViewMatrix,
		},
		u_frontColor: {
			func: "uniform3fv",
			value: parseColorToWebGLRgb(frontColor),
		},
		u_backColor: {
			func: "uniform3fv",
			value: parseColorToWebGLRgb(backColor),
		},
		u_strokeWidth: {
			func: "uniform1f",
			value: strokeWidth,
		},
		u_opacity: {
			func: "uniform1f",
			value: opacity,
		},
	});

	const model_300_vert = `#version 300 es
uniform mat4 u_modelView;
uniform mat4 u_matrix;
uniform vec3 u_frontColor;
uniform vec3 u_backColor;
in vec3 v_position;
in vec3 v_normal;
out vec3 front_color;
out vec3 back_color;
void main () {
	gl_Position = u_matrix * vec4(v_position, 1);
	vec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));
	float brightness = 0.5 + light.x * 0.15 + light.z * 0.35;
	front_color = u_frontColor * brightness;
	back_color = u_backColor * brightness;
}
`;

	const thick_edges_300_vert$1 = `#version 300 es
uniform mat4 u_matrix;
uniform mat4 u_projection;
uniform mat4 u_modelView;
uniform float u_strokeWidth;
in vec3 v_position;
in vec3 v_color;
in vec3 edge_vector;
in vec2 vertex_vector;
out vec3 blend_color;
void main () {
	vec3 edge_norm = normalize(edge_vector);
	// axis most dissimilar to edge_vector
	vec3 absNorm = abs(edge_norm);
	vec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);
	vec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;
	// two perpendiculars. with edge_vector these make basis vectors
	vec3 one = cross(axis, edge_norm);
	vec3 two = cross(one, edge_norm);
	vec3 displaceNormal = normalize(
		one * vertex_vector.x + two * vertex_vector.y
	);
	vec3 displace = displaceNormal * (u_strokeWidth * 0.5);
	gl_Position = u_matrix * vec4(v_position + displace, 1);
	blend_color = v_color;
}
`;

	const outlined_model_300_frag = `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif
uniform float u_opacity;
in vec3 front_color;
in vec3 back_color;
in vec3 barycentric;
out vec4 outColor;
float edgeFactor(vec3 barycenter) {
	vec3 d = fwidth(barycenter);
	vec3 a3 = smoothstep(vec3(0.0), d*3.5, barycenter);
	return min(min(a3.x, a3.y), a3.z);
}
void main () {
	gl_FragDepth = gl_FragCoord.z;
	vec3 color = gl_FrontFacing ? front_color : back_color;
	outColor = vec4(mix(vec3(0.0), color, edgeFactor(barycentric)), u_opacity);
}
`;

	const outlined_model_100_frag = `#version 100
precision mediump float;
uniform float u_opacity;
varying vec3 barycentric;
varying vec3 front_color;
varying vec3 back_color;
void main () {
	vec3 color = gl_FrontFacing ? front_color : back_color;
	vec3 boundary = vec3(0.0, 0.0, 0.0)
	// gl_FragDepth = 0.5;
	gl_FragColor = any(lessThan(barycentric, vec3(0.02)))
		? vec4(boundary, u_opacity)
		: vec4(color, u_opacity);
}
`;

	const model_100_vert = `#version 100
attribute vec3 v_position;
attribute vec3 v_normal;
uniform mat4 u_projection;
uniform mat4 u_modelView;
uniform mat4 u_matrix;
uniform vec3 u_frontColor;
uniform vec3 u_backColor;
varying vec3 normal_color;
varying vec3 front_color;
varying vec3 back_color;
void main () {
	gl_Position = u_matrix * vec4(v_position, 1);
	vec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));
	float brightness = 0.5 + light.x * 0.15 + light.z * 0.35;
	front_color = u_frontColor * brightness;
	back_color = u_backColor * brightness;
}
`;

	const thick_edges_100_vert$1 = `#version 100
attribute vec3 v_position;
attribute vec3 v_color;
attribute vec3 edge_vector;
attribute vec2 vertex_vector;
uniform mat4 u_matrix;
uniform mat4 u_projection;
uniform mat4 u_modelView;
uniform float u_strokeWidth;
varying vec3 blend_color;
void main () {
	vec3 edge_norm = normalize(edge_vector);
	// axis most dissimilar to edge_vector
	vec3 absNorm = abs(edge_norm);
	vec3 xory = absNorm.x < absNorm.y ? vec3(1,0,0) : vec3(0,1,0);
	vec3 axis = absNorm.x > absNorm.z && absNorm.y > absNorm.z ? vec3(0,0,1) : xory;
	// two perpendiculars. with edge_vector these make basis vectors
	vec3 one = cross(axis, edge_norm);
	vec3 two = cross(one, edge_norm);
	vec3 displaceNormal = normalize(
		one * vertex_vector.x + two * vertex_vector.y
	);
	vec3 displace = displaceNormal * (u_strokeWidth * 0.5);
	gl_Position = u_matrix * vec4(v_position + displace, 1);
	blend_color = v_color;
}
`;

	const model_100_frag = `#version 100
precision mediump float;
uniform float u_opacity;
varying vec3 front_color;
varying vec3 back_color;
void main () {
	vec3 color = gl_FrontFacing ? front_color : back_color;
	gl_FragColor = vec4(color, u_opacity);
}
`;

	const simple_300_frag = `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif
in vec3 blend_color;
out vec4 outColor;
 
void main() {
	outColor = vec4(blend_color.rgb, 1);
}
`;

	const outlined_model_100_vert = `#version 100
attribute vec3 v_position;
attribute vec3 v_normal;
attribute vec3 v_barycentric;
uniform mat4 u_projection;
uniform mat4 u_modelView;
uniform mat4 u_matrix;
uniform vec3 u_frontColor;
uniform vec3 u_backColor;
varying vec3 normal_color;
varying vec3 barycentric;
varying vec3 front_color;
varying vec3 back_color;
void main () {
	gl_Position = u_matrix * vec4(v_position, 1);
	barycentric = v_barycentric;
	vec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));
	float brightness = 0.5 + light.x * 0.15 + light.z * 0.35;
	front_color = u_frontColor * brightness;
	back_color = u_backColor * brightness;
}
`;

	const outlined_model_300_vert = `#version 300 es
uniform mat4 u_modelView;
uniform mat4 u_matrix;
uniform vec3 u_frontColor;
uniform vec3 u_backColor;
in vec3 v_position;
in vec3 v_normal;
in vec3 v_barycentric;
in float v_rawEdge;
out vec3 front_color;
out vec3 back_color;
out vec3 barycentric;
// flat out int rawEdge;
flat out int provokedVertex;
void main () {
	gl_Position = u_matrix * vec4(v_position, 1);
	provokedVertex = gl_VertexID;
	barycentric = v_barycentric;
	// rawEdge = int(v_rawEdge);
	vec3 light = abs(normalize((vec4(v_normal, 1) * u_modelView).xyz));
	float brightness = 0.5 + light.x * 0.15 + light.z * 0.35;
	front_color = u_frontColor * brightness;
	back_color = u_backColor * brightness;
}
`;

	const model_300_frag = `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif
uniform float u_opacity;
in vec3 front_color;
in vec3 back_color;
out vec4 outColor;
void main () {
	gl_FragDepth = gl_FragCoord.z;
	vec3 color = gl_FrontFacing ? front_color : back_color;
	outColor = vec4(color, u_opacity);
}
`;

	const simple_100_frag = `#version 100
precision mediump float;
varying vec3 blend_color;
void main () {
	gl_FragColor = vec4(blend_color.rgb, 1);
}
`;

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const foldedFormFaces = (gl, version = 1, graph = {}, options = {}) => {
		const exploded = makeExplodedGraph(graph, options.layerNudge);
		const program = version === 1
			? createProgram(gl, model_100_vert, model_100_frag)
			: createProgram(gl, model_300_vert, model_300_frag);
		return {
			program,
			vertexArrays: makeFoldedVertexArrays(gl, program, exploded, options),
			elementArrays: makeFoldedElementArrays(gl, version, exploded),
			flags: [gl.DEPTH_TEST],
			makeUniforms: makeUniforms$1,
		};
	};

	const foldedFormEdges = (gl, version = 1, graph = {}, options = {}) => {
		const program = version === 1
			? createProgram(gl, thick_edges_100_vert$1, simple_100_frag)
			: createProgram(gl, thick_edges_300_vert$1, simple_300_frag);
		return {
			program,
			vertexArrays: makeThickEdgesVertexArrays(gl, program, graph, options),
			elementArrays: makeThickEdgesElementArrays(gl, version, graph),
			flags: [gl.DEPTH_TEST],
			makeUniforms: makeUniforms$1,
		};
	};

	const foldedFormFacesOutlined = (gl, version = 1, graph = {}, options = {}) => {
		const exploded = makeExplodedGraph(graph, options.layerNudge);
		const program = version === 1
			? createProgram(gl, outlined_model_100_vert, outlined_model_100_frag)
			: createProgram(gl, outlined_model_300_vert, outlined_model_300_frag);
		return {
			program,
			vertexArrays: makeFoldedVertexArrays(gl, program, exploded, options),
			elementArrays: makeFoldedElementArrays(gl, version, exploded),
			flags: [gl.DEPTH_TEST],
			makeUniforms: makeUniforms$1,
		};
	};

	var foldedPrograms = /*#__PURE__*/Object.freeze({
		__proto__: null,
		foldedFormEdges: foldedFormEdges,
		foldedFormFaces: foldedFormFaces,
		foldedFormFacesOutlined: foldedFormFacesOutlined
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const WebGLFoldedForm = (gl, version = 1, graph = {}, options = {}) => {
		const programs = [];
		// either Faces, or FacesOutlined
		if (options.faces !== false) {
			if (options.outlines === false) {
				programs.push(foldedFormFaces(gl, version, graph, options));
			} else {
				programs.push(foldedFormFacesOutlined(gl, version, graph, options));
			}
		}
		// if edges option is on, also add thick edges
		if (options.edges === true) {
			programs.push(foldedFormEdges(gl, version, graph, options));
		}
		return programs;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const make2D$1 = (coords) => coords
		.map(coord => [0, 1]
			.map(i => coord[i] || 0));

	const makeCPEdgesVertexData = (graph, options) => {
		if (!graph || !graph.vertices_coords || !graph.edges_vertices) { return []; }
		const assignmentColors = options && options.dark ? dark : light;
		const assignment_color = {
			...assignmentColors,
			...options,
		};
		const vertices_coords = make2D$1(graph.edges_vertices
			.flatMap(edge => edge
				.map(v => graph.vertices_coords[v]))
			.flatMap(coord => [coord, coord]));
		const edgesVector = make2D$1(makeEdgesVector(graph));
		const vertices_color = graph.edges_assignment
			? graph.edges_assignment.flatMap(a => [
				assignment_color[a],
				assignment_color[a],
				assignment_color[a],
				assignment_color[a],
			])
			: graph.edges_vertices.flatMap(() => [
				assignment_color.U,
				assignment_color.U,
				assignment_color.U,
				assignment_color.U,
			]);
		const verticesEdgesVector = edgesVector
			.flatMap(el => [el, el, el, el]);
		const vertices_vector = graph.edges_vertices
			.flatMap(() => [[1, 0], [-1, 0], [-1, 0], [1, 0]]);
		return {
			vertices_coords,
			vertices_color,
			verticesEdgesVector,
			vertices_vector,
		};
	};

	var cpData = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeCPEdgesVertexData: makeCPEdgesVertexData
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const makeCPEdgesVertexArrays = (gl, program, graph, options) => {
		if (!graph || !graph.vertices_coords || !graph.edges_vertices) {
			return [];
		}
		const {
			vertices_coords,
			vertices_color,
			verticesEdgesVector,
			vertices_vector,
		} = makeCPEdgesVertexData(graph, options);
		return [{
			location: gl.getAttribLocation(program, "v_position"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: 2,
			data: new Float32Array(vertices_coords.flat()),
		}, {
			location: gl.getAttribLocation(program, "v_color"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_color.length ? vertices_color[0].length : 2,
			data: new Float32Array(vertices_color.flat()),
		}, {
			location: gl.getAttribLocation(program, "edge_vector"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: verticesEdgesVector.length ? verticesEdgesVector[0].length : 2,
			data: new Float32Array(verticesEdgesVector.flat()),
		}, {
			location: gl.getAttribLocation(program, "vertex_vector"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: vertices_vector.length ? vertices_vector[0].length : 2,
			data: new Float32Array(vertices_vector.flat()),
		}].filter(el => el.location !== -1);
	};

	const makeCPEdgesElementArrays = (gl, version = 1, graph = {}) => {
		if (!graph || !graph.edges_vertices) { return []; }
		const edgesTriangles = graph.edges_vertices
			.map((_, i) => i * 4)
			.flatMap(i => [i + 0, i + 1, i + 2, i + 2, i + 3, i + 0]);
		return [{
			mode: gl.TRIANGLES,
			buffer: gl.createBuffer(),
			data: version === 2
				? new Uint32Array(edgesTriangles)
				: new Uint16Array(edgesTriangles),
		}];
	};

	const make2D = (coords) => coords
		.map(coord => [0, 1]
			.map(i => coord[i] || 0));

	const makeCPFacesVertexArrays = (gl, program, graph) => {
		if (!graph || !graph.vertices_coords) { return []; }
		return [{
			location: gl.getAttribLocation(program, "v_position"),
			buffer: gl.createBuffer(),
			type: gl.FLOAT,
			length: 2,
			data: new Float32Array(make2D(graph.vertices_coords).flat()),
		}].filter(el => el.location !== -1);
	};

	const makeCPFacesElementArrays = (gl, version = 1, graph = {}) => {
		if (!graph || !graph.vertices_coords || !graph.faces_vertices) { return []; }
		return [{
			mode: gl.TRIANGLES,
			buffer: gl.createBuffer(),
			data: version === 2
				? new Uint32Array(triangulateConvexFacesVertices(graph).flat())
				: new Uint16Array(triangulateConvexFacesVertices(graph).flat()),
		}];
	};

	var cpArrays = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeCPEdgesElementArrays: makeCPEdgesElementArrays,
		makeCPEdgesVertexArrays: makeCPEdgesVertexArrays,
		makeCPFacesElementArrays: makeCPFacesElementArrays,
		makeCPFacesVertexArrays: makeCPFacesVertexArrays
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const makeUniforms = (gl, {
		projectionMatrix,
		modelViewMatrix,
		cpColor,
		strokeWidth,
	}) => ({
		u_matrix: {
			func: "uniformMatrix4fv",
			value: multiplyMatrices4(projectionMatrix, modelViewMatrix),
		},
		u_projection: {
			func: "uniformMatrix4fv",
			value: projectionMatrix,
		},
		u_modelView: {
			func: "uniformMatrix4fv",
			value: modelViewMatrix,
		},
		u_cpColor: {
			func: "uniform3fv",
			value: parseColorToWebGLRgb(cpColor),
		},
		u_strokeWidth: {
			func: "uniform1f",
			value: strokeWidth,
		},
	});

	const cp_300_frag = `#version 300 es
#ifdef GL_FRAGMENT_PRECISION_HIGH
  precision highp float;
#else
  precision mediump float;
#endif
in vec3 blend_color;
out vec4 outColor;
void main() {
	outColor = vec4(blend_color.rgb, 1);
}
`;

	const cp_100_frag = `#version 100
precision mediump float;
varying vec3 blend_color;
void main () {
	gl_FragColor = vec4(blend_color.rgb, 1);
}
`;

	const thick_edges_300_vert = `#version 300 es
uniform mat4 u_matrix;
uniform float u_strokeWidth;
in vec2 v_position;
in vec3 v_color;
in vec2 edge_vector;
in vec2 vertex_vector;
out vec3 blend_color;
void main () {
	float sign = vertex_vector[0];
	float halfWidth = u_strokeWidth * 0.5;
	vec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;
	gl_Position = u_matrix * vec4(side + v_position, 0, 1);
	blend_color = v_color;
}
`;

	const thick_edges_100_vert = `#version 100
uniform mat4 u_matrix;
uniform float u_strokeWidth;
attribute vec2 v_position;
attribute vec3 v_color;
attribute vec2 edge_vector;
attribute vec2 vertex_vector;
varying vec3 blend_color;
void main () {
	float sign = vertex_vector[0];
	float halfWidth = u_strokeWidth * 0.5;
	vec2 side = normalize(vec2(edge_vector.y * sign, -edge_vector.x * sign)) * halfWidth;
	gl_Position = u_matrix * vec4(side + v_position, 0, 1);
	blend_color = v_color;
}
`;

	const cp_100_vert = `#version 100
uniform mat4 u_matrix;
uniform vec3 u_cpColor;
attribute vec2 v_position;
varying vec3 blend_color;
void main () {
	gl_Position = u_matrix * vec4(v_position, 0, 1);
	blend_color = u_cpColor;
}
`;

	const cp_300_vert = `#version 300 es
uniform mat4 u_matrix;
uniform vec3 u_cpColor;
in vec2 v_position;
out vec3 blend_color;
void main () {
	gl_Position = u_matrix * vec4(v_position, 0, 1);
	blend_color = u_cpColor;
}
`;

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const cpFacesV1 = (gl, graph = {}, options = undefined) => {
		const program = createProgram(gl, cp_100_vert, cp_100_frag);
		return {
			program,
			vertexArrays: makeCPFacesVertexArrays(gl, program, graph),
			elementArrays: makeCPFacesElementArrays(gl, 1, graph),
			flags: [],
			makeUniforms,
		};
	};

	const cpEdgesV1 = (gl, graph = {}, options = undefined) => {
		const program = createProgram(gl, thick_edges_100_vert, cp_100_frag);
		return {
			program,
			vertexArrays: makeCPEdgesVertexArrays(gl, program, graph, options),
			elementArrays: makeCPEdgesElementArrays(gl, 1, graph),
			flags: [],
			makeUniforms,
		};
	};

	const cpFacesV2 = (gl, graph = {}, options = undefined) => {
		const program = createProgram(gl, cp_300_vert, cp_300_frag);
		return {
			program,
			vertexArrays: makeCPFacesVertexArrays(gl, program, graph),
			elementArrays: makeCPFacesElementArrays(gl, 2, graph),
			flags: [],
			makeUniforms,
		};
	};

	const cpEdgesV2 = (gl, graph = {}, options = undefined) => {
		const program = createProgram(gl, thick_edges_300_vert, cp_300_frag);
		return {
			program,
			vertexArrays: makeCPEdgesVertexArrays(gl, program, graph, options),
			elementArrays: makeCPEdgesElementArrays(gl, 2, graph),
			flags: [],
			makeUniforms,
		};
	};

	var cpPrograms = /*#__PURE__*/Object.freeze({
		__proto__: null,
		cpEdgesV1: cpEdgesV1,
		cpEdgesV2: cpEdgesV2,
		cpFacesV1: cpFacesV1,
		cpFacesV2: cpFacesV2
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const WebGLCreasePattern = (gl, version = 1, graph = {}, options = undefined) => {
		switch (version) {
		case 1:
			return [cpFacesV1(gl, graph, options), cpEdgesV1(gl, graph, options)];
		case 2:
		default:
			return [cpFacesV2(gl, graph, options), cpEdgesV2(gl, graph, options)];
		}
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description WebGL methods
	 */
	var webgl = Object.assign(
		Object.create(null),
		{
			createProgram,
			initialize: initializeWebGL,
			foldedForm: WebGLFoldedForm,
			creasePattern: WebGLCreasePattern,
			// webGLHelpers,
		},
		view,
		program,
		foldedArrays,
		foldedData,
		foldedPrograms,
		cpArrays,
		cpData,
		cpPrograms,
	);

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Flip a model over by reversing the order of the faces
	 * in a faces_layer encoding.
	 * @param {number[]} faces_layer a faces_layer array
	 * @returns {number[]} a new faces_layer array
	 * @linkcode Origami ./src/layer/general.js 12
	 */
	const flipFacesLayer = faces_layer => invertMap(
		invertMap(faces_layer).reverse(),
	);
	/**
	 * @description Given a faces_layer ordering of faces in a graph,
	 * complute the edges_assignments, including "B", "F", "V", and "M".
	 * @param {FOLD} graph a FOLD graph, with the vertices already folded.
	 * @param {number[]} faces_layer a faces_layer array
	 * @returns {string[]} an edges_assignment array.
	 * @linkcode Origami ./src/layer/general.js 23
	 */
	const facesLayerToEdgesAssignments = (graph, faces_layer) => {
		const edges_assignment = [];
		const faces_winding = makeFacesWinding(graph);
		// set boundary creases
		const edges_faces = graph.edges_faces
			? graph.edges_faces
			: makeEdgesFaces(graph);
		edges_faces.forEach((faces, e) => {
			if (faces.length === 1) { edges_assignment[e] = "B"; }
			if (faces.length === 2) {
				const windings = faces.map(f => faces_winding[f]);
				if (windings[0] === windings[1]) {
					edges_assignment[e] = "F";
					return;
				}
				const layers = faces.map(f => faces_layer[f]);
				const local_dir = layers[0] < layers[1];
				const global_dir = windings[0] ? local_dir : !local_dir;
				edges_assignment[e] = global_dir ? "V" : "M";
			}
		});
		return edges_assignment;
	};
	/**
	 * @description Convert a set of face-pair layer orders (+1,-1,0)
	 * into a face-face relationship matrix.
	 * @param {number[]} faceOrders an array of FOLD spec faceOrders.
	 * @returns {number[][]} NxN matrix, number of faces, containing +1,-1,0
	 * as values showing the relationship between i to j in face[i][j].
	 * @linkcode Origami ./src/layer/general.js 54
	 */
	const faceOrdersToMatrix = (faceOrders) => {
		const faces = [];
		faceOrders.forEach(order => {
			faces[order[0]] = undefined;
			faces[order[1]] = undefined;
		});
		const matrix = faces.map(() => []);
		faceOrders
			// .filter((_, i) => orders[condition_keys[i]] !== 0)
			.forEach(([a, b, c]) => {
				matrix[a][b] = c;
				matrix[b][a] = -c;
			});
		return matrix;
	};

	var general = /*#__PURE__*/Object.freeze({
		__proto__: null,
		faceOrdersToMatrix: faceOrdersToMatrix,
		facesLayerToEdgesAssignments: facesLayerToEdgesAssignments,
		flipFacesLayer: flipFacesLayer
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description for a flat-foldable origami, this will return
	 * ONLY ONE of the possible layer arrangements of the faces.
	 * first it finds all pairwise face layer conditions, then
	 * finds a topological ordering of each condition.
	 * @param {object} graph a FOLD object, make sure the vertices
	 * have already been folded.
	 * @param {number} [epsilon=1e-6] an optional epsilon value
	 * @returns {number[]} a faces_layer object, describing,
	 * for each face (key) which layer the face inhabits (value)
	 */

	const makeFacesLayer = (graph) => {
		let { faceOrders, faces_normal } = graph;
		if (!faces_normal) {
			faces_normal = makeFacesNormal(graph);
		}
		return invertMap(topologicalOrder({ faceOrders, faces_normal }));
	};

	// export const faceOrdersToFacesLayer = (graph) => {
	// 	return topologicalOrder({ faceOrders, faces_normal }, faces);
	// };

	// const makeFacesLayer = (graph, epsilon) => {
	// 	const conditions = allLayerConditions(graph, epsilon)[0];
	// 	return invertMap(topologicalOrder(conditions, graph));
	// };

	// export default makeFacesLayer;

	var facesLayer = /*#__PURE__*/Object.freeze({
		__proto__: null,
		makeFacesLayer: makeFacesLayer
	});

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// todo, should epsilon be multiplied by 2?

	/**
	 * @description make an array of objects where each object represents one
	 * fold line, and contains all the tacos and tortillas sharing the fold line.
	 * @param {number[][]} folded_faces sectors in their folded positions, the result
	 * of calling "foldStripWithAssignments"
	 * @param {boolean} is_circular if the folded strip wraps around and joins with itself.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} array of taco objects. each taco object represents one
	 * fold location shared by multiple tacos. each taco object contains keys:
	 * "both", "left", "right" where the values are an array of pairs of faces,
	 * the pairs of adjacent faces around the taco edge. "left": [ [2,3] [6,0] ]
	 * @linkcode Origami ./src/layer/singleVertexSolver/makeFoldedStripTacos.js 18
	 */
	const makeFoldedStripTacos = (folded_faces, is_circular, epsilon) => {
		// center of each face, will be used to see if a taco faces left or right
		const faces_center = folded_faces
			.map((ends) => (ends ? (ends[0] + ends[1]) / 2 : undefined));
		const locations = [];
		// gather all fold locations that match, add them to the same group.
		// for every fold location, make one of these objects where the pairs are
		// the two adjacent faces on either side of the crease line.
		// {
		//   min: -0.1,
		//   max: 0.1,
		//   pairs: [ [2,3], [0,1] ],
		// };
		folded_faces.forEach((ends, i) => {
			if (!ends) { return; }
			// if the strip is not circular, skip the final round and don't wrap around
			if (!is_circular && i === folded_faces.length - 1) { return; }
			const fold_end = ends[1];
			const min = fold_end - (epsilon * 2);
			const max = fold_end + (epsilon * 2);
			const faces = [i, (i + 1) % folded_faces.length];
			// which side of the crease is the face on?
			// false = left (-), true = right (+)
			const sides = faces
				.map(f => faces_center[f])
				.map(center => center > fold_end);
			// place left tacos at index 1, right at 2, and neither (tortillas) at 0
			const taco_type = (!sides[0] && !sides[1]) * 1 + (sides[0] && sides[1]) * 2;
			// todo: this searches every time. could be improved with a sorted array.
			const match = locations
				.filter(el => el.min < fold_end && el.max > fold_end)
				.shift();
			const entry = { faces, taco_type };
			if (match) {
				match.pairs.push(entry);
			} else {
				locations.push({ min, max, pairs: [entry] });
			}
		});
		// ignore stacks which have only one taco. we know they pass the test.
		// technically we can also filter out after they have been separated
		// as we can ignore the case with 1 left and 1 right. it always passes too.
		// but these will get ignored in the next function anyway
		return locations
			.map(el => el.pairs)
			.filter(pairs => pairs.length > 1)
			.map(pairs => ({
				both: pairs.filter(el => el.taco_type === 0).map(el => el.faces),
				left: pairs.filter(el => el.taco_type === 1).map(el => el.faces),
				right: pairs.filter(el => el.taco_type === 2).map(el => el.faces),
			}));
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given two indices, return a copy of the array between them,
	 * excluding the elements at the indices themselves.
	 * @returns {any[]} the subarray exclusively between the two indices.
	 */
	const between = (arr, i, j) => (i < j
		? arr.slice(i + 1, j)
		: arr.slice(j + 1, i));
	/**
	 * because this test is meant to run during the intermediate steps while
	 * the a strip is being assembled, the strip may eventually be circular,
	 * but currently it isn't.
	 *
	 * @params {[number, number][]} for every sector, "start" and "end" of each sector
	 * this is the output of having run "foldStripWithAssignments"
	 * @param {number[]} layers_face, index is z-layer, value is the sector/face.
	 * @param {boolean} do assignments contain a boundary? (to test for loop around)
	 * @returns {boolean} does a violation occur. "false" means all good.
	 * @linkcode Origami ./src/layer/singleVertexSolver/validateTacoTortillaStrip.js 24
	 */
	const validateTacoTortillaStrip = (
		faces_folded,
		layers_face,
		is_circular = true,
		epsilon = EPSILON,
	) => {
		// for every sector/face, the value is its index in the layers_face array
		const faces_layer = invertMap(layers_face);
		// for every sector, the location of the end of the sector after folding
		// (the far end, the second end visited by the walk)
		const fold_location = faces_folded
			.map(ends => (ends ? ends[1] : undefined));
		// for every sector, the location of the end which lies nearest to -Infinity
		const faces_mins = faces_folded
			.map(ends => (ends ? Math.min(...ends) : undefined))
			.map(n => n + epsilon);
		// for every sector, the location of the end which lies nearest to +Infinity
		const faces_maxs = faces_folded
			.map(ends => (ends ? Math.max(...ends) : undefined))
			.map(n => n - epsilon);
		// we can't test the loop back around when j==end and i==0 because they only
		// connect after the piece has been completed,
		// but we do need to test it when that happens
		// const max = layers_face.length + (layers_face.length === sectors.length ? 0 : -1);
		// const faces_array_circular = is_circular
		//   && faces_layer.length === faces_folded.length;
		const max = faces_layer.length + (is_circular ? 0 : -1);
		// iterate through all the faces, take each face together with the next face,
		// establish the fold line between them, then check the layer stacking and
		// gather all faces that exist between this pair of faces, test each
		// of them to see if they cross through this pair's fold line.
		for (let i = 0; i < max; i += 1) {
			// this is the next face in the folding sequence
			const j = (i + 1) % faces_layer.length;
			// if two adjacent faces are in the same layer, they will not be causing an
			// overlap, at least not at their crease (because there is no crease).
			if (faces_layer[i] === faces_layer[j]) { continue; }
			// todo consider prebuilding a table of comparing fold locations with face mins and maxs
			// result of between contains both numbers and arrays: [5,[0,1],2,[3,4]]
			// the reduce will bring everything to the top level: [5,0,1,2,3,4]
			const layers_between = between(layers_face, faces_layer[i], faces_layer[j])
				.flat();
			// check if the fold line is (below/above) ALL of the sectors between it
			// it will be above if
			const all_below_min = layers_between
				.map(index => fold_location[i] < faces_mins[index])
				.reduce((a, b) => a && b, true);
			const all_above_max = layers_between
				.map(index => fold_location[i] > faces_maxs[index])
				.reduce((a, b) => a && b, true);
			if (!all_below_min && !all_above_max) { return false; }
		}
		return true;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description test a stack of tacos (all left or right) for self-intersection.
	 * for a collection of tacos which all point in the same direction,
	 * all pairs of faces in a taco-taco stack have a shared edge,
	 * give each pair a unique identifier (simplest, a unique integer 0...n),
	 * now we refer to each face simply by its pair identifier. so now a face
	 * layer stack would appear like: [1, 1, 0, 5, 5, 0] (which is a valid stack).
	 * a bad layer stack would be: [1, 5, 1, 5].
	 * @param {number[]} stacking order of each face where each face is
	 * encoded as its pair number identifier.
	 * @returns {boolean} true if the taco stack passes this test. false if fails.
	 * @linkcode Origami ./src/layer/singleVertexSolver/validateTacoTacoFacePairs.js 16
	 */
	const validateTacoTacoFacePairs = (face_pair_stack) => {
		// create a copy of "stack" that removes single faces currently missing
		// their other pair partner. this removes boundary faces (with no adj. face)
		// as well as stacks which are in the process of being constructed but not
		// yet final
		const pair_stack = nonUniqueElements(face_pair_stack);
		const pairs = {};
		let count = 0;
		for (let i = 0; i < pair_stack.length; i += 1) {
			if (pairs[pair_stack[i]] === undefined) {
				count += 1;
				pairs[pair_stack[i]] = count;
			} else if (pairs[pair_stack[i]] !== undefined) {
				// if we have seen this layer pair already, it MUST be appearing
				// in the correct order, that is, as it gets popped off the stack,
				// it must be the next-most-recently added pair to the stack.
				if (pairs[pair_stack[i]] !== count) { return false; }
				count -= 1;
				pairs[pair_stack[i]] = undefined;
			}
		}
		return true;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a layers_face (ensure that it is flat/only numbers)
	 * convert a stack of taco_faces in the form of [[f1,f2], [f3,f4]]
	 * into a flat array of the layers_face where each face is now an index
	 * to the location of the pair the face is inside of in taco_faces.
	 * @linkcode Origami ./src/layer/singleVertexSolver/validateLayerSolver.js 12
	 */
	const build_layers = (layers_face, faces_pair) => layers_face
		.map(f => faces_pair[f])
		.filter(a => a !== undefined);

	const validateLayerSolver = (
		faces_folded,
		layers_face,
		taco_face_pairs,
		circ_and_done,
		epsilon,
	) => {
		// if the strip contains "F" assignments, layers_face will contain
		// a mix of numbers and arrays of numbers, like: [1, 0, 5, [3, 4], 2]
		// as [3,4] are on the same "layer".
		// flatten this array so all numbers get pushed onto the top level, like:
		// [1, 0, 5, [3, 4], 2] into [1, 0, 5, 3, 4, 2].
		// now, this does create a layer preference between (3 and 4 in this example),
		// but in this specific use case we can be guaranteed that only one of those
		// will be used in the build_layers, as only one of a set of flat-
		// strip faces can exist in one taco stack location.
		const flat_layers_face = flattenArrays(layers_face);
		// taco-tortilla intersections
		if (!validateTacoTortillaStrip(
			faces_folded,
			layers_face,
			circ_and_done,
			epsilon,
		)) { return false; }
		// taco-taco intersections
		for (let i = 0; i < taco_face_pairs.length; i += 1) {
			const pair_stack = build_layers(flat_layers_face, taco_face_pairs[i]);
			if (!validateTacoTacoFacePairs(pair_stack)) { return false; }
		}
		return true;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * faces and assignments are fencepost aligned. assignments precedes faces.
	 *       faces: |-----(0)-----(1)-----(2)---- ... -(n-2)-------(n-1)-|
	 * assignments: |-(0)-----(1)-----(2)-----(3) ... -------(n-1)-------|
	 */
	/**
	 * these are the only creases that change the direction of the paper
	 */
	const change_map = {
		V: true, v: true, M: true, m: true,
	};
	/**
	 * @description convert a list of assignments into an array of
	 * booleans stating if that face between the pair of assignments
	 * has been flipped (true) or not (false). the first face is false.
	 *
	 * another way of saying this is if a face is "false", the face is
	 * moving to the right, if "true" moving to the left.
	 * @linkcode Origami ./src/layer/singleVertexSolver/general.js 22
	 */
	const assignmentsToFacesFlip = (assignments) => {
		let counter = 0;
		// because fencepost, and we are hard-coding the first face to be false,
		// we don't need to append the first post back to the end of this slice.
		const shifted_assignments = assignments.slice(1);
		// globally, the location that each fold takes place along the +X
		return [false].concat(shifted_assignments
			.map(a => (change_map[a] ? ++counter : counter))
			.map(count => count % 2 === 1));
	};
	/**
	 * model the movement of layers above or below the previous layer after a fold.
	 * valley fold sets the paper above the previous sector (and mountain below),
	 * but a valley fold AFTER a valley fold moves the paper below.
	 */
	const up_down = {
		V: 1, v: 1, M: -1, m: -1,
	};
	const upOrDown = (mv, i) => (i % 2 === 0
		? (up_down[mv] || 0)
		: -(up_down[mv] || 0));
	/**
	 * @description convert a list of assignments into an array of
	 * numbers stating if that face between the pair of assignments
	 * has been raised above or below the previous face in the +Z axis.
	 *
	 * +1 means this face lies above the previous face, -1 below.
	 * the first face implicitly starts at 0.
	 *
	 * These values describe the relationship between the current index
	 * and the next face (i + 1)%length index. and it describes the location
	 * of the second of the pair.
	 * index [0] indicates how face [1] is above/below face[0].
	 * @returns {number[]} unit directionality. +1 for up, -1 down
	 * @linkcode Origami ./src/layer/singleVertexSolver/general.js 58
	 */
	const assignmentsToFacesVertical = (assignments) => {
		let iterator = 0;
		// because fencepost, we are relating assignments[1] to face[0]
		return assignments
			.slice(1)
			.concat([assignments[0]])
			.map(a => {
				const updown = upOrDown(a, iterator);
				iterator += up_down[a] === undefined ? 0 : 1;
				return updown;
			});
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given an array of sectors (defined by length),
	 * and a fenceposted-array of fold assignments, fold the sectors
	 * along the numberline, returning each sector as a pair of numbers
	 * that mark the two ends of the of the folded sector: [end1, end2].
	 * The first sector is always starts at 0, and spans [0, sector].
	 *
	 * When a boundary edge is encountered, the walk stops, no sectors after
	 * the boundary will be included in the result. The algorithm will walk in
	 * one direction, incrementing, starting at index "start", stopping at "end".
	 * @param {number[]} faces an array of sector lengths
	 * @param {string[]} an array of assignments "B", "V", "M", "F"
	 * @returns {number[][]} array of sector positions with two indices representing
	 * either end of the sector. any sectors caught between multiple
	 * boundaries will be undefined.
	 * @linkcode Origami ./src/layer/singleVertexSolver/foldStripWithAssignments.js 20
	 */
	const foldStripWithAssignments = (faces, assignments) => {
		// one number for each sector, locally, the movement away from 0.
		const faces_end = assignmentsToFacesFlip(assignments)
			.map((flip, i) => faces[i] * (flip ? -1 : 1));
		// the cumulative position for each sector, stored as an array of 2:
		// [ the start of the sector, the end of the sector ]
		const cumulative = faces.map(() => undefined);
		cumulative[0] = [0, faces_end[0]];
		for (let i = 1; i < faces.length; i += 1) {
			if (assignments[i] === "B" || assignments[i] === "b") { break; }
			const prev = (i - 1 + faces.length) % faces.length;
			const prev_end = cumulative[prev][1];
			cumulative[i] = [prev_end, prev_end + faces_end[i]];
		}
		return cumulative;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const is_boundary = { B: true, b: true };
	/**
	 * @description Given an ordered set of faces and crease assignments
	 * between the faces, this recursive algorithm finds every combination
	 * of layer orderings that work without causing any self-intersections.
	 * "scalars" could be sector angles, where the sum of angles doesn't need to
	 * add up to 360, or this method can solve a strip of paper where "scalars"
	 * is not radial, simply 1D lengths between folds.
	 * If "scalars" represents a 1D folded strip which does not loop around, make
	 * sure to include two "B" assignments in the correct location.
	 * faces and assignments are fencepost aligned. assignments precedes faces.
	 * faces: |-----(0)-----(1)-----(2)---- ... -(n-2)-------(n-1)-|
	 * assig: |-(0)-----(1)-----(2)-----(3) ... -------(n-1)-------|
	 * @param {number[]} ordered unsigned scalars, the length of paper between folds
	 * @param {string[]} array of "M","V", assignment of fold between faces
	 * @returns {number[][]} array of arrays. each inner array is a solution.
	 * each solution is an ordering of faces_layer, where each index is a
	 * face and each value is the layer the face occupies.
	 * @linkcode Origami ./src/layer/singleVertexSolver/index.js 30
	 */
	const singleVertexSolver = (ordered_scalars, assignments, epsilon = EPSILON) => {
		const faces_folded = foldStripWithAssignments(ordered_scalars, assignments);
		const faces_updown = assignmentsToFacesVertical(assignments);
		// todo: we only really need to check index [0] and [length-1]
		const is_circular = assignments
			.map(a => !(is_boundary[a]))
			.reduce((a, b) => a && b, true);
		// if the sector contains no boundary (cuts), check if the folded state
		// start and end line up, if not, it's clear no solution is possible.
		if (is_circular) {
			const start = faces_folded[0][0];
			const end = faces_folded[faces_folded.length - 1][1];
			if (Math.abs(start - end) > epsilon) { return []; }
		}
		// prepare tacos ahead of time, since we know the fold locations
		// only grab the left and right tacos. return their adjacent faces in the
		// form of which pair they are a part of, as an inverted array.
		// taco-tortilla testing will happen using a different data structure.
		const taco_face_pairs = makeFoldedStripTacos(faces_folded, is_circular, epsilon)
			.map(taco => [taco.left, taco.right]
				.map(invertMap)
				.filter(arr => arr.length > 1))
			.reduce((a, b) => a.concat(b), []);
		/**
		 * @description Consectively visit each face from 0...n, recursively
		 * inserting it above or below the current position (in all slots above
		 * or below). At the beginning of the recusive function check if there is a
		 * violation where the newly-inserted face is causing a self-intersection.
		 * @param {number[]} layering is an inverted form of the final return value.
		 * indices represent layers, from 0 to N, moving upwards in +Z space,
		 * and faces will be inserted into layers as we search for a layer ordering.
		 * @param {number} iteration count, relates directly to the face index
		 * @param {number} layer, the +Z index layer currently being added to,
		 * this is the splice index of layers_face we will be adding the face to.
		 */
		const recurse = (layers_face = [0], face = 0, layer = 0) => {
			const next_face = face + 1;
			// will the next face be above or below the current face's position?
			const next_dir = faces_updown[face];
			// because this test will run during the intermediate assembly of a strip.
			// the strip may eventually be circular, but currently it isn't.
			// set this boolean to be true only if we are also at the end.
			const is_done = face >= ordered_scalars.length - 1;
			// is circular AND is done (just added the final face)
			const circ_and_done = is_circular && is_done;
			// test for any self-intersections throughout the entire layering
			if (!validateLayerSolver(
				faces_folded,
				layers_face,
				taco_face_pairs,
				circ_and_done,
				epsilon,
			)) {
				return [];
			}
			// just before exit.
			// the final crease must turn the correct direction back to the start.
			if (circ_and_done) {
				// next_dir is now indicating the direction from the final face to the
				// first face, test if this also matches the orientation of the faces.
				const faces_layer = invertMap(layers_face);
				const first_face_layer = faces_layer[0];
				const last_face_layer = faces_layer[face];
				if (next_dir > 0 && last_face_layer > first_face_layer) { return []; }
				if (next_dir < 0 && last_face_layer < first_face_layer) { return []; }
				// todo: what about === 0 ?
			}

			// Exit case. all faces have been traversed.
			if (is_done) { return [layers_face]; }
			// Continue case.
			// depending on the direction of the next face (above, below, same level),
			// insert the face into one or many places, then repeat the recursive call.
			// note: causing a self-intersection is possible, hence, check at beginning
			if (next_dir === 0) {
				// append the next face into this layer (making it an array if necessary)
				// and repeat the recursion with no additional layers, just this one.
				layers_face[layer] = [next_face].concat(layers_face[layer]);
				// no need to call .slice() on layers_face. only one path forward.
				return recurse(layers_face, next_face, layer);
			}
			// given our current position (layer) and next_dir (up or down),
			// get the subarray that's either above or below the current layer.
			// these are all the indices we will attempt to insert the new face.
			// - below: [0, layer]. includes layer
			// - above: (layer, length]. excludes layer. includes length (# of faces)
			// this way all indices (including +1 at the end) are covered once.
			// these are used in the splice() method, 0...Length, inserting an element
			// will place the new element before the old element at that same index.
			// so, we need +1 indices (at the end) to be able to append to the end.
			const splice_layers = next_dir === 1
				? Array.from(Array(layers_face.length - layer))
					.map((_, i) => layer + i + 1)
				: Array.from(Array(layer + 1))
					.map((_, i) => i);
			// recursively attempt to fit the next folded face at all possible layers.
			// make a deep copy of the layers_face arrays.
			const next_layers_faces = splice_layers.map(() => clone(layers_face));
			// insert the next_face into all possible valid locations (above or below)
			next_layers_faces
				.forEach((layers, i) => layers.splice(splice_layers[i], 0, next_face));
			// recursively call
			return next_layers_faces
				.map((layers, i) => recurse(layers, next_face, splice_layers[i]))
				.reduce((a, b) => a.concat(b), []);
		};
		// after collecting all layers_face solutions, convert them into faces_layer
		return recurse().map(invertMap);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @name singleVertexAssignmentSolver
	 * @description This extends the singleVertexSolver to also solve unassigned
	 * assignments. The assignments parameter can be left empty entirely, or,
	 * if you only know some assignments, place "U" in the unknown spots.
	 * faces and assignments are fencepost aligned. assignments precedes faces.
	 *       faces: |-----(0)-----(1)-----(2)---- ... -(n-2)-------(n-1)-|
	 * assignments: |-(0)-----(1)-----(2)-----(3) ... -------(n-1)-------|
	 * @param {number[]} orderedScalars an ordered list of scalars, the lengths of the faces
	 * @param {string[]|undefined} assignments an array of single character assignment values
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object[]} array of solutions where each solution contains
	 * "layer" and "assignment", where layer is a "faces_layer" mapping, and assignment
	 * is an array of assignment characters.
	 * @linkcode Origami ./src/layer/singleVertexSolver/assignmentSolver.js 20
	 */
	const assignmentSolver = (orderedScalars, assignments, epsilon) => {
		if (assignments == null) {
			assignments = orderedScalars.map(() => "U");
		}
		// enumerate all possible assignments by replacing "U" with both "M" and "V"
		const all_assignments = maekawaAssignments(assignments);
		const layers = all_assignments
			.map(assigns => singleVertexSolver(orderedScalars, assigns, epsilon));
		return all_assignments
			.map((_, i) => i)
			.filter(i => layers[i].length > 0)
			.map(i => ({
				assignment: all_assignments[i],
				layer: layers[i],
			}));
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description each state encodes a valid layer combination. each number
	 * describes a relationship between pairs of faces, indicating:
	 * - 1: the first face is above the second face
	 * - 2: the second face is above the first face
	 * each taco/tortilla set has its own encoding of face pairs.
	 */
	// A-C and B-D are connected
	// "(A,C) (B,D) (B,C) (A,D) (A,B) (C,D)"
	const taco_taco_valid_states = [
		"111112",
		"111121",
		"111222",
		"112111",
		"121112",
		"121222",
		"122111",
		"122212",
		"211121",
		"211222",
		"212111",
		"212221",
		"221222",
		"222111",
		"222212",
		"222221",
	];
	// A-C is the taco, B is the tortilla
	// (A,C) (A,B) (B,C)
	const taco_tortilla_valid_states = ["112", "121", "212", "221"];

	// A-B and C-D are connected, A is above/below C, B is above/below D
	// (A,C) (B,D)
	// in the case of tortilla-crossing face, the crossing face
	// appears twice, the same index appears in place of both C and D
	const tortilla_tortilla_valid_states = ["11", "22"];

	// const tortilla_face_valid_states = [];
	// (A,B) (B,C) (C,A)
	const transitivity_valid_states = [
		"112",
		"121",
		"122",
		"211",
		"212",
		"221",
	];
	/**
	 * @param {object[]} states, array of objects containing permutations (keys)
	 *  and their values (solution is possible or not)
	 * @param {number} t, 0...N the index in "states" we are looking at.
	 * @param {string} key, a layer order as a string, like "001221"
	 */
	const check_state = (states, t, key) => {
		// convert the key into an array of integers (0, 1, 2)
		const A = Array.from(key).map(char => parseInt(char, 10));
		// for each "t" index of states, only include keys which contain
		// "t" number of unknowns (0s).
		if (A.filter(x => x === 0).length !== t) { return; }
		states[t][key] = false;
		// solution will either be 0, 1, or an array of modifications
		let solution = false;
		for (let i = 0; i < A.length; i += 1) {
			const modifications = [];
			// look at the unknown layers only (index is 0)
			if (A[i] !== 0) { continue; }
			// in place of the unknowns, try each of the possible states (1, 2)
			for (let x = 1; x <= 2; x += 1) {
				// temporarily set the state to this new possible state.
				A[i] = x;
				// if this state exists in the previous set, save this solution.
				if (states[t - 1][A.join("")] !== false) {
					modifications.push([i, x]);
				}
			}
			// reset the state back to 0
			A[i] = 0;
			// if we found modifications (even if we aren't using them), the
			// solution is no longer 0. solution is either 1 or modifications.
			if (modifications.length > 0 && solution === false) {
				solution = [];
			}
			// this round's modifications will be length of 2 if we added
			// both possible states (1, 2), if this happens, we can't infer anything.
			// only accept a modification when it's the only one (length is 1).
			if (modifications.length === 1) {
				solution.push(modifications[0]);
			}
		}
		// if we invalidated a 0 solution (solution impossible), and no modifications
		// were able to be added, solution is 1, meaning, currently valid (if unsolved).
		if (solution !== false && solution.length === 0) {
			solution = true;
		}
		states[t][key] = solution;
	};
	/**
	 * @description make a lookup table for every possible state of a taco/
	 * tortilla combination, given the particular taco/tortilla valid states.
	 * the value of each state is one of 3 values (2 numbers, 1 array):
	 * - 0: layer order is not valid
	 * - 1: layer order is currently valid. and is either solved (key contains
	 *   no zeros / unknowns), or it is not yet invalid and can still be solved.
	 * - (Array): two numbers, [index, value], modify the current layer by
	 *   changing the number at index to the value.
	 * @param {string[]} valid_states, one of the 3 set of valid states above
	 * @returns {object} keys are layer states, possible solution as values.
	 */
	// const flip = { 0:0, 1:2, 2:1 };
	const make_lookup = (valid_states) => {
		// the choose count can be inferred by the length of the valid states
		// (assuming they are all the same length)
		const choose_count = valid_states[0].length;
		// array of empty objects
		const states = Array
			.from(Array(choose_count + 1))
			.map(() => ({}));
		// all permutations of 1s and 2s (no zeros), length of choose_count.
		// examples for (6): 111112, 212221
		// set the value of these to "false" (solution is impossible)
		// with the valid cases to be overwritten in the next step.
		Array.from(Array(Math.pow(2, choose_count)))
			.map((_, i) => i.toString(2))
			.map(str => Array.from(str).map(n => parseInt(n, 10) + 1).join(""))
			.map(str => (`11111${str}`).slice(-choose_count))
			.forEach(key => { states[0][key] = false; });
		// set the valid cases to "true" (solution is possible)
		valid_states.forEach(s => { states[0][s] = true; });
		// "t" relates to the number of unknowns (# zeros). layer 0 is complete,
		// start at layer 1 and count up to choose_count.
		Array.from(Array(choose_count))
			.map((_, i) => i + 1)
			// make all permuations of 0s, 1s, and 2s now, length of choose_count.
			// (all possibile permuations of layer orders)
			.map(t => Array.from(Array(Math.pow(3, choose_count)))
				.map((_, i) => i.toString(3))
				.map(str => (`000000${str}`).slice(-choose_count))
				.forEach(key => check_state(states, t, key)));
		// todo: the filter at the beginning of check_state is throwing away
		// a lot of solutions, duplicating work, in the first array here, instead
		// of being smart about it, only doing one loop, and sorting them here
		// before entering check_state.
		// gather solutions together into one object. if a layer order has
		// multiple suggested modifications, grab the first one
		let outs = [];
		// array decrementing integers from [choose_count...0]
		Array.from(Array(choose_count + 1))
			.map((_, i) => choose_count - i)
			.forEach(t => {
				const A = [];
				// currently, each value is either a number (0 or 1), or
				// an array of multiple modifications, in which case, we only need one.
				Object.keys(states[t]).forEach(key => {
					let out = states[t][key];
					// multiple modifications are possible, get the first one.
					if (out.constructor === Array) { out = out[0]; }
					// if (out.constructor === Array) {
					//   const key_correct = Array.from(key);
					//   const key_flipped = Array.from(key);
					//   key_correct[out[0][0]] = out[0][1];
					//   key_flipped[out[0][0]] = flip[out[0][1]];
					//   out = {
					//     true: key_correct.join(""),
					//     false: key_flipped.join(""),
					//   };
					// }
					A.push([key, out]);
				});
				outs = outs.concat(A);
			});
		// this is unnecessary but because for Javascipt object keys,
		// insertion order is preserved, sort keys for cleaner output.
		outs.sort((a, b) => parseInt(a[0], 10) - parseInt(b[0], 10));
		// return data as an object.
		// recursively freeze result, this is intended to be an immutable reference
		const lookup = {};
		outs.forEach(el => { lookup[el[0]] = Object.freeze(el[1]); });
		return Object.freeze(lookup);
	};
	/**
	 * @name table
	 * @memberof layer
	 * @description This lookup table encodes all possible taco-taco,
	 * taco-tortilla, tortilla-tortilla, and transitivity constraints between
	 * groups of faces in a folded graph. Given an encoded state, as a key
	 * of this object, the value represents either:
	 * - {boolean} true: the layer order is so far valid
	 * - {boolean} false: the layer order is invalid
	 * - {number[]}: the layer order is valid, and, here is another
	 * relationship which can be inferred from the current state.
	 * This is an implementation of an algorithm designed by [Jason Ku](//jasonku.mit.edu).
	 */
	const layerTable = {
		taco_taco: make_lookup(taco_taco_valid_states),
		taco_tortilla: make_lookup(taco_tortilla_valid_states),
		tortilla_tortilla: make_lookup(tortilla_tortilla_valid_states),
		transitivity: make_lookup(transitivity_valid_states),
	};

	// const done_result = { 0: false, 1: true };
	// const make_number = (key, value) => {
	//   const arr = Array.from(key);
	//   arr[value[0]] = value[1];
	//   const base_three = arr.join("");
	//   return parseInt(base_three, 3);
	// };
	// const quick_lookup = {};
	// Object.keys(layerTable).forEach(type => {
	//   quick_lookup[type] = [];
	//   Object.keys(layerTable[type]).forEach(key => {
	//     const base_ten = parseInt(key, 3);
	//     const value = layerTable[type][key];
	//     const done = value === 0 || value === 1;
	//     const new_value = done ? done_result[value] : make_number(key, value);
	//     quick_lookup[type][base_ten] = new_value;
	//   });
	// });

	// export default quick_lookup;

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Convert an array of faces which are involved in one
	 * taco/tortilla/transitivity condition into an array of arrays where
	 * each face is paired with the others in the precise combination that
	 * the solver is expecting for this particular condition.
	 * @param {number[]} an array of the faces involved in this particular condition.
	 * @linkcode Origami ./src/layer/solver3d/general.js 10
	 */
	const constraintToFacePairs = ({
		// taco_taco (A,C) (B,D) (B,C) (A,D) (A,B) (C,D)
		taco_taco: f => [
			[f[0], f[2]],
			[f[1], f[3]],
			[f[1], f[2]],
			[f[0], f[3]],
			[f[0], f[1]],
			[f[2], f[3]],
		],
		// taco_tortilla (A,C) (A,B) (B,C)
		taco_tortilla: f => [[f[0], f[2]], [f[0], f[1]], [f[1], f[2]]],
		// tortilla_tortilla (A,C) (B,D)
		tortilla_tortilla: f => [[f[0], f[2]], [f[1], f[3]]],
		// transitivity (A,B) (B,C) (C,A)
		transitivity: f => [[f[0], f[1]], [f[1], f[2]], [f[2], f[0]]],
	});
	/**
	 * @description Given an array of a pair of integers, sort the smallest
	 * to be first, and format them into a space-separated string.
	 * @linkcode Origami ./src/layer/solver3d/general.js 32
	 */
	const pairArrayToSortedPairString = pair => (pair[0] < pair[1]
		? `${pair[0]} ${pair[1]}`
		: `${pair[1]} ${pair[0]}`);
	/**
	 * @description Convert an array of faces which are involved in one
	 * taco/tortilla/transitivity condition into an array of arrays where
	 * each face is paired with the others in the precise combination that
	 * the solver is expecting for this particular condition.
	 * @param {number[]} an array of the faces involved in this particular condition.
	 * @linkcode Origami ./src/layer/solver3d/general.js 43
	 */
	const constraintToFacePairsStrings = ({
		// taco_taco (A,C) (B,D) (B,C) (A,D) (A,B) (C,D)
		taco_taco: f => [
			pairArrayToSortedPairString([f[0], f[2]]),
			pairArrayToSortedPairString([f[1], f[3]]),
			pairArrayToSortedPairString([f[1], f[2]]),
			pairArrayToSortedPairString([f[0], f[3]]),
			pairArrayToSortedPairString([f[0], f[1]]),
			pairArrayToSortedPairString([f[2], f[3]]),
		],
		// taco_tortilla (A,C) (A,B) (B,C)
		taco_tortilla: f => [
			pairArrayToSortedPairString([f[0], f[2]]),
			pairArrayToSortedPairString([f[0], f[1]]),
			pairArrayToSortedPairString([f[1], f[2]]),
		],
		// tortilla_tortilla (A,C) (B,D)
		tortilla_tortilla: f => [
			pairArrayToSortedPairString([f[0], f[2]]),
			pairArrayToSortedPairString([f[1], f[3]]),
		],
		// transitivity (A,B) (B,C) (C,A)
		transitivity: f => [
			pairArrayToSortedPairString([f[0], f[1]]),
			pairArrayToSortedPairString([f[1], f[2]]),
			pairArrayToSortedPairString([f[2], f[0]]),
		],
	});

	const to_signed_layer_convert = { 0: 0, 1: 1, 2: -1 };
	/**
	 * face pairs: "# #" space separated integer indices. values: 1 or 2.
	 */
	const keysToFaceOrders = (facePairs, faces_aligned) => {
		const keys = Object.keys(facePairs);
		const faceOrders = keys.map(string => string
			.split(" ")
			.map(n => parseInt(n, 10)));
		faceOrders.forEach((faces, i) => {
			const value = to_signed_layer_convert[facePairs[keys[i]]];
			// equivalent to: side = (!faces_aligned[faces[1]]) ? -value : value
			const side = (((value === 1) ^ (faces_aligned[faces[1]])) * -2) + 1;
			faces.push(side);
		});
		return faceOrders;
	};
	/**
	 * @description traverse the solution tree, convert any orders
	 * from { string: number } where string is a face pair, like "3 29",
	 * and the number is one of either (1,2) into the FOLD spec facesOrder
	 * format, like [3, 29, -1].
	 * The string becomes .split(" ") and the (1,2) order becomes (1,-1).
	 * Modifies the solution parameter object in place.
	 * @param {object} solution the result of calling src/layer/solver/index.js
	 * @param {boolean[]} faces_winding for every face true or false,
	 * specifically, the property on the result of getOverlappingFacesGroups.
	 * @returns {object} the solution parameter, modified in place.
	 */
	const reformatSolution = (solution, faces_winding) => {
		if (solution.orders) {
			solution.orders = solution.orders
				.flatMap(order => keysToFaceOrders(order, faces_winding));
		}
		if (solution.leaves) {
			solution.leaves = solution.leaves
				.map(order => keysToFaceOrders(order, faces_winding));
		}
		if (solution.partitions) {
			solution.partitions
				.forEach(child => reformatSolution(child, faces_winding));
		}
		if (solution.node) {
			solution.node
				.forEach(child => reformatSolution(child, faces_winding));
		}
		return solution;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @typedef Constraint
	 * @type {number[]}
	 * @description an array of 3 or 4 faces involved in one taco/tortilla/transitivity constraint.
	 */
	/**
	 * @typedef Constraints
	 * @type {object}
	 * @description All Constraint entries for all of the taco/tortilla/transitivity cases.
	 * @property {Constraint[]} taco_taco an array of all taco-taco constraints.
	 * @property {Constraint[]} taco_tortilla an array of all taco-tortilla constraints.
	 * @property {Constraint[]} tortilla_tortilla an array of all tortilla-tortilla constraints.
	 * @property {Constraint[]} transitivity an array of all transitivity constraints.
	 */
	// "taco_taco", "taco_tortilla", "tortilla_tortilla", "transitivity"
	const taco_types = Object.freeze(Object.keys(layerTable));
	/**
	 * @description a layer orientation between two faces is encoded as:
	 * 0: unknown, 1: face A is above B, 2: face B is above A.
	 * this map will flip 1 and 2, leaving 0 to be 0.
	 */
	const flipFacePairOrder = { 0: 0, 1: 2, 2: 1 };
	/**
	 * @description Given one particular taco/tortilla/transitivity constraint,
	 * arrange its faces in all combinations of facePairs and check if any of
	 * these orders are known (1 or 2), arrange this into a string (eg. 010021),
	 * and use this string to reference the lookup table which will return one
	 * of three states: valid, invalid, or the change implied by this state.
	 * @param {string} type one of the four:
	 * "taco_taco", "taco_tortilla", "tortilla_tortilla", "transitivity"
	 * @param {number[]} constraint an array of the faces
	 * involved in this particular condition.
	 * @param {object[]} ...orders an array of solutions to facePair orders. each
	 * taking the form of facePair keys, and orders (0,1,2) values.
	 * @returns true if valid, false if invalid, and in the case of an implied
	 * change, return an array where the first item is a facePair ("3 5"), and
	 * the second is the order (like 1 or 2).
	 * @linkcode Origami ./src/layer/solver3d/propagate.js 44
	 */
	const buildRuleAndLookup = (type, constraint, ...orders) => {
		// regroup the N faces into an array of pairs, giving us the
		// facePair ("3 5") and booleans stating if the order was flipped.
		const facePairsArray = constraintToFacePairs[type](constraint);
		const flipped = facePairsArray.map(pair => pair[1] < pair[0]);
		const facePairs = facePairsArray.map((pair, i) => (flipped[i]
			? `${pair[1]} ${pair[0]}`
			: `${pair[0]} ${pair[1]}`));
		// consult all "orders" parameters for a solution (1 or 2, not 0) to
		// the facePair. for each facePair get the first solution found, and
		// in the case of no solution, that facePair will be 0 (unknown).
		// join this together into a string, (eg: "010021")
		const key = facePairs.map((facePair, i) => {
			for (let o = 0; o < orders.length; o += 1) {
				if (orders[o][facePair]) {
					return flipped[i]
						? flipFacePairOrder[orders[o][facePair]]
						: orders[o][facePair];
				}
			}
			return 0;
		}).join("");
		// now, consult the lookup table. if the result is a boolean,
		// return that boolean.
		if (layerTable[type][key] === true) { return true; }
		if (layerTable[type][key] === false) { return false; }
		// the table is giving us an implied state. return the implication's
		// facePair and order as an array. make sure to flip the order if necessary.
		const implication = layerTable[type][key];
		const implicationFacePair = facePairs[implication[0]];
		const implicationOrder = flipped[implication[0]]
			? flipFacePairOrder[implication[1]]
			: implication[1];
		return [implicationFacePair, implicationOrder];
	};

	// const getFacesWithUnknownOrdersArray = (...orders) => {
	// 	const unknownKeys = orders
	// 		.map(facePairsOrder => Object.keys(facePairsOrder)
	// 			.filter(key => facePairsOrder[key] !== 0))
	// 		.flat();
	// 	return uniqueElements(unknownKeys.map(key => key.split(" ")).flat());
	// };
	/**
	 * @description Given a current set of modified facePairs keys, (modified
	 * since the last time we ran this), get all condition indices that
	 * include one or more of these facePairs.
	 * @param {Constraints} constraints an object containing all four cases, inside
	 * of each is an (very large, typically) array of all constraints as a list of faces.
	 * @param {object} constraintsLookup a map which contains, for every
	 * taco/tortilla/transitivity case (top level keys), inside each is an object
	 * which relates each facePair (key) to an array of indices (value),
	 * where each index is an index in the "constraints" array
	 * in which **both** of these faces appear.
	 * @param {string[]} facePairsSubsetArray an array of facePair string keys.
	 * @linkcode Origami ./src/layer/solver3d/propagate.js 101
	 */
	const getConstraintIndicesFromFacePairs = (
		constraints,
		constraintsLookup,
		facePairsSubsetArray,
	) => {
		const constraintIndices = {};
		taco_types.forEach(type => {
			// given the array of modified facePairs since last round, get all
			// the indices in the constraints array in which these facePairs exist.
			// this array will contain duplicates
			const constraintIndicesWithDups = facePairsSubsetArray
				.flatMap(facePair => constraintsLookup[type][facePair]);
			// filter these constraint indices to remove duplicates
			constraintIndices[type] = uniqueElements(constraintIndicesWithDups)
				.filter(i => constraints[type][i]);
		});
		return constraintIndices;
	};
	/**
	 * @description Consult the lookup table for the current layer-orders,
	 * check for any implied layer order changes (and check for validity), propagate
	 * these implied states, check these updated conditions for new implications, repeat.
	 * @param {Constraints} constraints an object containing all four cases, inside
	 * of each is an (very large, typically) array of all constraints as a list of faces.
	 * @param {object} a map which contains, for every taco/tortilla/transitivity case
	 * (top level keys), inside each is an object which relates each facePair (key) to
	 * an array of indices (value), where each index is an index in the "constraints"
	 * array in which **both** of these faces appear.
	 * @param {string[]} initiallyModifiedFacePairs an array of facePair string keys.
	 * These are the keys which had a layer change since the last time running this method.
	 * @param {...object} ...orders any number of facePairsOrder solutions
	 * which relate facePairs (key) like "3 5" to an order, either 0, 1, or 2.
	 * @linkcode Origami ./src/layer/solver3d/propagate.js 135
	 */
	const propagate = (
		constraints,
		constraintsLookup,
		initiallyModifiedFacePairs,
		...orders
	) => {
		// "modifiedFacePairs" is an array of facePair strings, as we make updates and
		// apply changes and repeat, this will hold all changed facePair keys.
		// the moment this array is empty, we have finished propagating all changes.
		let modifiedFacePairs = initiallyModifiedFacePairs;
		// this is the result which will be returned, it maps facePairs (keys)
		// to layer orders, either 1 or 2 (values) and contains only those facePairs
		// which were changed by this method, so it will never contain a 0 value condition.
		const newOrders = {};
		do {
			// using the facePairs which were modified in the last loop,
			// get all constraint indices which involve any of the individual faces
			// from any of these facePairs.
			const modifiedConstraintIndices = getConstraintIndicesFromFacePairs(
				constraints,
				constraintsLookup,
				modifiedFacePairs,
			);
			// todo: do you get better results by fast forwarding through all taco-taco
			// newOrders (or transitivity, or any one in particular), before then
			// moving onto the other sets, or is it faster to depth-first search through all?
			// the modifications that happened this round
			const roundModificationsFacePairs = {};
			for (let t = 0; t < taco_types.length; t += 1) {
				const type = taco_types[t];
				const indices = modifiedConstraintIndices[type];
				for (let i = 0; i < indices.length; i += 1) {
					const lookupResult = buildRuleAndLookup(
						type,
						constraints[type][indices[i]],
						...orders,
						newOrders,
					);
					if (lookupResult === true) { continue; }
					if (lookupResult === false) {
						// consider throwing an error, we can convey descriptive information
						// about which faces are causing a problem
						console.warn("invalid state found", type, constraints[type][indices[i]]);
						return false;
					}
					if (newOrders[lookupResult[0]]) {
						// rule already exists. make sure the results match
						if (newOrders[lookupResult[0]] !== lookupResult[1]) {
							console.warn("order conflict", type, constraints[type][indices[i]]);
							return false;
						}
					} else {
						const [key, value] = lookupResult;
						roundModificationsFacePairs[key] = true;
						newOrders[lookupResult[0]] = value;
					}
				}
			}
			modifiedFacePairs = Object.keys(roundModificationsFacePairs);
			// console.log("modifiedConstraintIndices", modifiedConstraintIndices);
			// console.log("roundModificationsFacePairs", roundModificationsFacePairs);
			// console.log("newOrders", newOrders);
			// console.log("modifiedFacePairs", modifiedFacePairs.length, modifiedFacePairs);
		} while (modifiedFacePairs.length);
		return newOrders;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given a facePairKey (like "3 39") check the constraints
	 * lookup for all taco/tortilla events which this key is involved in.
	 * Given this list, we can get all the other faces which are involved
	 * in each of these conditions also. Given this second list, make all
	 * possible combinations of face pairs (like "3 XX" and "39 XX") with
	 * all other faces involved in every taco/tortilla event.
	 * Note, this can include face pairs which aren't even being considered
	 * in the greater calculation (already computed, for example), but these
	 * will be filtered out inside getDisjointSets().
	 */
	const getNeighborsArray = (key, constraints, constraintsLookup) => {
		// collect all neighbors into one hash to remove duplicates.
		const neighborsHash = {};
		// visit each taco/tortilla/transitivity type, and inside each type,
		// visit all constraints, store the constraints in the neighborsHash.
		Object.keys(constraints).forEach(type => {
			// skip if constraintsLookup for a type/key doesn't exist.
			const indices = constraintsLookup[type][key];
			if (!indices) { return; }
			// for each constraint index, convert it into its 3 or 4 face indices,
			// then convert these into all permutations of face-pair strings.
			indices
				.map(c => constraints[type][c])
				.map(faces => constraintToFacePairsStrings[type](faces)
					// add each facePair to the neighborsHash.
					.forEach(facePair => { neighborsHash[facePair] = true; }));
		});
		return Object.keys(neighborsHash);
	};
	/**
	 * @param {string[]} remainingKeys array of facePair keys which are unsolved
	 * @param {any} constraints
	 * @param {any} constraintsLookup
	 * @param {object} constraintsNeighborsMemo given a face-pair (key),
	 * the value is an array of all other face-pairs which are
	 * included in some condition (taco/tortilla/trans)
	 * in which the face-pair key also appears.
	 * @linkcode Origami ./src/layer/solver3d/getDisjointSets.js 45
	 */
	const getDisjointSets = (
		remainingKeys,
		constraints,
		constraintsLookup,
		// tortillaSets,
		// tortillaSetsLookup,
		constraintsNeighborsMemo = {},
	) => {
		// const prevLen = constraints.tortilla_tortilla.length;
		// const tortillaSets = constraints.tortilla_tortilla
		// 	.flatMap(t => [
		// 		[t[2], t[0], t[1], t[3]],
		// 		[t[0], t[2], t[3], t[1]],
		// 		[t[2], t[0], t[3], t[1]],
		// 	]);
		// 	// .flatMap(t => [
		// 	// 	[t[1], t[0], t[2], t[3]],
		// 	// 	[t[0], t[1], t[3], t[2]],
		// 	// 	[t[1], t[0], t[3], t[2]],
		// 	// ]);
		// const tortillaSetsLookup = {};
		// tortillaSets.forEach((t, i) => {
		// 	tortillaSetsLookup[[t[0], t[2]].sort((a, b) => a - b).join(" ")] = [prevLen + i];
		// 	tortillaSetsLookup[[t[1], t[3]].sort((a, b) => a - b).join(" ")] = [prevLen + i];
		// 	// tortillaSetsLookup[[t[0], t[1]].sort((a, b) => a - b).join(" ")] = [prevLen + i];
		// 	// tortillaSetsLookup[[t[2], t[3]].sort((a, b) => a - b).join(" ")] = [prevLen + i];
		// });
		// const constraintsAll = { ...constraints };
		// const constraintsLookupAll = { ...constraintsLookup };
		// constraintsAll.tortilla_tortilla = JSON
		// 	.parse(JSON.stringify(constraintsAll.tortilla_tortilla));
		// constraintsLookupAll.tortilla_tortilla = JSON
		// 	.parse(JSON.stringify(constraintsLookupAll.tortilla_tortilla));
		// constraintsAll.tortilla_tortilla.push(...tortillaSets);
		// constraintsLookupAll.tortilla_tortilla = {
		// 	...constraintsLookup.tortilla_tortilla,
		// 	...tortillaSetsLookup,
		// };
		// console.log("constraintsAll", constraintsAll);
		// console.log("constraintsLookupAll", constraintsLookupAll);
		// const constraintsAll = { ...constraints };
		// const constraintsLookupAll = { ...constraintsLookup };

		// move remainingKeys into a dictionary.
		// we will delete keys from this dictionary as we visit them
		const keys = {};
		remainingKeys.forEach(key => { keys[key] = true; });
		// iterate through all remainingKeys
		let i = 0;
		// the number of groups will grow as needed
		// groupIndex is always groups.length - 1
		const groups = [];
		while (i < remainingKeys.length) {
			// begin iterating through all keys in the remaining keys
			// if the key already been visited, move onto the next.
			if (!keys[remainingKeys[i]]) { i += 1; continue; }
			// this marks the beginning of a new group.
			const group = [];
			// create a new stack (and stackHash containing duplicate data)
			// beginning with the first unvisited key
			const stack = [remainingKeys[i]];
			const stackHash = { [remainingKeys[i]]: true };
			do {
				// pop a key off of the stack
				const key = stack.shift();
				// mark the key as "visited" by removing it from "keys"
				delete keys[key];
				// add this key to the current group
				group.push(key);
				// we are about to loop through all of this key's neighbors
				// if they already exist, use the data from the memo
				const neighborsArray = constraintsNeighborsMemo[key]
					? constraintsNeighborsMemo[key]
					: getNeighborsArray(key, constraints, constraintsLookup);
					// : getNeighborsArray(key, constraintsAll, constraintsLookupAll);
				// in case there is new data, save it in the memo
				constraintsNeighborsMemo[key] = neighborsArray;
				// console.log("neighborsArray", neighborsArray);
				// get all neighbors from the hash, filtering out facePairs
				// which were already visited any time in this method ("keys"),
				// and already visited and included inside this stack ("stackHash")
				const neighbors = neighborsArray
					.filter(facePair => keys[facePair] && !stackHash[facePair]);
				// console.log("branch search", key, "connected to", neighborsArray);
				// add these facePairs to the stack (and hash) to be visited next loop.
				stack.push(...neighbors);
				neighbors.forEach(facePair => { stackHash[facePair] = true; });
			} while (stack.length);
			i += 1;
			groups.push(group);
		}
		return groups;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// import { makeEdgesEdgesCrossing } from "../../graph/intersect/edgesEdges.js";
	// import { getEdgesEdgesIntersection } from "../../graph/intersect/edgesEdges.js";
	// import { booleanMatrixToIndexedArray } from "../../general/arrays.js";
	/**
	 * @description makeTortillaTortillaEdgesCrossing
	 * @param {FOLD} graph a FOLD object graph
	 * @param {todo} todo todo
	 * @param {number} [epsilon=1e-6] optional epsilon value
	 * @returns todo
	 * @linkcode Origami ./src/layer/solver3d/tortillaTortilla.js 20
	 */
	// export const makeTortillaTortillaEdgesCrossing = (graph, edges_faces_side, epsilon) => {
	// 	// get all tortilla edges. could also be done by searching
	// 	// "edges_assignment" for all instances of F/f. perhaps this way is better.
	// 	const tortilla_edge_indices = edges_faces_side
	// 		.map(side => side.length === 2 && side[0] !== side[1])
	// 		.map((bool, i) => (bool ? i : undefined))
	// 		.filter(a => a !== undefined);
	// 	// get all edges which cross these tortilla edges. these edges can even be
	// 	// boundary edges, it doesn't matter how many adjacent faces they have.
	// 	const edges_crossing_matrix = makeEdgesEdgesCrossing(graph, epsilon);
	// 	const edges_crossing = booleanMatrixToIndexedArray(edges_crossing_matrix);
	// 	console.log("3d edges_crossing", edges_crossing);
	// 	// parallel arrays. tortilla_edge_indices contains the edge index.
	// 	// tortilla_edges_crossing contains an array of the crossing edge indices.
	// 	const tortilla_edges_crossing = tortilla_edge_indices
	// 		.map(i => edges_crossing[i]);
	// 	// combine parallel arrays into one object.
	// 	// tortilla_edge is a number. crossing_edges is an array of numbers.
	// 	return tortilla_edges_crossing.map((edges, i) => ({
	// 		tortilla_edge: tortilla_edge_indices[i],
	// 		crossing_edges: edges,
	// 	})).filter(el => el.crossing_edges.length);
	// };
	/**
	 *
	 */
	const makeTortillasFacesCrossing = (graph, edges_faces_side, epsilon) => {
		const faces_winding = makeFacesWinding(graph);
		const faces_polygon = makeFacesPolygon(graph, epsilon);
		faces_winding.forEach((winding, i) => {
			if (!winding) {
				faces_polygon[i].reverse();
			}
		});
		const tortilla_edge_indices = edges_faces_side
			.map(side => side.length === 2 && side[0] !== side[1])
			.map((bool, i) => (bool ? i : undefined))
			.filter(a => a !== undefined);
		const edges_coords = tortilla_edge_indices
			.map(e => graph.edges_vertices[e])
			.map(edge => edge
				.map(vertex => graph.vertices_coords[vertex]));
		const edges_vector = edges_coords
			.map(coords => subtract2(coords[1], coords[0]));
		const matrix = [];
		tortilla_edge_indices.forEach(e => { matrix[e] = []; });
		// console.log("clip", tortilla_edge_indices
		//	 .map((e, ei) => faces_polygon
		//	 	.map((poly, f) => clipLineConvexPolygon(
		//	 		poly,
		//	 		edges_vector[ei],
		//	 		edges_coords[ei][0],
		//	 		exclude,
		//	 		excludeS,
		//	 		epsilon))));
		const result = tortilla_edge_indices
			.map((e, ei) => faces_polygon
				.map(poly => clipLineConvexPolygon(
					poly,
					{ vector: edges_vector[ei], origin: edges_coords[ei][0] },
					exclude,
					excludeS,
					epsilon,
				))
				.map(res => res !== undefined));
		// const result = tortilla_edge_indices
		// 	.map((e, ei) => faces_polygon
		// 		.map((poly, f) => intersectConvexPolygonLine(
		// 			poly,
		// 			{ vector: edges_vector[ei], origin: edges_coords[ei][0] },
		// 			excludeS,
		// 			includeL ))
		// 			// epsilon))
		// 		.map((result, f) => result !== undefined));
		result.forEach((faces, ei) => faces
			.forEach((overlap, f) => {
				if (overlap) {
					matrix[tortilla_edge_indices[ei]].push(f);
				}
			}));
		// console.log("faces_polygon", faces_polygon);
		// console.log("tortilla_edge_indices", tortilla_edge_indices);
		// console.log("edges_coords", edges_coords);
		// console.log("edges_vector", edges_vector);
		// console.log("result", result);
		// console.log("matrix", matrix);
		return matrix;
	};
	/**
	 *
	 */
	const makeTortillaTortillaFacesCrossing = (graph, edges_faces_side, epsilon) => {
		// const tortilla_tortilla_edges = makeTortillaTortillaEdgesCrossing(
		// 	graph,
		// 	edges_faces_side,
		// 	epsilon,
		// );
		// console.log("tortilla_tortilla_edges", tortilla_tortilla_edges);
		const tortillas_faces_crossing = makeTortillasFacesCrossing(graph, edges_faces_side, epsilon);
		const tortilla_faces_results = tortillas_faces_crossing
			.map((faces, e) => faces.map(face => [graph.edges_faces[e], [face, face]]))
			.reduce((a, b) => a.concat(b), []);
		// const tortilla_tortilla_results = tortilla_tortilla_edges
		// 	.map(el => ({
		// 		tortilla_faces: graph.edges_faces[el.tortilla_edge],
		// 		crossing_faces: el.crossing_edges.map(edge => graph.edges_faces[edge]),
		// 	}))
		// 	.map(el => el.crossing_faces
		// 		// note, adjacent_faces could be singular in the case of a boundary edge,
		// 		// and this is still valid.
		// 		.map(adjacent_faces => adjacent_faces
		// 			.map(face => [el.tortilla_faces, [face, face]]))
		// 		.reduce((a, b) => a.concat(b), []))
		// 	.reduce((a, b) => a.concat(b), []);
		// console.log("tortillas_faces_crossing", tortillas_faces_crossing);
		// console.log("tortilla_tortilla_results", tortilla_tortilla_results);
		// console.log("tortilla_faces_results", tortilla_faces_results);
		// return tortilla_tortilla_results;
		return tortilla_faces_results;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const makeEdgesFacesSide = (graph) => {
		const edges_origin = graph.edges_vertices
			.map(vertices => graph.vertices_coords[vertices[0]]);
		const edges_vector = graph.edges_vertices
			.map(vertices => subtract2(
				graph.vertices_coords[vertices[1]],
				graph.vertices_coords[vertices[0]],
			));
		return graph.edges_faces
			.map((faces, i) => faces
				.map(face => cross2(
					subtract2(
						graph.faces_center[face],
						edges_origin[i],
					),
					edges_vector[i],
				))
				.map(cross => Math.sign(cross)));
	};
	/**
	 * @description having already pre-computed a the tacos in the form of
	 * edges and the edges' adjacent faces, give each face a +1 or -1 based
	 * on which side of the edge it is on. "side" determined by the cross-
	 * product against the edge's vector.
	 * @linkcode Origami ./src/layer/solver3d/facesSide.js 33
	 */
	const makeTacosFacesSide = (graph, tacos_edges, tacos_faces) => {
		// there are two edges involved in a taco, grab the first one.
		// we have to use the same origin/vector so that the face-sidedness is
		// consistent globally, not local to its edge.
		const tacos_edge_coords = tacos_edges
			.map(edges => graph.edges_vertices[edges[0]]
				.map(vertex => graph.vertices_coords[vertex]));
		const tacos_edge_origin = tacos_edge_coords
			.map(coords => coords[0]);
		const tacos_edge_vector = tacos_edge_coords
			.map(coords => subtract2(coords[1], coords[0]));

		const tacos_faces_center = tacos_faces
			.map(faces => faces
				.map(face_pair => face_pair
					.map(face => graph.faces_center[face])));

		return tacos_faces_center
			.map((faces, i) => faces
				.map(pairs => pairs
					.map(center => cross2(
						subtract2(
							center,
							tacos_edge_origin[i],
						),
						tacos_edge_vector[i],
					))
					.map(cross => Math.sign(cross))));
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description classify a pair of adjacent faces encoded as +1 or -1
	 * depending on which side they are on into one of 3 types:
	 * - "both": tortilla (faces lie on both sides of the edge)
	 * - "left": a taco facing left
	 * - "right": a taco facing right
	 */
	const classify_faces_pair = (pair) => {
		if ((pair[0] === 1 && pair[1] === -1)
			|| (pair[0] === -1 && pair[1] === 1)) {
			return "both";
		}
		if ((pair[0] === 1 && pair[1] === 1)) { return "right"; }
		if ((pair[0] === -1 && pair[1] === -1)) { return "left"; }
		return undefined;
	};

	// pairs of tacos are valid taco-taco if they are both "left" or "right".
	const is_taco_taco = (classes) => classes[0] === classes[1]
		&& classes[0] !== "both";

	// pairs of tortillas are valid tortillas if both of them are "both".
	const is_tortilla_tortilla = (classes) => classes[0] === classes[1]
		&& classes[0] === "both";

	// pairs of face-pairs are valid taco-tortillas if one is "both" (tortilla)
	// and the other is either a "left" or "right" taco.
	const is_taco_tortilla = (classes) => classes[0] !== classes[1]
		&& (classes[0] === "both" || classes[1] === "both");
	/**
	 * @description this kind of taco-tortilla is edge-aligned with a tortilla
	 * that is made of two faces. there are 4 faces involved, we only need 3.
	 * given the direction of the taco ("left" or "right"), get the similarly-
	 * facing side of the tortilla and return this along with the taco.
	 */
	const make_taco_tortilla = (face_pairs, types, faces_side) => {
		const direction = types[0] === "left" || types[1] === "left" ? -1 : 1;
		// deep copy these objects. ensures that no arrays share pointers.
		const taco = types[0] === "both" ? [...face_pairs[1]] : [...face_pairs[0]];
		// get only one side of the tortilla
		const index = types[0] === "both" ? 0 : 1;
		const tortilla = faces_side[index][0] === direction
			? face_pairs[index][0]
			: face_pairs[index][1];
		return { taco, tortilla };
	};
	const make_tortilla_tortilla = (face_pairs, tortillas_sides) => {
		if (face_pairs === undefined) { return undefined; }
		return (tortillas_sides[0][0] === tortillas_sides[1][0])
			? face_pairs
			: [face_pairs[0], [face_pairs[1][1], face_pairs[1][0]]];
	};
	/**
	 *
	 */
	const makeCopyWithFlatEdges = (graph) => {
		const copy = { ...graph };
		// flat edges indices in a hash table
		const lookup = {};
		// these are the indices of all flat edges (edges to keep)
		copy.edges_foldAngle
			.map(edgeFoldAngleIsFlat)
			.map((flat, i) => (flat ? i : undefined))
			.filter(a => a !== undefined)
			.forEach(e => { lookup[e] = true; });
		filterKeysWithPrefix(graph, "edges").forEach(key => {
			copy[key] = [];
			graph[key].forEach((el, e) => {
				if (lookup[e]) {
					copy[key][e] = JSON.parse(JSON.stringify(el));
				}
			});
		});
		return copy;
	};
	/**
	 * @description Given a FOLD object, find all instances of edges
	 * overlapping which classify as taco/tortillas to determine layer order.
	 * @param {FOLD} graph a FOLD graph. vertices_coords should already be
	 * folded and faces_center should be pre-calculated.
	 * @param {number} [epsilon=1e-6] an optional epsilon, default 1e-6
	 * @returns {object} an object containing keys:
	 * taco_taco, tortilla_tortilla, taco_tortilla
	 * @linkcode Origami ./src/layer/solver3d/makeTacosTortillas.js 105
	 * @notes due to the face_center calculation to determine face-edge
	 * sidedness, this is currently hardcoded to only work with convex polygons.
	 */
	const makeTacosTortillas = (graphInput, epsilon = EPSILON) => {
		// console.log("BEFORE", graphInput);
		const graph = makeCopyWithFlatEdges(graphInput);
		// console.log("AFTER", graph);

		// const nonFlatEdges = graph.edges_foldAngle
		// 	.map(edgeFoldAngleIsFlat)
		// 	.map((flat, i) => (flat ? undefined : i))
		// 	.filter(a => a !== undefined);
		// console.log("nonFlatEdges", nonFlatEdges);
		// given a graph which is already in its folded state,
		// find which edges are tacos, or in other words, find out which
		// edges overlap with another edge.
		const edges_faces_side = makeEdgesFacesSide(graph);
		// nonFlatEdges.forEach(e => delete edges_faces_side[e]);
		// const eep = makeEdgesEdgesParallel(graph);
		// console.log("eep", eep);
		// const edges_edges_parallel = makeEdgesEdges2DParallel(graph);
		// console.log("edges_edges_parallel", edges_edges_parallel);
		// for every edge, find all other edges which are parallel to this edge and
		// overlap the edge, excluding the epsilon space around the endpoints.
		// 130ms:
		const edges_edgesParallelOverlap = makeEdgesEdgesParallelOverlap(graph, epsilon);
		// convert this matrix into unique pairs ([4, 9] but not [9, 4])
		// thse pairs are also sorted such that the smaller index is first.
		const tacos_edges = selfRelationalUniqueIndexPairs(edges_edgesParallelOverlap)
		// const tacos_edges = booleanMatrixToUniqueIndexPairs(edge_edge_overlap_matrix)
			.filter(pair => pair
				.map(edge => graph.edges_faces[edge].length > 1)
				.reduce((a, b) => a && b, true));
		const tacos_faces = tacos_edges
			.map(pair => pair
				.map(edge => graph.edges_faces[edge]));
		// convert every face into a +1 or -1 based on which side of the edge is it on.
		// ie: tacos will have similar numbers, tortillas will have one of either.
		// the +1/-1 is determined by the cross product to the vector of the edge.
		const tacos_faces_side = makeTacosFacesSide(graph, tacos_edges, tacos_faces);
		// each pair of faces is either a "left" or "right" (taco) or "both" (tortilla).
		const tacos_types = tacos_faces_side
			.map(faces => faces
				.map(classify_faces_pair));
		// this completes taco-taco, however both tortilla-tortilla and taco-tortilla
		// has two varieties.
		// tortilla-tortilla has both (1) edge-aligned tortillas where 4 unique faces
		// are involved, and (2) the case where an edge crosses one tortilla, where
		// only 3 faces are involved.
		// taco-tortilla: (1) those tacos which are edge-aligned with another
		// tortilla-tortilla, and (2) those tacos which simply cross through the
		// middle of a face. this completes taco-tortilla (1).
		const taco_taco = tacos_types
			.map((pair, i) => (is_taco_taco(pair) ? tacos_faces[i] : undefined))
			.filter(a => a !== undefined);
		// tortilla-tortilla contains one additional required ordering:
		// [a,b], [c,d] means a and b are connected, and c and d are connected,
		// additionally, a is above/below c and b is above/below d.
		// get the first of the two tacos_edges, use this as the origin/vector.
		// recompute the face-sidedness using these. see: make_tortilla_tortilla.
		const tortilla_tortilla_aligned = tacos_types
			.map((pair, i) => (is_tortilla_tortilla(pair) ? tacos_faces[i] : undefined))
			.map((pair, i) => make_tortilla_tortilla(pair, tacos_faces_side[i]))
			.filter(a => a !== undefined);
		// 5ms:
		// todo: faces_winding is used here. we need to pass in the new version.
		//
		const tortilla_tortilla_crossing = makeTortillaTortillaFacesCrossing(
			graph,
			edges_faces_side,
			epsilon,
		);
		const tortilla_tortilla = tortilla_tortilla_aligned
			.concat(tortilla_tortilla_crossing);
		// taco-tortilla (1), first case. taco overlaps tortilla.
		const taco_tortilla_aligned = tacos_types
			.map((pair, i) => (is_taco_tortilla(pair)
				? make_taco_tortilla(tacos_faces[i], tacos_types[i], tacos_faces_side[i])
				: undefined))
			.filter(a => a !== undefined);
		// taco-tortilla (2), the second of two cases, when a taco overlaps a face.
		// 750ms:
		const edges_faces_overlap = getEdgesFacesOverlap(graph, epsilon);
		// 10ms:
		const edges_overlap_faces = booleanMatrixToIndexedArray(edges_faces_overlap)
			.map((faces, e) => (edges_faces_side[e].length > 1
				&& edges_faces_side[e][0] === edges_faces_side[e][1]
				? faces
				: []));
		const taco_tortillas_crossing = edges_overlap_faces
			.map((tortillas, edge) => ({ taco: graph.edges_faces[edge], tortillas }))
			.filter(el => el.tortillas.length);
		const taco_tortilla_crossing = taco_tortillas_crossing
			.flatMap(el => el.tortillas
				.map(tortilla => ({ taco: [...el.taco], tortilla })));
		// finally, join both taco-tortilla cases together into one.
		const taco_tortilla = taco_tortilla_aligned.concat(taco_tortilla_crossing);
		// console.log("edges_faces_side", edges_faces_side);
		// console.log("edges_edgesParallelOverlap", edges_edgesParallelOverlap);
		// console.log("tacos_faces", tacos_faces);
		// console.log("tacos_edges", tacos_edges);
		// console.log("tortilla_tortilla_aligned", tortilla_tortilla_aligned);
		// console.log("tortilla_tortilla_crossing", tortilla_tortilla_crossing);
		return {
			taco_taco,
			tortilla_tortilla,
			taco_tortilla,
		};
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a folded graph, find all trios of faces which overlap
	 * each other, meaning there exists at least one point that lies at the
	 * intersection of all three faces.
	 * @param {FOLD} graph a FOLD graph
	 * @param {boolean[][]} faces_facesOverlap an overlap-relationship between every face
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {number[][]} list of arrays containing three face indices.
	 * @linkcode Origami ./src/layer/solver3d/makeTransitivityTrios.js 15
	 */
	const makeTransitivityTrios = (
		graph,
		faces_facesOverlap,
		epsilon = EPSILON,
	) => {
		// prepare a list of all faces in the graph as lists of vertices
		// also, make sure they all have the same winding (reverse if necessary)
		// todo: i replaced this with makeFacesPolygon so that it runs
		// math.makePolygonNonCollinear, which removes collinear vertices
		// which is necessary for the polygon polygon clip method.
		const polygons = makeFacesPolygon(graph, epsilon);
		// const polygons = graph.faces_vertices
		// 	.map(face => face
		// 		.map(v => graph.vertices_coords[v]));
		// todo: why did i write this one? i just uncommented the block below.
		// makeFacesWinding(graph).forEach((winding, i) => {
		// 	if (!winding) { polygons[i].reverse(); }
		// });
		// this is now happening in the prepare() method before this is called
		// polygons.forEach((face, i) => {
		// 	if (!faces_winding[i]) { face.reverse(); }
		// });
		const matrix = graph.faces_vertices.map(() => []);
		polygons.forEach((_, f1) => faces_facesOverlap[f1].forEach(f2 => {
			if (f2 <= f1) { return; }
			const polygon = clipPolygonPolygon(polygons[f1], polygons[f2], epsilon);
			if (polygon) { matrix[f1][f2] = polygon; }
		}));
		const trios = [];
		matrix.forEach((row, i) => row.forEach((poly, j) => {
			if (j <= i || !matrix[i][j]) { return; }
			matrix.forEach((_, k) => {
				if (k <= i || k <= j) { return; }
				// todo: bring this back. but this would require we convert
				// faces_facesOverlap into a quick lookup table.
				// if (!faces_facesOverlap[i][k] || !faces_facesOverlap[j][k]) { return; }
				const polygon = clipPolygonPolygon(poly, polygons[k], epsilon);
				if (polygon) { trios.push([i, j, k].sort((a, b) => a - b)); }
			});
		}));
		return trios;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description given a full set of transitivity conditions (trios of faces which
	 * overlap each other), and the set of pre-computed taco-taco and
	 * taco-tortilla events, remove any transitivity condition where the three
	 * faces are already covered in a taco-taco case.
	 * @linkcode Origami ./src/layer/solver3d/filterTransitivity.js 9
	 */
	const filterTransitivity = (transitivity_trios, tacos_tortillas) => {
		// will contain taco-taco and taco-tortilla events encoded as all
		// permutations of 3 faces involved in each event.
		const tacos_trios = {};
		// using the list of all taco-taco conditions, store all permutations of
		// the three faces (sorted low to high) into a dictionary for quick lookup.
		// store them as space-separated strings.
		tacos_tortillas.taco_taco
			.map(tacos => [tacos[0][0], tacos[0][1], tacos[1][0], tacos[1][1]]
				.sort((a, b) => a - b))
			.forEach(taco => [
				`${taco[0]} ${taco[1]} ${taco[2]}`,
				`${taco[0]} ${taco[1]} ${taco[3]}`,
				`${taco[0]} ${taco[2]} ${taco[3]}`,
				`${taco[1]} ${taco[2]} ${taco[3]}`,
			].forEach(key => { tacos_trios[key] = true; }));
		// convert all taco-tortilla cases into similarly-formatted,
		// space-separated strings.
		tacos_tortillas.taco_tortilla
			.map(el => [el.taco[0], el.taco[1], el.tortilla]
				.sort((a, b) => a - b).join(" "))
			.forEach(key => { tacos_trios[key] = true; });
		// return the filtered set of trios.
		return transitivity_trios
			.filter(trio => tacos_trios[trio.join(" ")] === undefined);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Each taco/tortilla event involves the relationship between
	 * 3 or 4 faces. The lookup table encodes the relationship between all
	 * permutations of pairs of these faces in a particular order.
	 * 6: taco-taco, 3: taco-tortilla, 2: tortilla-tortilla, 3: transitivity.
	 * @linkcode Origami ./src/layer/solver3d/makeConstraints.js 12
	 */
	const makeConstraints = (tacos_tortillas, transitivity_trios) => {
		const constraints = {};
		// A-C and B-D are connected. A:[0][0] C:[0][1] B:[1][0] D:[1][1]
		// "(A,C) (B,D) (B,C) (A,D) (A,B) (C,D)"
		constraints.taco_taco = tacos_tortillas.taco_taco.map(el => [
			el[0][0], el[1][0], el[0][1], el[1][1],
		]);
		// A-C is the taco, B is the tortilla. A:taco[0] C:taco[1] B:tortilla
		// (A,C) (A,B) (B,C)
		constraints.taco_tortilla = tacos_tortillas.taco_tortilla.map(el => [
			el.taco[0], el.tortilla, el.taco[1],
		]);
		// A-B and C-D are connected, where A is above/below C and B is above/below D
		// A:[0][0] B:[0][1] C:[1][0] D:[1][1]
		// (A,C) (B,D)
		constraints.tortilla_tortilla = tacos_tortillas.tortilla_tortilla.map(el => [
			el[0][0], el[0][1], el[1][0], el[1][1],
		]);
		// transitivity. no relation between faces in the graph.
		// (A,B) (B,C) (C,A)
		constraints.transitivity = transitivity_trios.map(el => [
			el[0], el[1], el[2],
		]);
		return constraints;
	};

	const makeConstraintsLookup = (constraints) => {
		const lookup = {};
		Object.keys(constraints).forEach(key => { lookup[key] = {}; });
		Object.keys(constraints).forEach(type => {
			constraints[type]
				.forEach((constraint, i) => constraintToFacePairsStrings[type](constraint)
					.forEach(key => {
						if (lookup[type][key] === undefined) {
							lookup[type][key] = [];
						}
						lookup[type][key].push(i);
					}));
		});
		return lookup;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// flip 1 and 2 to be the other, leaving 0 to be 0.
	const make_conditions_flip_condition = { 0: 0, 1: 2, 2: 1 };
	// neighbor faces determined by crease between them
	const make_conditions_assignment_direction = {
		M: 1, m: 1, V: 2, v: 2,
	};
	/**
	 * @description Given a FOLD graph, already folded, find the layer arrangement
	 * between neighboring faces (using edges_faces), and assign this facePair
	 * a 1 or 2, checking whether faces have been flipped or not.
	 * @param {FOLD} graph a FOLD graph
	 * @param {string[]} facePairs an array of space-separated face-pair strings
	 * @returns {object} an object describing all the solved facePairs (keys) and
	 * their layer order 1 or 2 (value), the object only includes those facePairs
	 * which are solved, so, no 0-value entries will exist.
	 * @linkcode Origami ./src/layer/solver3d/solveEdgeAdjacent.js 19
	 */
	const solveEdgeAdjacentFacePairs = (graph, facePairs, faces_winding) => {
		const facePairsHash = {};
		facePairs.forEach(key => { facePairsHash[key] = true; });
		const solution = {};
		graph.edges_faces.forEach((faces, edge) => {
			// the crease assignment determines the order between pairs of faces.
			const assignment = graph.edges_assignment[edge];
			const local_order = make_conditions_assignment_direction[assignment];
			// skip boundary edges or edges with confusing assignments.
			if (faces.length < 2 || local_order === undefined) { return; }
			// face[0] is the origin face.
			// the direction of "m" or "v" will be inverted if face[0] is flipped.
			const upright = faces_winding[faces[0]];
			// now we know from a global perspective the order between the face pair.
			const global_order = upright
				? local_order
				: make_conditions_flip_condition[local_order];
			const key1 = `${faces[0]} ${faces[1]}`;
			const key2 = `${faces[1]} ${faces[0]}`;
			// console.log("adj edge", assignment, upright, local_order, global_order, solution);
			if (key1 in facePairsHash) { solution[key1] = global_order; }
			if (key2 in facePairsHash) {
				solution[key2] = make_conditions_flip_condition[global_order];
			}
		});
		return solution;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description a range is an array of two numbers [start, end]
	 * not necessarily in sorted order.
	 * Do the two spans overlap on the numberline?
	 */
	const rangesOverlapExclusive = (a, b, epsilon = 1e-6) => {
		// make sure ranges are well formed (sorted low to high)
		const r1 = a[0] < a[1] ? a : [a[1], a[0]];
		const r2 = b[0] < b[1] ? b : [b[1], b[0]];
		const overlap = Math.min(r1[1], r2[1]) - Math.max(r1[0], r2[0]);
		return overlap > epsilon;
	};

	const doEdgesOverlap = (graph, edgePair, vector, epsilon = 1e-6) => {
		// console.log("doEdgesOverlap", graph, edgePair, vector, epsilon);
		const pairCoords = edgePair
			.map(edge => graph.edges_vertices[edge]
				.map(v => graph.vertices_coords[v]));
		const pairCoordsDots = pairCoords
			.map(edge => edge
				.map(coord => dot(coord, vector)));
		const result = rangesOverlapExclusive(...pairCoordsDots, epsilon);
		// console.log("pairCoords", pairCoords);
		// console.log("pairCoordsDots", pairCoordsDots);
		// console.log("result", result);
		return result;
	};

	// this will only work with graphs which are manifolds, edges must
	// have only one or two adjacent faces (so, be a member of only
	// one or two coplanar groups), not three or more.
	/**
	 *
	 */
	const make3DTortillaEdges = (graph, edges_sets, epsilon = 1e-6) => {
		const edges_sets_keys = edges_sets.map(arr => arr.join(" "));
		// intersectingSets_edges will be a dictionary of pairs of groups: "3 15"
		// indicating that there is an intersection between these two planes,
		// and the value is an array of all edges along that intersection.
		const intersectingSets_edges = {};
		edges_sets_keys.forEach((key, i) => {
			if (intersectingSets_edges[key] === undefined) {
				intersectingSets_edges[key] = [];
			}
			intersectingSets_edges[key].push(i);
		});
		// we are looking for tortilla-tortilla cases so we need two or more edges.
		// remove an intersectingSets_edges if it contains only one edge.
		Object.keys(intersectingSets_edges)
			.filter(key => intersectingSets_edges[key].length < 2)
			.forEach(key => delete intersectingSets_edges[key]);
		// every intersection line contains two or more edges. turn this list
		// into a pairwise combination where every pair of edges is made.
		// not all pairs of two edges will actually overlap geometrically
		// but we will filter those in the next step.
		const intersectingSets_pairsAll = {};
		Object.keys(intersectingSets_edges).forEach(key => {
			intersectingSets_pairsAll[key] = chooseTwoPairs(intersectingSets_edges[key]);
		});
		const intersectingSets_pairsValid = {};
		// now, true or false if the edge pairs overlap
		Object.keys(intersectingSets_pairsAll).forEach(key => {
			// get a unit vector in the direction of the edges
			const firstEdge = intersectingSets_pairsAll[key][0][0];
			const coords = graph.edges_vertices[firstEdge]
				.map(v => graph.vertices_coords[v]);
			const vector = normalize(subtract(coords[1], coords[0]));
			// get one of the groups to get a plane/normal
			// const group = parseInt(key.split(" ")[0], 10);
			intersectingSets_pairsValid[key] = intersectingSets_pairsAll[key]
				.map(pair => doEdgesOverlap(graph, pair, vector, epsilon));
		});
		const intersectingSets_pairs = {};
		Object.keys(intersectingSets_pairsAll).forEach(key => {
			intersectingSets_pairs[key] = intersectingSets_pairsAll[key]
				.filter((_, i) => intersectingSets_pairsValid[key][i]);
		});
		// console.log("intersectingSets_edges", intersectingSets_edges);
		// console.log("intersectingSets_pairsAll", intersectingSets_pairsAll);
		// console.log("intersectingSets_pairsValid", intersectingSets_pairsValid);
		// console.log("intersectingSets_pairs", intersectingSets_pairs);
		return Object.keys(intersectingSets_pairs)
			.flatMap(key => intersectingSets_pairs[key]);
	};
	/**
	 * @description For a 3D folded model, this will find the places
	 * where two planes meet along collinear edges, these joining of two
	 * planes creates a tortilla-tortilla relationship.
	 */
	const make3DTortillas = (graph, faces_set, edges_set, epsilon = 1e-6) => {
		const tortilla_edges = make3DTortillaEdges(graph, edges_set, epsilon);
		const tortilla_faces = tortilla_edges
			.map(pair => pair
				.map(edge => graph.edges_faces[edge]));
		// make sure to sort the faces of the tacos on the correct side so that
		// the two faces in the same plane are on the same side of the edge.
		// [[A,X], [B,Y]], A and B are connected faces, X and Y are connected
		// and A and X are in the same plane, B and Y are in the same plane.
		tortilla_faces.forEach((tacos, i) => {
			if (faces_set[tacos[0][0]] !== faces_set[tacos[1][0]]) {
				tortilla_faces[i][1].reverse();
			}
		});
		// finally, each face's shared planar group chose a normal to the plane
		// according to only one of its faces, it could also have chosen the
		// flip of this normal. this normal will be used at the end of the solver
		// to re-orient all faces in their plane. we need to determine if the two
		// plane normals involved here are consistent across the edge, across two
		// neighbor faces, or is one flipped from the other, and if it's flipped,
		// we need to...
		// i think...
		// flip one of the pairs so that it looks like A joins Y and B joins X.
		// const normalsMatch = tortilla_faces
		// 	// get two adjacent faces from the two distinct planar groups
		// 	.map(tortillas => [tortillas[0][0], tortillas[1][0]])
		// 	.map(faces => faces.map(face => overlapInfo.faces_winding[face]))
		// 	.map(orients => orients[0] === orients[1]);
		// normalsMatch
		// 	.map((match, i) => (!match ? i : undefined))
		// 	.filter(a => a !== undefined)
		// 	.forEach(i => tortilla_faces[i][1].reverse());
		// console.log("tortilla_edges", tortilla_edges);
		// console.log("tortilla_faces", tortilla_faces);
		// console.log("normalsMatch", normalsMatch);
		return tortilla_faces;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const segmentPolygonOverlap2Exclusive = (segment, polygon, epsilon) => {
		const point_in_poly = segment
			.map(point => overlapConvexPolygonPoint(
				polygon,
				point,
				exclude,
				epsilon,
			)).reduce((a, b) => a || b, false);
		if (point_in_poly) { return true; }
		const edge_intersect = intersectConvexPolygonLine(
			polygon,
			{ vector: subtract2(segment[1], segment[0]), origin: segment[0] },
			excludeS,
			excludeS,
			epsilon,
		);
		if (edge_intersect) { return true; }
		return false;
	};
	/**
	 * @description For a 3D folded model, this will find the places
	 * where two planes meet along collinear edges, these joining of two
	 * planes creates a tortilla-tortilla relationship.
	 */
	const make3DTacoTortillas = (
		graph,
		sets_facePairs,
		sets_transformXY,
		faces_set,
		faces_polygon,
		edges_sets,
		epsilon = 1e-6,
	) => {
		if (sets_facePairs.length < 2) { return []; }
		const sets_face_pairs = sets_facePairs
			.map(set => set
				.map(pair => pair.split(" ").map(n => parseInt(n, 10))));
		const sets_facesSet = sets_face_pairs
			.map(pairs => pairs
				.flat()
				.sort((a, b) => a - b));
		const sets_faces = sets_facesSet.map(faces => [...new Set(faces)]);
		const edges_facesLookup = graph.edges_faces
			.map(faces => {
				const lookup = {};
				faces.forEach(face => { lookup[face] = {}; });
				return lookup;
			});
		const edges_possibleOverlapFaces = edges_sets
			.map((sets, edge) => sets
				.flatMap(set => sets_faces[set])
				.filter(face => !edges_facesLookup[edge][face]));
		const edges_possibleOverlapOtherFaces = edges_sets
			.map((sets, edge) => sets
				.flatMap(set => sets_faces[set])
				.filter(face => edges_facesLookup[edge][face]));
		// we only want to be dealing with edges which are 3D.
		// these are the flat angles. delete them
		edges_possibleOverlapFaces
			.map((_, e) => (edgeFoldAngleIsFlat(graph.edges_foldAngle[e])
				? e : undefined))
			.filter(a => a !== undefined)
			.forEach(e => {
				delete edges_possibleOverlapFaces[e];
				delete edges_possibleOverlapOtherFaces[e];
			});
		const edges_segment3D = edges_possibleOverlapFaces
			.map((_, e) => graph.edges_vertices[e]
				.map(v => graph.vertices_coords[v]));
		const edgeFaceOverlapBoolean = edges_possibleOverlapFaces
			.map((faces, edge) => faces
				.map(face => segmentPolygonOverlap2Exclusive(
					edges_segment3D[edge]
						.map(point => multiplyMatrix4Vector3(
							sets_transformXY[faces_set[face]],
							point,
						)),
					faces_polygon[face],
					epsilon,
				)));
		// const edgeFaceOverlap = edgeFaceOverlapBoolean
		// 	.map((faces, i) => faces
		// 		.map((overlap, j) => (overlap
		// 			? edges_possibleOverlapFaces[i][j]
		// 			: undefined))
		// 		.filter(a => a !== undefined));
		// const edgeFaceOverlapOtherFace = edgeFaceOverlapBoolean
		// 	.map((faces, i) => faces
		// 		.map((overlap, j) => (overlap
		// 			? edges_possibleOverlapOtherFaces[i][j]
		// 			: undefined))
		// 		.filter(a => a !== undefined));
		const results = edgeFaceOverlapBoolean
			.flatMap((faces, i) => faces
				.map((overlap, j) => (overlap
					? ({
						edge: i,
						face: edges_possibleOverlapFaces[i][j],
						otherFace: edges_possibleOverlapOtherFaces[i][j],
					})
					: undefined))
				.filter(a => a !== undefined));
		console.log("make3DTacoTortillas");
		console.log("sets_facePairs", sets_facePairs);
		console.log("edges_sets", edges_sets);
		console.log("sets_face_pairs", sets_face_pairs);
		console.log("sets_faces", sets_faces);
		console.log("edges_possibleOverlapFaces", edges_possibleOverlapFaces);
		console.log("edges_possibleOverlapOtherFaces", edges_possibleOverlapOtherFaces);
		console.log("edges_segment3D", edges_segment3D);
		// console.log("edges_transform", edges_transform);
		// console.log("edges_segment2D", edges_segment2D);
		console.log("results", results);
		return results;
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	const getEdgesSetsInTwoPlanes = (graph, faces_set) => {
		// find edges which are in two sets
		const edges_sets_lookup = graph.edges_vertices.map(() => ({}));
		faces_set
			.forEach((set, face) => graph.faces_edges[face]
				.forEach(edge => { edges_sets_lookup[edge][set] = true; }));
		// for every edge, which co-planar group does it appear in
		const edges_sets = edges_sets_lookup
			.map(o => Object.keys(o)
				.map(n => parseInt(n, 10)));
		// if an edge only appears in one group, delete the entry from the array
		// this will create an array with holes, maintaining edge's indices.
		edges_sets.forEach((arr, i) => {
			if (arr.length !== 2) { delete edges_sets[i]; }
		});
		// ensure entries in edges_sets are sorted
		edges_sets.forEach((arr, i) => {
			if (arr[0] > arr[1]) { edges_sets[i].reverse(); }
		});
		return edges_sets;
	};

	/**
	 * todo: bad code. n^2
	 */
	const makeFacesFacesOverlap = (graph, sets_faces, faces_polygon, epsilon) => {
		const faces_facesOverlapMatrix = graph.faces_vertices.map(() => []);
		sets_faces.forEach(set_faces => {
			for (let i = 0; i < set_faces.length - 1; i += 1) {
				for (let j = i + 1; j < set_faces.length; j += 1) {
					const faces = [set_faces[i], set_faces[j]];
					const polygons = faces.map(f => faces_polygon[f]);
					const overlap = overlapConvexPolygons(...polygons, epsilon);
					if (overlap) {
						faces_facesOverlapMatrix[faces[0]][faces[1]] = true;
						faces_facesOverlapMatrix[faces[1]][faces[0]] = true;
					}
				}
			}
		});
		return faces_facesOverlapMatrix
			.map(overlap => overlap
				.map((_, i) => i)
				.filter(a => a !== undefined));
	};
	/**
	 * @description make copies of 
	 */
	const graphGroupCopies = (graph, sets_faces, sets_transform) => {
		// transform point by a matrix, return result as 2D
		const transformTo2D = (matrix, point) => {
			const p = multiplyMatrix4Vector3(matrix, point);
			return [p[0], p[1]];
		};
		// coerce all vertices into 3D in case they are not already
		const vertices_coords_3d = graph.vertices_coords
			.map(coord => resize(3, coord));
		// make shallow copies of the graph, one for every group
		const copies = sets_faces.map(faces => subgraphWithFaces(graph, faces));
		// transform all vertices_coords by the inverse transform
		// to bring them all into the XY plane. convert to 2D
		sets_transform.forEach((matrix, i) => {
			copies[i].vertices_coords = copies[i].vertices_coords
				.map((_, v) => transformTo2D(matrix, vertices_coords_3d[v]));
		});
		return copies;
	};

	const prepare = (graphInput, epsilon = 1e-6) => {
		// shallow copy the user input graph so we don't modify it.
		const graph = { ...graphInput };
		// ensure this data is here because 
		if (!graph.faces_edges) {
			graph.faces_edges = makeFacesEdgesFromVertices(graph);
		}
		if (!graph.edges_faces) {
			graph.edges_faces = makeEdgesFacesUnsorted(graph);
		}
		// edges_foldAngle needs to be present so we can ignore foldAngles
		// which are not flat when doing taco/tortilla things. if we need to
		// build it here, all of them are flat, but we need the array to exist
		if (!graph.edges_foldAngle && graph.edges_assignment) {
			graph.edges_foldAngle = makeEdgesFoldAngle(graph);
		}
		// separate the group into coplanar overlapping sets
		const {
			sets_faces,
			// sets_plane,
			sets_transformXY,
			faces_set,
			faces_winding,
			// faces_facesOverlap,
		} = coplanarOverlappingFacesGroups(graph, epsilon);
		// const overlapInfo = coplanarOverlappingFacesGroups(graph, epsilon);
		// const overlapInfo = disjointFacePlaneSets(graph, epsilon);
		// const sets_faces = invertMap(faces_set)
		// 	.map(el => (el.constructor === Array ? el : [el]));
		// all vertices_coords will become 2D
		const graphCopies = graphGroupCopies(
			graph,
			sets_faces,
			sets_transformXY,
		);
		// convert faces into polygons, ordered set of points, not necessarily
		// matching the winding in the original face because all faces will be
		// made to be counter clockwise. using faces_winding, flip it if needed.
		// additionally, makeFacesPolygon ensures no collinear vertices exist.
		const faces_polygon = [];
		graphCopies
			.map(copy => makeFacesPolygon(copy, epsilon))
			.forEach(faces => faces
				.forEach((polygon, f) => { faces_polygon[f] = polygon; }));
		// reverse order of points if the winding is flipped.
		// all faces_polygon are now counter-clockwise and in the XY plane.
		faces_winding
			.map((upright, i) => (upright ? undefined : i))
			.filter(a => a !== undefined)
			.forEach(f => faces_polygon[f].reverse());
		// simple faces center by averaging all the face's vertices
		const faces_center = faces_polygon
			.map(polygon => polygon
				.reduce((a, b) => add2(a, b), [0, 0])
				.map(el => el / polygon.length));
		// populate faces_center into each of the graph copies
		graphCopies.forEach(el => {
			el.faces_center = el.faces_vertices.map((_, i) => faces_center[i]);
		});
		const faces_facesOverlap = makeFacesFacesOverlap(
			graph,
			sets_faces,
			faces_polygon,
			epsilon,
		);
		// now that we have all faces separated into coplanar-overlapping sets,
		// run the 2D taco/tortilla algorithms on each set individually,
		// until we get to make3DTortillas, which will work across coplanar sets
		const sets_tacos_tortillas = graphCopies
			.map(el => makeTacosTortillas(el, epsilon));
		const sets_unfiltered_trios = graphCopies
			.map(el => makeTransitivityTrios(el, faces_facesOverlap, epsilon));
		const sets_transitivity_trios = sets_unfiltered_trios
			.map((trios, i) => filterTransitivity(trios, sets_tacos_tortillas[i]));
		const sets_constraints = sets_tacos_tortillas
			.map((tacos_tortillas, i) => makeConstraints(
				tacos_tortillas,
				sets_transitivity_trios[i],
			));
		const facePairsInts = selfRelationalUniqueIndexPairs(faces_facesOverlap);
		const facePairs = facePairsInts.map(pair => pair.join(" "));
		// const sets_edgeAdjacentOrders = graphCopies
		// 	.map(el => solveEdgeAdjacent(el, facePairs, overlapInfo.faces_winding));
		const facePairsIndex_group = facePairsInts
			.map(pair => faces_set[pair[0]]);
		const sets_facePairsIndex = invertMap(facePairsIndex_group)
			.map(el => (el.constructor === Array ? el : [el]));
		const sets_facePairsWithHoles = sets_facePairsIndex
			.map(indices => indices.map(i => facePairs[i]));
		const sets_facePairs = sets_constraints
			.map((_, i) => (sets_facePairsWithHoles[i] ? sets_facePairsWithHoles[i] : []));
		// for each edge, which set(s) is it a member of, this method
		// only finds those which are in two sets, as the ones in one
		// set only is not interesting to us
		const edges_sets = getEdgesSetsInTwoPlanes(graph, faces_set);

		const tortillas3D = make3DTortillas(graph, faces_set, edges_sets, epsilon)
			.map(el => [
				// el[0][0], el[1][0], el[0][1], el[1][1],
				...el[0], ...el[1],
			]);
		const tacoTortillas3D = make3DTacoTortillas(
			graph,
			sets_facePairs,
			sets_transformXY,
			faces_set,
			faces_polygon,
			edges_sets,
			epsilon,
		);
		tacoTortillas3D
			.map(el => [el.face, el.otherFace].map(f => faces_winding[f]));
		const tt3dKeysOrdered = tacoTortillas3D
			.map(el => el.face < el.otherFace);
		const tt3dKeys = tacoTortillas3D
			.map((el, i) => (tt3dKeysOrdered[i]
				? [el.face, el.otherFace]
				: [el.otherFace, el.face]))
			.map(pair => pair.join(" "));
		const signOrder = { "-1": 2, 1: 1, 0: 0 };
		const tt3dOrders = tacoTortillas3D
			.map(el => Math.sign(graph.edges_foldAngle[el.edge]))
			// .map((sign, i) => {
			// 	// needs some complicated thing here
			// 	const flip = (tt3dKeysOrdered[i] ? tt3dWindings[i][0] : tt3dWindings[i][1]);
			// 	return flip ? -1 * sign : sign;
			// })
			.map(sign => signOrder[sign]);

		console.log("tacoTortillas3D", tacoTortillas3D);
		// console.log("tt3dWindings", tt3dWindings);
		// console.log("tt3dKeysOrdered", tt3dKeysOrdered);
		// console.log("tt3dKeys", tt3dKeys);
		// console.log("tt3dOrders", tt3dOrders);

		// console.log("sets_transformXY", sets_transformXY);
		// console.log("faces_set", faces_set);
		// console.log("sets_faces", sets_faces);
		// console.log("faces_winding", faces_winding);
		// console.log("faces_facesOverlap", faces_facesOverlap);
		// console.log("graphCopies", graphCopies);
		// console.log("faces_polygon", faces_polygon);
		// console.log("faces_center", faces_center);
		// console.log("sets_tacos_tortillas", sets_tacos_tortillas);
		// console.log("sets_unfiltered_trios", sets_unfiltered_trios);
		// console.log("sets_transitivity_trios", sets_transitivity_trios);
		// console.log("sets_constraints", sets_constraints);
		// // console.log("sets_constraintsLookup", sets_constraintsLookup);
		// console.log("facePairsInts", facePairsInts);
		// console.log("facePairs", facePairs);
		// // console.log("sets_edgeAdjacentOrders", sets_edgeAdjacentOrders);
		// console.log("facePairsIndex_group", facePairsIndex_group);
		// console.log("sets_facePairsIndex", sets_facePairsIndex);
		// console.log("sets_facePairs", sets_facePairsWithHoles);
		// console.log("edges_sets", edges_sets);
		// console.log("tortillas3D", tortillas3D);
		// console.log("tacoTortillas3D", tacoTortillas3D);
		// now we join all the data from the separate groups together.
		const constraints = {
			taco_taco: [],
			taco_tortilla: [],
			tortilla_tortilla: [],
			transitivity: [],
		};
		sets_constraints.forEach(group => {
			constraints.taco_taco.push(...group.taco_taco);
			constraints.taco_tortilla.push(...group.taco_tortilla);
			constraints.tortilla_tortilla.push(...group.tortilla_tortilla);
			constraints.transitivity.push(...group.transitivity);
		});
		constraints.tortilla_tortilla.push(...tortillas3D);
		const constraintsLookup = makeConstraintsLookup(constraints);
		const facePairsFlat = sets_facePairs.flat();
		const edgeAdjacentOrders = solveEdgeAdjacentFacePairs(graph, facePairs, faces_winding);
		// const edgeAdjacentOrders = {};
		console.log("constraints", constraints);
		console.log("constraintsLookup", constraintsLookup);
		console.log("facePairsFlat", facePairsFlat);
		console.log("edgeAdjacentOrders", edgeAdjacentOrders);

		tt3dKeys.forEach((key, i) => { edgeAdjacentOrders[key] = tt3dOrders[i]; });

		return {
			constraints,
			constraintsLookup,
			facePairs: facePairsFlat,
			edgeAdjacentOrders,
			faces_winding,
		};
		// return {
		// 	sets_constraints,
		// 	sets_constraintsLookup,
		// 	sets_facePairs,
		// 	sets_edgeAdjacentOrders,
		// 	faces_winding,
		// };
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	// [1, 2, 3], ["a", "b", "c"], ["$", "%", "&"]
	// 1a$, 1a%, 1a&
	// 1b$, 1b%, 1b&
	// 1c$, 1c%, 1c&
	// 2a$, 2a%, 2a&
	// ... (27 total)
	/**
	 * @param {any[][]} arrayOfArrays two-level nested array containing any type
	 */
	const matchHolistic = (arrayOfArrays) => {
		const lengths = arrayOfArrays.map(part => part.length);
		const compounding = lengths.slice();
		for (let i = compounding.length - 2; i >= 0; i -= 1) {
			compounding[i] *= compounding[i + 1];
		}
		if (compounding[0] > (2 ** 28)) {
			console.warn("allSolutions() might fail: too many");
		}
		const scales = compounding.slice();
		scales.push(1);
		scales.shift();
		return Array.from(Array(compounding[0]))
			.map((_, i) => i)
			.map(i => scales
				.map((d, j) => Math.floor(i / d) % lengths[j]));
	};
	/**
	 *
	 */
	const allSolutions = (n, ...orders) => {
		const ordersSoFar = n.orders ? [...orders, n.orders] : [...orders];
		// partition node
		if (n.partitions) {
			const parts = n.partitions.map(el => allSolutions(el));
			const combinations = matchHolistic(parts);
			return combinations
				.map(indices => indices.flatMap((i, j) => parts[j][i]))
				.map(solution => [...ordersSoFar, ...solution]);
		}
		// not a partition node
		// get all solutions from all combined recursive branching
		const solutions = [];
		if (n.leaves) {
			n.leaves.forEach(order => solutions.push([...ordersSoFar, order]));
		}
		if (n.node) {
			const branches = n.node
				.flatMap(el => allSolutions(el, ...ordersSoFar));
			solutions.push(...branches);
		}
		if (!n.leaves && !n.node) { solutions.push([...ordersSoFar]); }
		return solutions;
	};
	/**
	 *
	 */
	const anySolution = (n) => {
		const nodeOrders = n.orders ? n.orders : [];
		// partition node
		if (n.partitions) {
			return [...nodeOrders, ...n.partitions.flatMap(el => anySolution(el))];
		}
		// not a partition node
		// get all solutions from all combined recursive branching
		if (n.leaves) { return [...nodeOrders, ...n.leaves[0]]; }
		if (n.node) { return [...nodeOrders, ...anySolution(n.node[0])]; }
		// no leaves or node (the root node / one solution only)
		return nodeOrders;
	};
	// const anySolution = (n) => {
	// 	const nodeOrders = n.orders ? n.orders : [];
	// 	// partition node
	// 	if (n.partitions) {
	// 		return [...nodeOrders, ...n.partitions.map(el => anySolution(el))];
	// 	}
	// 	// not a partition node
	// 	// get all solutions from all combined recursive branching
	// 	if (n.leaves) { return [...nodeOrders, ...n.leaves[n.leaves.length - 1]]; }
	// 	if (n.node) { return [...nodeOrders, ...anySolution(n.node[n.node.length - 1])]; }
	// 	// no leaves or node (the root node / one solution only)
	// 	return nodeOrders;
	// };
	/**
	 *
	 */
	const LayerPrototype = {
		// anySolution: function () {
		// 	return this.groups.flatMap(group => anySolution(group));
		// },
		anySolution: function () { return anySolution(this); },
		// allSolutions: function () {
		// 	if (!this.allSolutionsMemo) {
		// 		this.allSolutionsMemo = this.groups
		// 			.map(group => allSolutions(group));
		// 	}
		// 	return this.allSolutionsMemo;
		// },
		allSolutions: function () {
			if (!this.allSolutionsMemo) {
				this.allSolutionsMemo = allSolutions(this);
			}
			return this.allSolutionsMemo;
		},
		/**
		 * @description For every branch, get the total number of states.
		 * @returns {number[]} the total number of states in each branch.
		 * @linkcode Origami ./src/layer/solver3d/prototype.js 101
		 */
		// count: function () {
		// 	return this.allSolutions().map(solution => solution.length);
		// },
		count: function () { return this.allSolutions().length; },
		/**
		 * @description Get one complete layer solution by merging the
		 * root solution with one state from each branch.
		 * @param {number[]} ...indices optionally specify which state from
		 * each branch, otherwise this will return index 0 from each branch.
		 * @returns {object} an object with space-separated face pair keys, with
		 * a value of +1 or -1, indicating the stacking order between the pair.
		 * @linkcode Origami ./src/layer/solver3d/prototype.js 114
		 */
		// solution: function (groupIndices = []) {
		// 	const solutions = this.allSolutions();
		// 	const indices = Array(solutions.length)
		// 		.fill(0)
		// 		.map((n, i) => (groupIndices[i] != null ? groupIndices[i] : n));
		// 	return solutions
		// 		.flatMap((solution, i) => solution[indices[i]].flat());
		// },
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */
	/**
	 * @description Given an array of unsolved facePair keys, attempt to solve
	 * the entire set by guessing both states (1, 2) for one key, propagate any
	 * implications, repeat another guess (1, 2) on another key, propagate, repeat...
	 * This method is recursive but will only branch a maximum of two times each
	 * recursion (one for each guess 1, 2). For each recursion, all solutions are
	 * gathered into a single object, and that round's solved facePairs are added
	 * to the "...orders" parameter. When all unsolvedKeys are solved, the result
	 * is an array of solutions, each solving represeting the set of solutions from
	 * each depth. Combine these solutions using Object.assign({}, ...orders)
	 * @param {Constraints} constraints an object containing all four cases, inside
	 * of each is an (very large, typically) array of all constraints as a list of faces.
	 * @param {object} constraintsLookup a map which contains, for every
	 * taco/tortilla/transitivity case (top level keys), inside each is an object
	 * which relates each facePair (key) to an array of indices (value),
	 * where each index is an index in the "constraints" array
	 * in which **both** of these faces appear.
	 * @param {string[]} unsolvedKeys array of facePair keys to be solved
	 * @param {...object} ...orders any number of facePairsOrder solutions
	 * which relate facePairs (key) like "3 5" to an order, either 0, 1, or 2.
	 * @linkcode Origami ./src/layer/solver3d/index.js 31
	 */
	const solveNonBranchingNode = (
		constraints,
		constraintsLookup,
		unsolvedKeys,
		solvedOrders,
		...orders
	) => {
		if (!unsolvedKeys.length) { return {}; }
		const guessKey = unsolvedKeys[0];
		const completedSolutions = [];
		const unfinishedSolutions = [];
		// given the same guessKey with both 1 and 2 as the guess, run propagate.
		[1, 2].forEach(b => {
			const result = propagate(
				constraints,
				constraintsLookup,
				[guessKey],
				...solvedOrders,
				...orders,
				{ [guessKey]: b },
			);
			// bad results will be false. skip these. if the result is valid,
			// check if all variables are solved or more work is required.
			if (result === false) { return; }
			// currently, the one guess itself is left out of the result object.
			// we could either combine the objects, or add this guess directly in.
			result[guessKey] = b;
			// store the result as either completed or unfinished
			const array = Object.keys(result).length === unsolvedKeys.length
				? completedSolutions
				: unfinishedSolutions;
			array.push(result);
		});
		// solution contains leaves and (recursive) nodes, only if non-empty.
		const solution = {
			leaves: completedSolutions,
			node: unfinishedSolutions.map(order => solveNode(
				constraints,
				constraintsLookup,
				unsolvedKeys.filter(key => !(key in order)),
				[...solvedOrders, ...orders],
				order,
			)),
		};
		if (solution.leaves.length === 0) { delete solution.leaves; }
		if (solution.node.length === 0) { delete solution.node; }
		return solution;
	};
	/**
	 * @description Before we solve each node, check to see if there are
	 * any disjoint sets, if so, create a branch where each individual
	 * disjoint set gets solved and the branch structure is preserved.
	 * If no disjoint sets, solve and return the node.
	 */
	const solveNode = (
		constraints,
		constraintsLookup,
		remainingKeys,
		solvedOrders,
		...orders
	) => {
		if (!remainingKeys.length) { return { orders }; }
		const disjointSets = getDisjointSets(
			remainingKeys,
			constraints,
			constraintsLookup,
			// tortillaSets,
			// tortillaSetsLookup,
		);
		// console.log("disjointSets", disjointSets);
		if (disjointSets.length > 1) {
			// console.log("FOUND disjointSets", disjointSets);
			return {
				orders,
				partitions: disjointSets
					.map(branchKeys => solveNonBranchingNode(
						constraints,
						constraintsLookup,
						branchKeys,
						solvedOrders,
						...orders,
					)),
			};
		}
		return {
			orders,
			...solveNonBranchingNode(
				constraints,
				constraintsLookup,
				disjointSets[0],
				solvedOrders,
				...orders,
			),
		};
	};
	/**
	 * @name solver
	 * @memberof layer
	 * @description Recursively calculate all layer order solutions between faces
	 * in a flat-folded FOLD graph.
	 * @param {FOLD} graph a flat-folded FOLD graph, where the vertices
	 * have already been folded.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a set of solutions where keys are face pairs
	 * and values are +1 or -1 describing the relationship of the two faces.
	 * Results are stored in "root" and "partitions", to compile a complete solution,
	 * append the "root" to one selection from each array in "partitions".
	 * @linkcode Origami ./src/layer/solver3d/index.js 140
	 */
	const groupLayerSolver = (
		constraints,
		constraintsLookup,
		facePairs,
		edgeAdjacentOrders,
		faces_winding,
	) => {
		// propagate layer order starting with only the edge-adjacent face orders
		const initialResult = propagate(
			constraints,
			constraintsLookup,
			Object.keys(edgeAdjacentOrders),
			edgeAdjacentOrders,
		);
		// graph does not have a valid layer order. no solution
		if (!initialResult) { return undefined; }
		// get all keys unsolved after the first round of propagate
		const remainingKeys = facePairs
			.filter(key => !(key in edgeAdjacentOrders))
			.filter(key => !(key in initialResult));
		// group the remaining keys into groups that are isolated from one another.
		// recursively solve each branch, each branch could have more than one solution.
		const solution = solveNode(
			constraints,
			constraintsLookup,
			remainingKeys,
			[],
			edgeAdjacentOrders,
			initialResult,
		);
		return reformatSolution(solution, faces_winding);
	};
	/**
	 * @name solver
	 * @memberof layer
	 * @description Recursively calculate all layer order solutions between
	 * co-planar faces in a 2D or 3D FOLD graph.
	 * @param {FOLD} graph a flat-folded FOLD graph, where the vertices
	 * have already been folded.
	 * @param {number} [epsilon=1e-6] an optional epsilon
	 * @returns {object} a set of solutions where keys are face pairs
	 * and values are +1 or -1 describing the relationship of the two faces.
	 * Results are stored in "root" and "partitions", to compile a complete solution,
	 * append the "root" to one selection from each array in "partitions".
	 * @linkcode Origami ./src/layer/solver3d/index.js 186
	 */
	// const globalLayerSolver = (graph, epsilon = 1e-6) => {
	// 	const {
	// 		groups_constraints,
	// 		groups_constraintsLookup,
	// 		groups_facePairs,
	// 		groups_edgeAdjacentOrders,
	// 		faces_winding,
	// 	} = prepare(graph, epsilon);
	// 	// console.log("groups_constraints", groups_constraints);
	// 	// console.log("groups_constraintsLookup", groups_constraintsLookup);
	// 	// console.log("groups_facePairs", groups_facePairs);
	// 	// console.log("groups_edgeAdjacentOrders", groups_edgeAdjacentOrders);
	// 	// console.log("faces_winding", faces_winding);
	// 	const solutions = groups_constraints.map((constraints, i) => groupLayerSolver(
	// 		constraints,
	// 		groups_constraintsLookup[i],
	// 		groups_facePairs[i],
	// 		groups_edgeAdjacentOrders[i],
	// 		faces_winding,
	// 	)).filter(solution => solution && solution.orders.length);
	// 	return Object.assign(
	// 		Object.create(LayerPrototype),
	// 		{ groups: solutions },
	// 	);
	// };
	/**
	 * @description This layer solver extends the taco/tortilla method by Jason Ku
	 * into 3D by largely sorting faces into groups of coplanar-overlapping faces
	 * and adding a few new types of constraints which join faces between groups.
	 * This algorithm still requires faces be convex, and faces must be planar.
	 */
	const globalLayerSolver = (graph, epsilon = 1e-6) => {
		const {
			constraints,
			constraintsLookup,
			facePairs,
			edgeAdjacentOrders,
			faces_winding,
		} = prepare(graph, epsilon);
		const solution = groupLayerSolver(
			constraints,
			constraintsLookup,
			facePairs,
			edgeAdjacentOrders,
			faces_winding,
		);
		return Object.assign(
			Object.create(LayerPrototype),
			solution,
		);
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// import table from "./solver2d/table.js";
	// import * as makeConstraints from "./solver2d/makeConstraints.js";
	// import * as makeFacePairsOrder from "./solver2d/makeFacePairsOrder.js";
	// import * as globalSolverGeneral from "./solver2d/general.js";
	// import makeTacosTortillas from "./solver2d/tacos/makeTacosTortillas.js";
	// import makeFoldedStripTacos from "./solver2d/tacos/makeFoldedStripTacos.js";
	// import makeTransitivityTrios from "./solver2d/tacos/makeTransitivityTrios.js";
	// import * as tortillaTortilla from "./solver2d/tacos/tortillaTortilla.js";

	/**
	 * @description A collection of methods for calculating the layer order
	 * of the faces of an origami in its folded state.
	 */
	var layer = {
		solver: globalLayerSolver,
		// solver2d,
		// table,
		topologicalOrder,
		// makeTacosTortillas,
		// makeFoldedStripTacos,
		// makeTransitivityTrios,

		singleVertexSolver,
		singleVertexAssignmentSolver: assignmentSolver,
		// validateLayerSolver,
		// validateTacoTacoFacePairs,
		// validateTacoTortillaStrip,
		foldStripWithAssignments,
		...general,
		...nudge,
		...facesLayer,
		// makeConstraints,
		// makeFacePairsOrder,
		// globalSolverGeneral,
		// tortillaTortilla,
	};

	/**
	 * Rabbit Ear (c) Kraft
	 */

	// append graph methods as children of the graph constructor
	Object.assign(graph, graphMethods);
	/**
	 * Rabbit Ear
	 */
	const ear = {
		graph,
		cp,
		origami,
		axiom,
		convert,
		math,
		singleVertex,
		svg: SVG,
		webgl,
		// diagram,
		layer,
		// text,
	};

	// svg library needs a pointer to rabbit-ear
	lib.ear = ear;

	// give the user the ability to set the window
	// this allows DOM operations (svg) inside node or deno
	Object.defineProperty(ear, "window", {
		enumerable: false,
		set: value => { SVG.window = setWindow(value); },
	});

	return ear;

}));
